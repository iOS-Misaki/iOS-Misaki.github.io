<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki的小站</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/iOS-Misaki.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/"/>
  <updated>2018-12-31T09:21:43.527Z</updated>
  <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018年年终总结</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/12/31/2018%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/12/31/2018年年终总结/</id>
    <published>2018-12-31T09:21:06.000Z</published>
    <updated>2018-12-31T09:21:43.527Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;12月一整个月的996，弄得整个人身心交瘁，趁着元旦休息的时间，赶在2018年最后一天，年终总结一下。</p><a id="more"></a><p>&ensp;&ensp;&ensp;&ensp;进入新公司的主要工作是，用原生代码实现PaaS电商项目的整个流程，然后将基本功能，例如UM、购物车、订单、售后、收藏等全部解耦出来，一个个打成私有库，主工程来引入私有库的方式完成组件化。当然还有公司其他接手的五六个项目，修改迭代，没有什么难度，但是繁琐。总是在忙着PaaS项目，做着做着就被打断处理这些零碎的项目。从交付项目结果来看，还是事与愿违😂。交付的项目核心业务都是前端用Vue来完成的，App就是用<code>WebView</code>来展示，通过JS和原生代码的交互，来调用原生的登录登出、支付等，原生的部分只有UM模块和支付模块。<strong>这个还用得着组件化么😂😂😂</strong>。</p><p>&ensp;&ensp;&ensp;&ensp;再来看看个人技术成长。可以与2017年做个对比，17年初的时候主要精力在学习<code>Swift</code>语言新特性，17年下半年到今年上半年，主要精力放在了<code>Angular</code>和<code>HTML</code>、<code>JavaScript</code>上面。在迭代熊猫保保的时候，iOS开发任务不饱和，工作内容也变成一小半原生开发，一大半前端<code>Angular</code>开发。今年开通了<a href="https://juejin.im/user/5ab886906fb9a028b547df12" target="_blank" rel="noopener">掘金专栏</a>，<strong>还搭建了<a href="https://ios-misaki.github.io/" target="_blank" rel="noopener">个人博客</a>，算上今天，一共写了12篇文章</strong>，和年初订下的每半个月写篇技术博客目标差距不小。要想技术博客不流于形式（主要是17年上半年之前的在<a href="https://www.jianshu.com/u/abb55beb0e35" target="_blank" rel="noopener">简书</a>发表的文章都太过于形式化了），持续有内容有深度，实现年初的目标感觉很困难。在新工作后，就没有横向发展了，还是专攻iOS这块。12篇文章中有4篇都和组件化相关，包括搭建私有库、模块间解耦、组件之间通讯都有不少收获。除了这些，还阅读了<code>SDWebImage</code>、<code>YTKNetwork</code>和<code>AFNetworking</code>的部分源码，整理了<code>Runtime</code>的相关用法，学习了<code>CAAnimation</code>动画和自定义转场动画。</p><p>&ensp;&ensp;&ensp;&ensp;从年中跳槽经历的面试结果来看，iOS开发还是以<code>OC</code>语言为主，面试中仅有一家提出项目是用<code>Swift</code>语言完成，大多数会<code>Swift</code>只是一个加分项。但是原生iOS这块需求被大前端蚕食，大一点的公司除了要求对底层原理非常了解外，还需要对深度优化App要有一定见解，小公司更看重除了iOS外，还要求跨平台能力，会<code>Ionic</code>或者<code>React Native</code>。最近风头很旺的<code>Flutter</code>也是跨平台的方案之一。今后的努力的方向还是两条线，一个是原生这块继续深入，一个前端方向重点学习HTML、JavaScript、CSS。<strong>前端框架和跨平台方案每年都推陈出新，学都学不完，只有这个三驾马车才是万变不离其宗</strong>。</p><p>&ensp;&ensp;&ensp;&ensp;今年除了工作和个人技术成长外，还有值得说道的地方（手动(ノへ￣、)捂脸）。正所谓手中有粮心中不慌。除了保险上有配置外，以前还有买定期的理财产品，虽然金额不多，但是能养成好的储蓄习惯。然而今年加大了在币圈的投入。个人之前秉持的是价值投资，买入的都是<code>EOS、ETH、AE、ADA、QTUM</code>等底层公链。到四五月份的小牛的时候，还有几万块的收益。遗憾的没有能在高位套现，拿着手中一直不动，坚信价值投资，反而加了杠杆，继续投资。后来的结果大家都知道，<code>BTC</code>从最高点近2万美元跌到最低3155美元，跌幅84%。<code>ETH</code>从840多跌到82，跌幅90%，龙头如此，其他币更不用说了。最要命的是，后面加了杠杆，在未来很长一段时间，都要为这个错误持续买单。我估计，头发稀少，快要谢顶不是因为加班敲代码，而是因为亏钱愁的（手动(ノへ￣、)捂脸）。<strong>还好扛了下来，心态没有崩溃</strong>。2019币圈还是谷底，这也是个机会，目前还在小额定投中。没有走完整个牛熊周期是很吃亏的，学会熊市低价攒筹码牛市高位抛售这个浅显道理花的代价实在太大了。</p><p>&ensp;&ensp;&ensp;&ensp;当然也不是完全的都是糟心事，2017没有坚持下来的健身，2018年完成了。除去周末，下班回家早的时候，都会健身房练练。形体慢慢出来了，体重最高的时候是150斤左右，现在不到135。相对体重变化，我更看重体脂的变化，今年最高23%到现在稳定维持16%左右，骨骼肌和基础代谢都有明显的增长。</p><p>&ensp;&ensp;&ensp;&ensp;2018年就这么跌跌撞撞的走过去了，还是想落入俗套地说一句“<strong>2018，再见！2019，你好！</strong>”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;12月一整个月的996，弄得整个人身心交瘁，趁着元旦休息的时间，赶在2018年最后一天，年终总结一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS缓存机制详解</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/12/01/iOS%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/12/01/iOS缓存机制详解/</id>
    <published>2018-12-01T10:04:20.000Z</published>
    <updated>2018-12-01T10:22:52.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren’t aware that NSURLCache could be setup in two lines and do it 100× better. Even more developers have never known the benefits of network caching, and never attempted a solution, causing their apps to make untold numbers of unnecessary requests to the server.<br>无数开发者尝试自己做一个丑陋而脆弱的系统来实现网络缓存的功能，殊不知NSURLCache只要两行代码就能搞定，并且好上100倍。甚至更多的开发者根本不知道网络缓存的好处，从来没有尝试过解决方案，导致他们的App向服务器发出无数不必要的请求。</p></blockquote><a id="more"></a><h2 id="iOS系统的缓存策略"><a href="#iOS系统的缓存策略" class="headerlink" title="iOS系统的缓存策略"></a>iOS系统的缓存策略</h2><p>&ensp;&ensp;&ensp;&ensp;上面是引用<code>Mattt</code>大神在<a href="https://nshipster.com/" target="_blank" rel="noopener">NSHipster</a>介绍NSURLCache时的原话。</p><h3 id="服务端的缓存策略"><a href="#服务端的缓存策略" class="headerlink" title="服务端的缓存策略"></a>服务端的缓存策略</h3><p>&ensp;&ensp;&ensp;&ensp;先看看服务端的缓存策略。当第一次请求后，客户端会缓存数据，当有第二次请求的时候，客户端会额外在请求头加上<code>If-Modified-Since</code>或者<code>If-None-Match</code>，<code>If-Modified-Since</code>会携带缓存的最后修改时间，服务端会把这个时间和实际文件的最后修改时间进行比较。</p><ul><li>相同就返回状态码304，且不返回数据，客户端拿出缓存数据，渲染页面</li><li>不同就返回状态码200，并且返回数据，客户端渲染页面，并且更新缓存</li></ul><p>&ensp;&ensp;&ensp;&ensp;当然类似的还有<code>Cache-Control</code>、<code>Expires</code>和<code>Etag</code>，都是为了校验本地缓存文件和服务端是否一致，这里就带过了。</p><h3 id="NSURLCache"><a href="#NSURLCache" class="headerlink" title="NSURLCache"></a>NSURLCache</h3><p>&ensp;&ensp;&ensp;&ensp;<code>NSURLCache</code>是iOS系统提供的内存以及磁盘的综合缓存机制。<code>NSURLCache</code>对象被存储沙盒中<code>Library/cache</code>目录下。在我们只需要在<code>didFinishLaunchingWithOptions</code>函数里面加上下面的代码，就可以满足一般的缓存要求。(是的，搞定NSURLCache就是这么简单)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLCache * sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:20 * 1024 *1024 diskCapacity:100 * 1024 * 1024 diskPath:nil];</span><br><span class="line">[NSURLCache setSharedURLCache:sharedCache];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;下面是几个常用的API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//设置内存缓存的最大容量</span><br><span class="line">[cache setMemoryCapacity:1024 * 1024 * 20];</span><br><span class="line"></span><br><span class="line">//设置磁盘缓存的最大容量</span><br><span class="line">[cache setDiskCapacity:1024 * 1024 * 100];</span><br><span class="line"></span><br><span class="line">//获取某个请求的缓存</span><br><span class="line">[cache cachedResponseForRequest:request];</span><br><span class="line"></span><br><span class="line">//清除某个请求的缓存</span><br><span class="line">[cache removeCachedResponseForRequest:request];</span><br><span class="line"></span><br><span class="line">//请求策略，设置了系统会自动用NSURLCache进行数据缓存</span><br><span class="line">request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;</span><br></pre></td></tr></table></figure></p><h3 id="iOS常用的缓存策略"><a href="#iOS常用的缓存策略" class="headerlink" title="iOS常用的缓存策略"></a>iOS常用的缓存策略</h3><p>&ensp;&ensp;&ensp;&ensp;<code>NSURLRequestCachePolicy</code>是个枚举，指的是不同的缓存策略，一共有7种，但是能用的只有4种。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)</span><br><span class="line">&#123;</span><br><span class="line">    //如果有协议，对于特定的URL请求，使用协议实现定义的缓存逻辑。(默认的缓存策略)</span><br><span class="line">    NSURLRequestUseProtocolCachePolicy = 0,</span><br><span class="line"></span><br><span class="line">    //请求仅从原始资源加载URL，不使用任何缓存</span><br><span class="line">    NSURLRequestReloadIgnoringLocalCacheData = 1,</span><br><span class="line"></span><br><span class="line">    //不仅忽略本地缓存，还要忽略协议缓存和其他缓存 (未实现)</span><br><span class="line">    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4,</span><br><span class="line"></span><br><span class="line">    //被NSURLRequestReloadIgnoringLocalCacheData替代</span><br><span class="line">    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,</span><br><span class="line"></span><br><span class="line">    //无视缓存的有效期,有缓存就取缓存，没有缓存就会从原始地址加载</span><br><span class="line">    NSURLRequestReturnCacheDataElseLoad = 2,</span><br><span class="line"></span><br><span class="line">    //无视缓存的有效期，有缓存就取缓存，没有缓存就视为失败 (可以用于离线模式)</span><br><span class="line">    NSURLRequestReturnCacheDataDontLoad = 3,</span><br><span class="line"></span><br><span class="line">    //会从初始地址校验缓存的合法性，合法就用缓存数据，不合法从原始地址加载数据 (未实现)</span><br><span class="line">    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="AFNetworking的缓存策略"><a href="#AFNetworking的缓存策略" class="headerlink" title="AFNetworking的缓存策略"></a>AFNetworking的缓存策略</h2><p>&ensp;&ensp;&ensp;&ensp;之前写了<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/04/11/SDWebImage-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">SDWebImage的源码解析</a> 里面介绍过<code>SDWebImage</code>的缓存策略，有两条线根据时间和空间来管理缓存和<code>AFNetworking</code>很相似。<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>中<code>AFImageDownloader</code>使用<code>AFAutoPurgingImageCache</code>和<code>NSURLCache</code>管理图片缓存。</p><h3 id="AFNetworking中的NSURLCache"><a href="#AFNetworking中的NSURLCache" class="headerlink" title="AFNetworking中的NSURLCache"></a>AFNetworking中的NSURLCache</h3><p>&ensp;&ensp;&ensp;&ensp;<code>AFImageDownloader</code>中设置<code>NSURLCache</code>，低版本<code>iOS</code>版本中设置内存容量和磁盘容量会闪退（这个我没有考证，<code>iOS 7</code>的手机还真没有）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([[[UIDevice currentDevice] systemVersion] compare:@&quot;8.2&quot; options:NSNumericSearch] == NSOrderedAscending) </span><br><span class="line">&#123;</span><br><span class="line">    return [NSURLCache sharedURLCache];</span><br><span class="line">&#125;</span><br><span class="line">return [[NSURLCache alloc] initWithMemoryCapacity:20 * 1024 * 1024 diskCapacity:150 * 1024 * 1024 diskPath:@&quot;com.alamofire.imagedownloader&quot;];</span><br></pre></td></tr></table></figure><h3 id="AFNetworking中的AFAutoPurgingImageCache"><a href="#AFNetworking中的AFAutoPurgingImageCache" class="headerlink" title="AFNetworking中的AFAutoPurgingImageCache"></a>AFNetworking中的AFAutoPurgingImageCache</h3><p>&ensp;&ensp;&ensp;&ensp;<code>AFAutoPurgingImageCache</code>是专门用来图片缓存的。可以看到内部有三个属性，一个是用来装载<code>AFImageCache</code>对象的字典容器，一个是可以用内存空间大小、一个同步队列。<code>AFAutoPurgingImageCache</code>在初始化的时候，会注册<code>UIApplicationDidReceiveMemoryWarningNotification</code>通知，收到内存警告的时候会清除所有缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AFAutoPurgingImageCache ()</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary &lt;NSString* , AFCachedImage*&gt; *cachedImages;</span><br><span class="line">@property (nonatomic, assign) UInt64 currentMemoryUsage;</span><br><span class="line">@property (nonatomic, strong) dispatch_queue_t synchronizationQueue;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>AFCachedImage</code>是单个图片缓存对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UIImage *image;</span><br><span class="line"></span><br><span class="line">//标志符(这个值就是图片的请路径 request.URL.absoluteString)</span><br><span class="line">@property (nonatomic, strong) NSString *identifier;</span><br><span class="line"></span><br><span class="line">//图片大小</span><br><span class="line">@property (nonatomic, assign) UInt64 totalBytes;</span><br><span class="line"></span><br><span class="line">//缓存日期</span><br><span class="line">@property (nonatomic, strong) NSDate *lastAccessDate;</span><br><span class="line"></span><br><span class="line">//当前可用内存空间大小</span><br><span class="line">@property (nonatomic, assign) UInt64 currentMemoryUsage;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;来看看<code>AFCachedImage</code>初始化的时候。<code>iOS</code>使用图标标准是<code>ARGB_8888</code>，即一像素占位4个字节。内存大小 = 宽×高×每像素字节数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)initWithImage:(UIImage *)image identifier:(NSString *)identifier </span><br><span class="line">&#123;</span><br><span class="line">    if (self = [self init]) </span><br><span class="line">    &#123;</span><br><span class="line">        self.image = image;</span><br><span class="line">        self.identifier = identifier;</span><br><span class="line"></span><br><span class="line">        CGSize imageSize = CGSizeMake(image.size.width * image.scale, image.size.height * image.scale);</span><br><span class="line">        CGFloat bytesPerPixel = 4.0;</span><br><span class="line">        CGFloat bytesPerSize = imageSize.width * imageSize.height;</span><br><span class="line">        self.totalBytes = (UInt64)bytesPerPixel * (UInt64)bytesPerSize;</span><br><span class="line">        self.lastAccessDate = [NSDate date];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;来看看添加缓存的代码，用了<code>dispatch_barrier_async</code>栅栏函数将添加操作和删除缓存操作分割开来。每添加一个缓存对象，都重新计算当前缓存大小和可用空间大小。当内存超过设定值时，会按照日期的倒序来遍历缓存图片，删除最早日期的缓存，一直到满足缓存空间为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier </span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</span><br><span class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</span><br><span class="line"></span><br><span class="line">        AFCachedImage *previousCachedImage = self.cachedImages[identifier];</span><br><span class="line">        if (previousCachedImage != nil) </span><br><span class="line">        &#123;</span><br><span class="line">            self.currentMemoryUsage -= previousCachedImage.totalBytes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.cachedImages[identifier] = cacheImage;</span><br><span class="line">        self.currentMemoryUsage += cacheImage.totalBytes;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</span><br><span class="line">        if (self.currentMemoryUsage &gt; self.memoryCapacity) </span><br><span class="line">        &#123;</span><br><span class="line">            UInt64 bytesToPurge = self.currentMemoryUsage - self.preferredMemoryUsageAfterPurge;</span><br><span class="line">            NSMutableArray &lt;AFCachedImage*&gt; *sortedImages = [NSMutableArray arrayWithArray:self.cachedImages.allValues];</span><br><span class="line">            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;lastAccessDate&quot; ascending:YES];</span><br><span class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</span><br><span class="line"></span><br><span class="line">            UInt64 bytesPurged = 0;</span><br><span class="line"></span><br><span class="line">            for (AFCachedImage *cachedImage in sortedImages) </span><br><span class="line">            &#123;</span><br><span class="line">                [self.cachedImages removeObjectForKey:cachedImage.identifier];</span><br><span class="line">                bytesPurged += cachedImage.totalBytes;</span><br><span class="line">                if (bytesPurged &gt;= bytesToPurge) </span><br><span class="line">                &#123;</span><br><span class="line">                    break ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            self.currentMemoryUsage -= bytesPurged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="YTKNetwork的缓存策略"><a href="#YTKNetwork的缓存策略" class="headerlink" title="YTKNetwork的缓存策略"></a>YTKNetwork的缓存策略</h2><p>&ensp;&ensp;&ensp;&ensp;<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a>是猿题库技术团队开源的一个网络请求框架，内部封装了<code>AFNetworking</code>。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。笔者在一个电商的<code>PaaS</code>项目中就是使用<code>YTKNetwork</code>，它的特点还有支持请求结果缓存，支持批量请求，支持多请求依赖等。</p><h3 id="准备请求之前"><a href="#准备请求之前" class="headerlink" title="准备请求之前"></a>准备请求之前</h3><p>&ensp;&ensp;&ensp;&ensp;先来看看请求基类<code>YTKRequest</code>在请求之前做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)start </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //忽略缓存的标志 手动设置 是否利用缓存</span><br><span class="line">    if (self.ignoreCache) </span><br><span class="line">    &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 还有未完成的请求 是否还有未完成的请求</span><br><span class="line">    if (self.resumableDownloadPath) </span><br><span class="line">    &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载缓存是否成功</span><br><span class="line">    if (![self loadCacheWithError:nil]) </span><br><span class="line">    &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dataFromCache = YES;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">        //将请求数据写入文件</span><br><span class="line">        [self requestCompletePreprocessor];</span><br><span class="line">        [self requestCompleteFilter];</span><br><span class="line"></span><br><span class="line">        //这个时候直接去相应 请求成功的delegate和block ，没有发送请求</span><br><span class="line">        YTKRequest *strongSelf = self;</span><br><span class="line">        [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        if (strongSelf.successCompletionBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将block置空</span><br><span class="line">        [strongSelf clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="缓存数据写入文件"><a href="#缓存数据写入文件" class="headerlink" title="缓存数据写入文件"></a>缓存数据写入文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestCompletePreprocessor </span><br><span class="line">&#123;</span><br><span class="line">    [super requestCompletePreprocessor];</span><br><span class="line"></span><br><span class="line">    if (self.writeCacheAsynchronously) </span><br><span class="line">    &#123;</span><br><span class="line">        dispatch_async(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;<code>ytkrequest_cache_writing_queue</code>是一个优先级比较低的串行队列，当标志<code>dataFromCache</code>为<code>YES</code>的时候，确定能拿到数据，在这个串行队列中异步的写入文件。来看看写入缓存的具体操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveResponseDataToCacheFile:(NSData *)data </span><br><span class="line">&#123;</span><br><span class="line">    if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) </span><br><span class="line">    &#123;</span><br><span class="line">        if (data != nil) </span><br><span class="line">        &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                // New data will always overwrite old data.</span><br><span class="line">                [data writeToFile:[self cacheFilePath] atomically:YES];</span><br><span class="line"></span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [self cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self];</span><br><span class="line">                metadata.creationDate = [NSDate date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]];</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;除了请求数据文件，<code>YTK</code>还会生成一个记录缓存数据信息的元数据<code>YTKCacheMetadata</code>对象。<code>YTKCacheMetadata</code>记录了缓存的版本号、敏感信息、缓存日期和App的版本号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) long long version;</span><br><span class="line">@property (nonatomic, strong) NSString *sensitiveDataString;</span><br><span class="line">@property (nonatomic, assign) NSStringEncoding stringEncoding;</span><br><span class="line">@property (nonatomic, strong) NSDate *creationDate;</span><br><span class="line">@property (nonatomic, strong) NSString *appVersionString;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后把请求方法、请求域名、请求URL和请求参数组成的字符串进行一次<code>MD5</code>加密，作为缓存文件的名称。<code>YTKCacheMetadata</code>和缓存文件同名，多了一个<code>.metadata</code>的后缀作为区分。文件写入的路径是沙盒中<code>Library/LazyRequestCache</code>目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)cacheFileName </span><br><span class="line">&#123;</span><br><span class="line">    NSString *requestUrl = [self requestUrl];</span><br><span class="line">    NSString *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    id argument = [self cacheFileNameFilterForRequestArgument:[self requestArgument]];</span><br><span class="line">    NSString *requestInfo = [NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;,</span><br><span class="line">    (long)[self requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    NSString *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    return cacheFileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-b3a080f6739c49cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork缓存文件路径.png"></p><h3 id="校验缓存"><a href="#校验缓存" class="headerlink" title="校验缓存"></a>校验缓存</h3><p>&ensp;&ensp;&ensp;&ensp;回到start方法中，<code>loadCacheWithError</code>是校验缓存能不能成功加载出来，<code>loadCacheWithError</code>中会调用<code>validateCacheWithError</code>来检验缓存的合法性，校验的依据正是<code>YTKCacheMetadata</code>和<code>cacheTimeInSeconds</code>。要想使用缓存数据，请求实例要重写<code>cacheTimeInSeconds</code>设置一个大于0的值，而且缓存还支持版本、App的版本。在实际项目上应用，<code>get</code>请求实例设置一个<code>cacheTimeInSeconds</code>就够用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateCacheWithError:(NSError * _Nullable __autoreleasing *)error     </span><br><span class="line">&#123;</span><br><span class="line">    // Date</span><br><span class="line">    NSDate *creationDate = self.cacheMetadata.creationDate;</span><br><span class="line">    NSTimeInterval duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    if (duration &lt; 0 || duration &gt; [self cacheTimeInSeconds]) </span><br><span class="line">    &#123;</span><br><span class="line">        if (error) </span><br><span class="line">        &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache expired&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // Version</span><br><span class="line">    long long cacheVersionFileContent = self.cacheMetadata.version;</span><br><span class="line">    if (cacheVersionFileContent != [self cacheVersion]) </span><br><span class="line">    &#123;</span><br><span class="line">        if (error) </span><br><span class="line">        &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache version mismatch&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // Sensitive data</span><br><span class="line">    NSString *sensitiveDataString = self.cacheMetadata.sensitiveDataString;</span><br><span class="line">    NSString *currentSensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">    if (sensitiveDataString || currentSensitiveDataString) </span><br><span class="line">    &#123;</span><br><span class="line">        // If one of the strings is nil, short-circuit evaluation will trigger</span><br><span class="line">        if (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) </span><br><span class="line">        &#123;</span><br><span class="line">            if (error) </span><br><span class="line">            &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache sensitive data mismatch&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // App version</span><br><span class="line">    NSString *appVersionString = self.cacheMetadata.appVersionString;</span><br><span class="line">    NSString *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    if (appVersionString || currentAppVersionString) </span><br><span class="line">    &#123;</span><br><span class="line">        if (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) </span><br><span class="line">        &#123;</span><br><span class="line">            if (error) </span><br><span class="line">            &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;App version mismatch&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><p>&ensp;&ensp;&ensp;&ensp;因为缓存的目录是<code>Library/LazyRequestCache</code>，清除缓存就直接清空目录下所有文件就可以了。调用<code>[[YTKNetworkConfig sharedConfig] clearCacheDirPathFilter]</code>就行。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>缓存的本质是用空间换取时间。大学里面学过的《计算机组成原理》中就有介绍<code>cache</code>，除了磁盘和内存,还有L1和L2，对于iOS开发者来说，一般关注<code>disk</code>和<code>memory</code>就够了。阅读<code>SDWebImage、AFNetworking、YTKNetwork</code>的源码后，可以看出他们都非常重视数据的多线程的读写安全，在做深度优化时候，因地制宜，及时清理缓存文件。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren’t aware that NSURLCache could be setup in two lines and do it 100× better. Even more developers have never known the benefits of network caching, and never attempted a solution, causing their apps to make untold numbers of unnecessary requests to the server.&lt;br&gt;无数开发者尝试自己做一个丑陋而脆弱的系统来实现网络缓存的功能，殊不知NSURLCache只要两行代码就能搞定，并且好上100倍。甚至更多的开发者根本不知道网络缓存的好处，从来没有尝试过解决方案，导致他们的App向服务器发出无数不必要的请求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>组件化遇到的问题</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/11/28/%E7%BB%84%E4%BB%B6%E5%8C%96%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/11/28/组件化遇到的问题/</id>
    <published>2018-11-28T12:19:33.000Z</published>
    <updated>2018-11-28T08:27:53.181Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;来公司大半年时间了，一个人搞组件化不轻松，先来看看<code>podfile</code>，业务功能都已经拆分成了一个组件，现在主工程就是一个空壳子，所有的业务场景都在组件化包里面。现在总结一下，在组件化过程中遇到的问题。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://git.XXX.com/products/paas-app-ios-spec.git&apos;</span><br><span class="line">source &apos;https://github.com/CocoaPods/Specs.git&apos;</span><br><span class="line"># platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;YYPaas&apos; do</span><br><span class="line">pod &apos;PaasBaseComponent&apos;, &apos;~&gt; 1.0.30&apos;</span><br><span class="line"></span><br><span class="line">#pod &apos;PaasUMComponent&apos;, &apos;~&gt; 1.0.1&apos;</span><br><span class="line">pod &apos;PaasAddressComponent&apos;, &apos;~&gt; 1.0.7&apos;</span><br><span class="line">pod &apos;PaasThemeBuildStyleComponent&apos;, &apos;~&gt; 1.0.1&apos;</span><br><span class="line">pod &apos;PaasUMBuildStyleComponent&apos;, &apos;~&gt; 1.0.15&apos;</span><br><span class="line">pod &apos;PaasCollectionComponent&apos;, &apos;~&gt; 1.0.1&apos;</span><br><span class="line">pod &apos;PaasFootprintComponent&apos;, &apos;~&gt; 1.0.2&apos;</span><br><span class="line">pod &apos;PaasIntegralComponent&apos;, &apos;~&gt; 1.0.4&apos;</span><br><span class="line">pod &apos;PaasUserInfoComponent&apos;, &apos;~&gt; 1.0.1&apos;</span><br><span class="line">pod &apos;PaasSettingComponent&apos;, &apos;~&gt; 1.0.3&apos;</span><br><span class="line">pod &apos;PaasOrderComponent&apos;, &apos;~&gt; 1.0.5&apos;</span><br><span class="line">pod &apos;PaasAfterSaleComponent&apos;, &apos;~&gt; 1.0.1&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#use_frameworks!</span><br><span class="line"></span><br><span class="line"># Pods for YYPaas</span><br></pre></td></tr></table></figure><h2 id="创建私有库没有通过远端校验问题"><a href="#创建私有库没有通过远端校验问题" class="headerlink" title="创建私有库没有通过远端校验问题"></a>创建私有库没有通过远端校验问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=&apos;https://git.xxxx.com/products/paas-app-ios-spec.git,https://github.com/CocoaPods/Specs&apos; --use-libraries --allow-warnings --verbose</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;一般创建私有库的时候，本地校验都能通过，但是远端校验通不过，报错下图的错误<br><img src="https://upload-images.jianshu.io/upload_images/1487718-bf702de090b61f32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pod spec lint 报错.png"></p><p>&ensp;&ensp;&ensp;&ensp;上网查原因是上传的包过大，<code>http</code>的头部错误导致。后来修改<code>postBuffer</code>改为50M，100M都，但是还是不起作用。后来通过修改私有库的<code>.podspec</code>文件来解决这个问题。</p><p>&ensp;&ensp;&ensp;&ensp;<strong>本地校验指定<code>source</code>路径为<code>https</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.source           = &#123; :git =&gt; &apos;https://git.xxx.com/yuyi/PaasAddressComponent.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<strong>提交代码至远端后修改<code>source</code>为<code>ssh</code>方式</strong>，然后进行<code>pod spec lint</code>和<code>pod repo push</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.source           = &#123; :git =&gt; &apos;ssh://git@git.xxx.com:3589/yuyi/PaasAddressComponent.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<strong><code>pod repo push</code> 操作后要记住把<code>s.source</code>的引入方式改为<code>https</code>，不然通过不了本地校验。</strong><br>&ensp;&ensp;&ensp;&ensp;私有库都托管到公司的<code>gitlab</code>上面，现在还没有解决这个问题，我想应该是公司<code>gitLab</code>设置的问题，毕竟在同样的私有库托管在<code>https://gitee.com/</code>或者自己的<code>gitlab</code>账号都没有出现过同样的问题。</p><h2 id="资源文件的引用问题"><a href="#资源文件的引用问题" class="headerlink" title="资源文件的引用问题"></a>资源文件的引用问题</h2><p>&ensp;&ensp;&ensp;&ensp;搭建页面的时候都是用<code>Masonry</code>代码布局，没有用<code>xib</code>文件。这里的资源文件自剩下图片资源了。<br>&ensp;&ensp;&ensp;&ensp;假如不在组件中，图片资源交给<code>Assets.xcassets</code>来管理，引用直接通过<code>[UIImage imageNamed:@&quot;paas_nodata_placeholder&quot;]</code>。<br>&ensp;&ensp;&ensp;&ensp;现在没有单独的组件包的图片资源就不会放在<code>Assets.xcassets</code>，而是通过放在组件<code>Assets</code>目录下来管理，引用方式也变成了<code>[UIImage imageWithContentsOfFile:path]</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)imageWithPaasComponentType:(PaasComponentType)type </span><br><span class="line">                          WithClassName:(Class)className</span><br><span class="line">                               WithName:(NSString *)imageName</span><br><span class="line">&#123;</span><br><span class="line">    NSBundle * bundle = [NSBundle bundleForClass:className];</span><br><span class="line">    NSString * componentName;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case PaasComponentType_Base:</span><br><span class="line">            componentName = @&quot;PaasBaseComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_UM:</span><br><span class="line">            componentName = @&quot;PaasUMComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Address:</span><br><span class="line">            componentName = @&quot;PaasAddressComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_BuildUM:</span><br><span class="line">            componentName = @&quot;PaasUMBuildStyleComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Collection:</span><br><span class="line">            componentName = @&quot;PaasCollectionComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Footprint:</span><br><span class="line">            componentName = @&quot;PaasFootprintComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Integral:</span><br><span class="line">            componentName = @&quot;PaasIntegralComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_UserInfo:</span><br><span class="line">            componentName = @&quot;PaasUserInfoComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Setting:</span><br><span class="line">            componentName = @&quot;PaasSettingComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Order:</span><br><span class="line">            componentName = @&quot;PaasOrderComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_AfterSale:</span><br><span class="line">            componentName = @&quot;PaasAfterSaleComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case PaasComponentType_Evaluation:</span><br><span class="line">            componentName = @&quot;PaasEvaluationComponent&quot;;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString * resource = [NSString stringWithFormat:@&quot;%@.bundle/%@.png&quot;,componentName,[self addSuffixWithImageName:imageName]];</span><br><span class="line">    NSString * path = [bundle pathForResource:resource ofType:nil];</span><br><span class="line">    return [UIImage imageWithContentsOfFile:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSString *)addSuffixWithImageName:(NSString *)imageName</span><br><span class="line">&#123;</span><br><span class="line">    NSString * fileName;</span><br><span class="line">    if ([UIScreen mainScreen].scale == 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@@3x&quot;,imageName];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        fileName = [NSString stringWithFormat:@&quot;%@@2x&quot;,imageName];</span><br><span class="line">    &#125;</span><br><span class="line">    return fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;首先根据<code>className</code>来确定所在的<code>Bundle</code>，然后根据<code>PaasComponentType</code>来确定所在的组件名称，最后用<code>[UIScreen mainScreen].scale</code>来确定是用<code>@2x</code>图片还是<code>@3x</code>图片。</p><p>&ensp;&ensp;&ensp;&ensp;<code>podspec</code>加入图片文件<br><img src="https://upload-images.jianshu.io/upload_images/1487718-ea2dd7c4fe907f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件化图片引入方式.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.resource_bundles = &#123;</span><br><span class="line">&apos;PaasAddressComponent&apos; =&gt; [&apos;PaasAddressComponent/Assets/*.png&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件之间的通讯问题"><a href="#组件之间的通讯问题" class="headerlink" title="组件之间的通讯问题"></a>组件之间的通讯问题</h2><p>&ensp;&ensp;&ensp;&ensp;我在拆分订单组件和售后组件之前，订单详情是这样跳转到申请售后的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RefundViewController * vc = [[RefundViewController alloc]init];</span><br><span class="line">vc.FmodelArray = self.modelArray</span><br><span class="line">[self.navigationController pushViewController:vc animated:YES];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>OrderShopGoodsModel</code>是商品的<code>model</code> ，<code>self.modelArray</code>是商品详情存放<code>OrderShopGoodsModel</code>的集合，<code>RefundViewController</code>对外暴露了一个<code>FmodelArray</code>数组，里面存放的是<code>OrderShopGoodsModel</code>集合。<br>&ensp;&ensp;&ensp;&ensp;后来为了解耦，创建了<code>RefundShopGoodsModel</code>，<code>OrderShopGoodsModel</code>和<code>RefundShopGoodsModel</code>是没有任何区别的，都是用来存放商品的信息，例如 <code>id、name、sku、imageUrl、price</code>等。<code>converRefundGoodsModelWithArray</code>用来把<code>OrderShopGoodsModel</code>转化成<code>RefundShopGoodsModel</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vc.FmodelArray = [self converRefundGoodsModelWithArray:self.modelArray];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;这样没有根本解决解耦问题，把转换<code>Model</code>的代码放在订单详情，订单详情还需要依赖<code>RefundShopGoodsModel</code>，同样把转换的代码放在申请售后，售后模块还要依赖<code>OrderShopGoodsModel</code>。<br>&ensp;&ensp;&ensp;&ensp;<strong>为了解决模块之间通讯的参数问题，是不能用<code>Model</code>来传递的，否则无法解决依赖问题</strong>。最后的做法是<code>RefundViewController</code>暴露出一个字典<code>Fparams</code>用来接收参数。<code>Fparams</code>是未经转化原始商品数据。然在<code>RefundViewController</code>内写方法将字典转为相应的模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vc.Fparams = self.refundParams;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;配合中间件CTMediator路由跳转如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIViewController * vc = [[CTMediator sharedInstance] CTMediator_RefundViewControllerWithValue:self.refundParams];</span><br><span class="line">[self.navigationController pushViewController:vc animated:YES];</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;来公司大半年时间了，一个人搞组件化不轻松，先来看看&lt;code&gt;podfile&lt;/code&gt;，业务功能都已经拆分成了一个组件，现在主工程就是一个空壳子，所有的业务场景都在组件化包里面。现在总结一下，在组件化过程中遇到的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtime消息转发及其应用</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/10/30/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/10/30/Runtime消息转发及其应用/</id>
    <published>2018-10-30T11:39:40.000Z</published>
    <updated>2018-10-30T07:58:06.354Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;之前写过文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/01/08/Runtime%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">Runtime的常见用法</a>里面有介绍过利用<code>Objective-C</code>的<code>Runtime</code>特性来给<code>Category</code>生成属性、实现方法交换和给<code>Model</code>赋值。今天整理一下<code>Objective-C</code>消息传递和消息转发机制以及来防止应用闪退的问题。</p><a id="more"></a><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>&ensp;&ensp;打开#import&lt;objc/runtime.h&gt;文件，看到<code>struct objc_class</code>的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;<strong>结构体中有很多变量，分别是父类的指针、类的名字、类的版本、实例大小、变量列表、方法列表、方法缓存、协议列表。一个类对象就是一个结构体<code>struct objc_class</code>  ，这个结构体存放的数据称为<code>metadata(元数据)</code>，结构体的第一个成员变量是一个isa指针，isa指针指向<code>metaclass（元类）</code>。</strong></p><p>&ensp;&ensp;在看看<code>Method</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method(objc_method)</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;这个就是平常使用的函数，能够独立完成一个功能的一段代码</p><ul><li><code>SEL method_name</code> 方法名</li><li><code>char* method_types</code>方法类型</li><li><code>IMP method_imp</code> 方法实现的指针</li><li><code>SEL</code>和<code>IMP</code>都是Method的属性</li></ul><p>&ensp;&ensp;一般OC中函数调用例如 <code>[obj dosomthing]</code>都会被编译器转义成<code>objc_msgsend(obj,dosomething)</code>,<code>obj</code>就是对象实例，<code>dosomething</code>是<code>SEL</code>类型。<code>Runtime</code>的执行的流程是</p><ul><li>1.通过<code>obj</code>的<code>isa</code>指针找到他的<code>class</code>，然后在<code>class</code>中的<code>objc_cache</code>中查找方法</li><li>2.假如没有找到，就去<code>objc_method_list</code>中查找对应的方法</li><li>3.如果在<code>class</code>中种没有找到相关的方法，则会继续向上查找，在<code>父类（super_class）</code>重复步骤1、2。</li><li>4.假如一直没有找到这个方法，通常会<code>crash</code>并抛出异常，在抛出异常前会执行消息转发。</li></ul><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>&ensp;&ensp;发生消息转发，还有三次机会，假如都失败了就会执行<code>doesNotRecognizeSelector：</code>报错<code>unrecognized selector</code>。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-574c486162950666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS 消息转发流程图.png"></p><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(testMethod:) withObject:@&quot;something&quot;];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;我在<code>ViewController</code>里面调用<code>testMethod</code>方法，但是没有在<code>ViewController</code>申明这个方法，运行起来肯定是崩溃的。<br>在运行时，如果找不到要执行的方法，会首先执行<code>resolveClassMethod:</code>或者<code>resolveInstanceMethod：</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 添加的IMP</span><br><span class="line">void myMethod(id self, SEL cmd, id value)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 找不到对象方法时候调用</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(testMethod:))</span><br><span class="line">    &#123;</span><br><span class="line">        class_addMethod([self class],sel,(IMP)myMethod,&quot;v@:@&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return [super resolveInstanceMethod:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 找不到类方法时调用</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;当<code>ViewController</code>对象找不到<code>testMethod</code>方法，首先调用<code>resolveInstanceMethod</code>进行拦截补救。判断<code>ViewController</code>找不到的方法是否为<code>testMethod</code><br>如果是<code>testMethod</code>，调用<code>class_addMethod</code>为<code>ViewController</code>动态的添加<code>testMethod</code>方法。<br><code>class_addMethod</code>的四个参数分别是</p><ul><li>动态添加方法的类</li><li>动态添加的方法</li><li>方法实现</li><li>参数类型<br>&ensp;&ensp;这里假如说想在<code>resolveClassMethod</code>动态的添加类方法，<code>class_addMethod</code>的第一参数替换成<code>[self superClass]</code>即可。</li></ul><h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>&ensp;&ensp;假如没有在<code>resolveInstanceMethod</code>里面动态添加方法，还是会崩溃，这个时候需要另外一个对象来接收这个消息。新建一个<code>BackupViewController</code>类，然后让<code>BackupViewController</code>去执行<code>testMethod</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation BackupViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testMethod:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 找不到对象方法时候调用</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 找不到类方法时调用</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 寻找备用接收者</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    BackupViewController * backup = [[BackupViewController alloc] init];</span><br><span class="line">    if ([backup respondsToSelector:@selector(testMethod:)])</span><br><span class="line">    &#123;</span><br><span class="line">        return backup;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这个很好理解，既然自己不能动态添加方法，那就让其他的对象来接收这个消息，但是需要注意的是，这个备用者不能是<code>self</code>本身，否则会陷入循环中。</p><h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>&ensp;&ensp;假如不动态添加方法，也不转发给备用接收者，这个时候就需要完整消息转发<code>NSInvocation</code>来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - ViewController找不到方法的实现签名，需要给aSelector新建方法签名，在交给Backup处理</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature * signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature)</span><br><span class="line">    &#123;</span><br><span class="line">        signature = [BackupViewController instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 方法签名后进入forwardInvocation方法</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    BackupViewController * backup = [[BackupViewController alloc] init];</span><br><span class="line">    if ([backup respondsToSelector:sel])</span><br><span class="line">    &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:backup];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;首先创建<code>NSInvocation</code>对象，把尚未处理的那条消息有关的全部细节封装于这个<code>NSInvocation</code>对象中。此对象中包含选择子（<code>selector</code>）、目标（<code>target</code>）及参数。在触发<code>NSInvocation</code>对象时，会调用<code>forwardInvocation</code>来转发消息，如果发现调用操作不由本类来处理，则需要沿着继承体系，调用父类的同名方法，一直到<code>NSObject</code>类，调用<code>doesNotRecognizeSelector</code>来抛出异常，消息转发结束。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&ensp;&ensp;在这里消息转发三个步骤中，第一步<code>resolveInstanceMethod</code>可以解决问题，但是需要在当前对象添加不存在的方法。第三步，会导致消息流转的周期变长，还会产生<code>NSInvocation</code>，增加额外的开销。所以在应用中，在第二步处理消息防止应用闪退。<br>&ensp;&ensp;<strong>可以动态的创建一个类，动态的给该类添加对应的<code>Selector</code>,通过一个通用的返回0的函数来实现改<code>SEL</code>的<code>IMP</code>。然后将消息转发到这个类上。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ForwardingTarget.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation ForwardingTarget</span><br><span class="line"></span><br><span class="line">id ForwardingTarget_dynamicMethod(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    return [NSNull null];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    class_addMethod([self class], sel, (IMP)ForwardingTarget_dynamicMethod, &quot;@@:&quot;);</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    id result = [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    id result = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    [super doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;NSObject+DoesNotRecognizeSelectorExtension.h&quot;</span><br><span class="line"></span><br><span class="line">#import &quot;ForwardingTarget.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static ForwardingTarget * _target = nil;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (DoesNotRecognizeSelectorExtension)</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _target = [ForwardingTarget new];;</span><br><span class="line">        not_recognize_selector_classMethodSwizzle([self class], @selector(forwardingTargetForSelector:), @selector(doesnot_recognize_selector_swizzleForwardingTargetForSelector:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)doesnot_recognize_selector_swizzleForwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    id result = [self doesnot_recognize_selector_swizzleForwardingTargetForSelector:aSelector];</span><br><span class="line">    if (result)</span><br><span class="line">    &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - private method</span><br><span class="line"></span><br><span class="line">BOOL not_recognize_selector_classMethodSwizzle(Class aClass, SEL originalSelector, SEL swizzleSelector)</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class="line">    Method swizzleMethod = class_getInstanceMethod(aClass, swizzleSelector);</span><br><span class="line">    BOOL didAddMethod = class_addMethod(aClass,originalSelector,method_getImplementation(swizzleMethod),method_getTypeEncoding(swizzleMethod));</span><br><span class="line">    if (didAddMethod)</span><br><span class="line">    &#123;</span><br><span class="line">        class_replaceMethod(aClass,swizzleSelector,method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>参考<br><a href="https://yq.aliyun.com/articles/348673" target="_blank" rel="noopener">iOS unrecognized selector crash 自修复技术实现与原理解析</a><br><a href="https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/" target="_blank" rel="noopener">大白健康系统–iOS APP运行时Crash自动修复系统</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;之前写过文章&lt;a href=&quot;https://ios-misaki.github.io/iOS-Misaki.github.io/2018/01/08/Runtime%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Runtime的常见用法&lt;/a&gt;里面有介绍过利用&lt;code&gt;Objective-C&lt;/code&gt;的&lt;code&gt;Runtime&lt;/code&gt;特性来给&lt;code&gt;Category&lt;/code&gt;生成属性、实现方法交换和给&lt;code&gt;Model&lt;/code&gt;赋值。今天整理一下&lt;code&gt;Objective-C&lt;/code&gt;消息传递和消息转发机制以及来防止应用闪退的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TransitionAnimation 自定义转场动画</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/08/04/TransitionAnimation-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/08/04/TransitionAnimation-自定义转场动画/</id>
    <published>2018-08-04T12:40:27.000Z</published>
    <updated>2018-08-04T14:53:14.814Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在<code>iOS 7</code>之后，苹果就开放了自定义转场的相关<code>api</code>，现在都快<code>iOS 12</code>了，一直都没有好好研究转场动画，一个是之前没有重视，觉得花里胡哨的，另外一个是所做的项目中没有这样的转场动画需求。这里说的转场动画和上一篇<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/" target="_blank" rel="noopener">CAAnimation 系统动画</a>中<code>CATransition</code>动画不是一个概念，上一篇指的是单个View的转场特效，这里指的是整个控制器的转场特效。其实写上篇文章的目前也是为今天打下铺垫，复杂的转场效果也是由单个动画来组成的。</p><a id="more"></a><p><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E7%B1%BB%E5%9B%BE.png" alt="自定义转场动画类图"></p><p>&ensp;&ensp;&ensp;&ensp;由图中可以看出要完成自定义转场动画，必须遵从<code>UIViewControllerAnimatedTransitioning</code>协议，协议中有两个必须实现的方法一个是返回转场时间，一个是具体转场的实现。文章会结合5个最常用的动画场景来说明转场动画。</p><p>&ensp;&ensp;&ensp;&ensp;先来看看网易严选App的转场效果，可以看出当前页面想要<code>Push</code>其他的页面的时候，当前页面会下沉同时其他页面从右边平移至左边。<code>Present</code>页面的时候，当前页面也会下沉，目标视图从底部弹出。<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89Push%E5%92%8CPop%E5%8A%A8%E7%94%BB.gif" alt="网易严选Push和Pop动画.gif"></p><p><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89Present%E5%92%8CDismiss%E5%8A%A8%E7%94%BB.gif" alt="网易严选Present和Dismiss动画.gif"></p><p>&ensp;&ensp;&ensp;&ensp;来看代码，在<code>ViewController</code>里面有两个按钮，分别是<code>Push</code>出<code>SecondVC</code>和<code>Present</code>出<code>ThirdVC</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)pushBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    SecondViewController * vc = [[SecondViewController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)presentBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    ThirdViewController * vc = [[ThirdViewController alloc] init];</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Push和Pop动画"><a href="#Push和Pop动画" class="headerlink" title="Push和Pop动画"></a>Push和Pop动画</h2><h3 id="UIViewControllerAnimatedTransitioning协议"><a href="#UIViewControllerAnimatedTransitioning协议" class="headerlink" title="UIViewControllerAnimatedTransitioning协议"></a>UIViewControllerAnimatedTransitioning协议</h3><p>&ensp;&ensp;&ensp;&ensp;这里新建一个<code>AnimatedTransitioningObject</code>类，然后要遵循<code>UIViewControllerAnimatedTransitioning</code>协议。这个为了方便，把<code>Push、Pop、Present、Dismiss</code>这四个效果写在一起，用枚举来区分，当然也可以把每种动画效果单独用一个<code>AnimatedTransitioningObject</code>类来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger,TransitionAnimationObjectType) &#123;</span><br><span class="line">    TransitionAnimationObjectType_Push,</span><br><span class="line">    TransitionAnimationObjectType_Pop,</span><br><span class="line">    TransitionAnimationObjectType_present,</span><br><span class="line">    TransitionAnimationObjectType_Dismiss</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface TransitionAnimationObject : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) TransitionAnimationObjectType type;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTransitionAnimationObjectType:(TransitionAnimationObjectType)type;</span><br><span class="line"></span><br><span class="line">+ (instancetype)initWithTransitionAnimationObjectType:(TransitionAnimationObjectType)type;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;来看看两个必须实现的方法，在返回转场时间里也可以根据<code>type</code>来返回不同的动画时间，这里统一返回0.5秒。<code>pushAnimateTransition</code>里面实现<code>Push</code>效果转场。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    return 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    switch (_type) &#123;</span><br><span class="line">        case TransitionAnimationObjectType_Push:</span><br><span class="line">            [self pushAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransitionAnimationObjectType_Pop:</span><br><span class="line">            [self popAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransitionAnimationObjectType_present:</span><br><span class="line">            [self presentAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransitionAnimationObjectType_Dismiss:</span><br><span class="line">            [self dismissAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Push实现"><a href="#Push实现" class="headerlink" title="Push实现"></a>Push实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (void)pushAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //获取目标View(secondVC.view) 和 来源View(ViewController.view)</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //这里截图做动画 隐藏来源View</span><br><span class="line">    UIView * tempView = [fromView snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    fromView.hidden = YES;</span><br><span class="line"></span><br><span class="line">    //将需要做转场的View按照顺序添加到转场容器中</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line"></span><br><span class="line">    CGFloat width = containerView.frame.size.width;</span><br><span class="line">    CGFloat height = containerView.frame.size.height;</span><br><span class="line"></span><br><span class="line">    //设置目标View的初始位置</span><br><span class="line">    toView.frame = CGRectMake(width, 0, width, height);</span><br><span class="line"></span><br><span class="line">    //开始做动画</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line">    [UIView animateWithDuration:duration animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformMakeScale(0.9, 0.9);</span><br><span class="line">        toView.transform = CGAffineTransformMakeTranslation(-width, 0);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //这里要标记转场成功 假如不标记 系统会认为还在转场中 无法交互</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line"></span><br><span class="line">        //转场失败 也要做相应的处理</span><br><span class="line">        if ([transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            fromView.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pop实现"><a href="#Pop实现" class="headerlink" title="Pop实现"></a>Pop实现</h3><p>&ensp;&ensp;&ensp;&ensp; <code>Push</code>和<code>Pop</code>是相对的关系，所以在<code>Pop</code>动画中，目标视图和来源视图互换身份，实现也是用<code>CGAffineTransformIdentity</code>来还原<code>Push</code>动画即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)popAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //注意这里是还原 所以toView和fromView 身份互换了 toView是ViewController.view</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //获取相应的视图</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    UIView * tempView = [[containerView subviews] firstObject];</span><br><span class="line"></span><br><span class="line">    //在fromView 下面插入toView 不然回来的时候回黑屏</span><br><span class="line">    [containerView insertSubview:toView belowSubview:fromView];</span><br><span class="line"></span><br><span class="line">    //将动画直接还原即可</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line">    [UIView animateWithDuration:duration animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformIdentity;</span><br><span class="line">        fromView.transform = CGAffineTransformIdentity;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //标记转场</span><br><span class="line">        [transitionContext completeTransition:!transitionContext.transitionWasCancelled];</span><br><span class="line"></span><br><span class="line">        //转场成功的处理</span><br><span class="line">        if (![transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">            toView.hidden = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="UINavigationControllerDelegate代理方法"><a href="#UINavigationControllerDelegate代理方法" class="headerlink" title="UINavigationControllerDelegate代理方法"></a>UINavigationControllerDelegate代理方法</h3><p>&ensp;&ensp;&ensp;&ensp;完成<code>AnimatedTransitioningObject</code>类后，再返回<code>ViewController</code>中，<code>ViewController</code>要遵循<code>UINavigationBarDelegate</code>和<code>UIViewControllerTransitioningDelegate</code>，把<code>SecondVC</code>的<code>transitioningDelegate</code>设置为自己。然后根据不同的<code>operation</code>，来返回不同的动画实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController () &lt;UINavigationControllerDelegate,UIViewControllerTransitioningDelegate&gt;</span><br><span class="line"></span><br><span class="line">- (IBAction)pushBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    SecondViewController * vc = [[SecondViewController alloc] init];</span><br><span class="line">    vc.transitioningDelegate = self;</span><br><span class="line">    [self.navigationController pushViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Push &amp;&amp; Pop</span><br><span class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span><br><span class="line">animationControllerForOperation:(UINavigationControllerOperation)operation</span><br><span class="line">fromViewController:(UIViewController *)fromVC</span><br><span class="line">toViewController:(UIViewController *)toVC</span><br><span class="line">&#123;</span><br><span class="line">    if (operation == UINavigationControllerOperationPush)</span><br><span class="line">    &#123;</span><br><span class="line">        return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_Push];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (operation == UINavigationControllerOperationPop)</span><br><span class="line">    &#123;</span><br><span class="line">        return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_Pop];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;看看实现效果<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/Push%E5%92%8CPop%E6%95%88%E6%9E%9C.gif" alt="Push和Pop效果.gif"></p><h2 id="Present动画和Dismiss动画"><a href="#Present动画和Dismiss动画" class="headerlink" title="Present动画和Dismiss动画"></a>Present动画和Dismiss动画</h2><h3 id="Present实现"><a href="#Present实现" class="headerlink" title="Present实现"></a>Present实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //获取目标View(ThirdVC.view) 和 来源View(ViewController.view)</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //截图做动画</span><br><span class="line">    UIView * tempView = [fromView snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    tempView.frame = fromView.frame;</span><br><span class="line">    fromView.hidden = YES;</span><br><span class="line"></span><br><span class="line">    //按照顺序假如转场动画容器中</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line"></span><br><span class="line">    CGFloat width = containerView.frame.size.width;</span><br><span class="line">    CGFloat height = containerView.frame.size.height;</span><br><span class="line"></span><br><span class="line">    //设置toView的初始化位置 在屏幕底部</span><br><span class="line">    toView.frame = CGRectMake(0, height, width, 400);</span><br><span class="line"></span><br><span class="line">    //做转场动画</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line">    [UIView animateWithDuration:duration delay:0 usingSpringWithDamping:0.55 initialSpringVelocity:1 options:0 animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformMakeScale(0.9, 0.9);</span><br><span class="line">        toView.transform = CGAffineTransformMakeTranslation(0, -400);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //转场结束后一定要标记 否则会认为还在转场 无法交互</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">        if ([transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            //转场失败</span><br><span class="line">            fromView.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dismiss实现"><a href="#Dismiss实现" class="headerlink" title="Dismiss实现"></a>Dismiss实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)dismissAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //dismiss的时候 fromVC和toVC身份倒过来了</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //containerView里面的顺序也倒过来了 截图在最上面</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    UIView * tempView = [[containerView subviews] firstObject];</span><br><span class="line"></span><br><span class="line">    //做还原动画就可以了</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line"></span><br><span class="line">    [UIView animateWithDuration:duration delay:0 usingSpringWithDamping:0.55 initialSpringVelocity:1 options:0 animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformIdentity;</span><br><span class="line">        fromView.transform = CGAffineTransformIdentity;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //转场结束后一定要标记 否则会认为还在转场 无法交互</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">        if (![transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            //转场成功</span><br><span class="line">            toView.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UIViewControllerTransitioningDelegate代理方法"><a href="#UIViewControllerTransitioningDelegate代理方法" class="headerlink" title="UIViewControllerTransitioningDelegate代理方法"></a>UIViewControllerTransitioningDelegate代理方法</h3><p>&ensp;&ensp;&ensp;&ensp;回到<code>ViewController</code>，把<code>ThirdVC</code>的<code>transitioningDelegate</code>设置为自己,然后在代理方法中自定类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)presentBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    ThirdViewController * vc = [[ThirdViewController alloc] init];</span><br><span class="line">    vc.transitioningDelegate = self;</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Present &amp;&amp; Dismiss</span><br><span class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</span><br><span class="line">&#123;</span><br><span class="line">    return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_present];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed</span><br><span class="line">&#123;</span><br><span class="line">    return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_Dismiss];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="手势动画"><a href="#手势动画" class="headerlink" title="手势动画"></a>手势动画</h2><h3 id="UIPercentDrivenInteractiveTransition创建手势类"><a href="#UIPercentDrivenInteractiveTransition创建手势类" class="headerlink" title="UIPercentDrivenInteractiveTransition创建手势类"></a>UIPercentDrivenInteractiveTransition创建手势类</h3><p>&ensp;&ensp;&ensp;&ensp;新建一个手势类<code>GestureObject</code>继承自<code>UIPercentDrivenInteractiveTransition</code>，<code>addGestureToViewController</code>是给目标控制器添加手势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface GestureObject : UIPercentDrivenInteractiveTransition</span><br><span class="line"></span><br><span class="line">//判断是交互的手势</span><br><span class="line">@property (nonatomic,assign) BOOL interacting;</span><br><span class="line"></span><br><span class="line">- (void)addGestureToViewController:(UIViewController *)viewController;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后再手势的状态之间来判断是否执行动画，这里是判断手势偏移量超过屏幕一半的高度就生效，执行相关动画，否则还原动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleGesture:(UIPanGestureRecognizer *)ges</span><br><span class="line">&#123;</span><br><span class="line">    CGPoint point = [ges translationInView:ges.view];</span><br><span class="line"></span><br><span class="line">    switch (ges.state) &#123;</span><br><span class="line">        case UIGestureRecognizerStateBegan:</span><br><span class="line">        &#123;</span><br><span class="line">            self.interacting = YES;</span><br><span class="line">            [self.targetVC dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case UIGestureRecognizerStateChanged:</span><br><span class="line">        &#123;</span><br><span class="line">            CGFloat fraction = point.y / ges.view.frame.size.height;</span><br><span class="line">            //限制在0和1之间</span><br><span class="line">            fraction = MAX(0.0, MIN(fraction, 1.0));</span><br><span class="line">            self.shouldComplete = fraction &gt; 0.5;</span><br><span class="line">            [self updateInteractiveTransition:fraction];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        case UIGestureRecognizerStateEnded:</span><br><span class="line">        case UIGestureRecognizerStateCancelled:</span><br><span class="line">        &#123;</span><br><span class="line">            self.interacting = NO;</span><br><span class="line">            if (!self.shouldComplete || ges.state == UIGestureRecognizerStateCancelled)</span><br><span class="line">            &#123;</span><br><span class="line">                //还原动画</span><br><span class="line">                [self cancelInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //完成动画</span><br><span class="line">                [self finishInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="UIViewControllerTransitioningDelegate代理方法-1"><a href="#UIViewControllerTransitioningDelegate代理方法-1" class="headerlink" title="UIViewControllerTransitioningDelegate代理方法"></a>UIViewControllerTransitioningDelegate代理方法</h3><p>&ensp;&ensp;&ensp;&ensp;回到<code>ViewController</code>中，在<code>Present</code>出<code>ThirdVC</code>的时候添加手势，在代理方法<code>interactionControllerForDismissal</code>中指定手势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)presentBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    ThirdViewController * vc = [[ThirdViewController alloc] init];</span><br><span class="line">    vc.transitioningDelegate = self;</span><br><span class="line">    [self.gestureObject addGestureToViewController:vc];</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator</span><br><span class="line">&#123;</span><br><span class="line">    return self.gestureObject.interacting ? self.gestureObject : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看效果<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/Present%E5%92%8CDismiss%E6%95%88%E6%9E%9C.gif" alt="Present和Dismiss效果.gif"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&ensp;&ensp;&ensp;&ensp; <code>Push</code>、<code>Pop</code>、<code>Present</code>、<code>Dismiss</code>、手势动画都讲解完了，可以看出，自定义转场大致的步骤是</p><ul><li><strong>根据<code>viewForKey</code>来获取转场上下文</strong></li><li><strong>将要转场的视图加入转场容器中</strong></li><li><strong>做出转场动画</strong></li><li><strong>标记转场成功的状态，根据状态做相应的处理</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;理解了这些，再复杂的转场动画都能一步步分解出来，下面是格瓦拉App的转场效果，第一次看的时候，觉得很酷炫，现在了解了转场的核心后，觉得不那么难了，有时间再把它的效果写出来吧。<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E6%A0%BC%E7%93%A6%E6%8B%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="格瓦拉转场动画.gif"></p><p><a href="https://github.com/iOS-Misaki/TransitionAnimation"><strong>源码：TransitionAnimation</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在&lt;code&gt;iOS 7&lt;/code&gt;之后，苹果就开放了自定义转场的相关&lt;code&gt;api&lt;/code&gt;，现在都快&lt;code&gt;iOS 12&lt;/code&gt;了，一直都没有好好研究转场动画，一个是之前没有重视，觉得花里胡哨的，另外一个是所做的项目中没有这样的转场动画需求。这里说的转场动画和上一篇&lt;a href=&quot;https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CAAnimation 系统动画&lt;/a&gt;中&lt;code&gt;CATransition&lt;/code&gt;动画不是一个概念，上一篇指的是单个View的转场特效，这里指的是整个控制器的转场特效。其实写上篇文章的目前也是为今天打下铺垫，复杂的转场效果也是由单个动画来组成的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CAAnimation 系列动画</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/26/CAAnimation 系列动画/</id>
    <published>2018-07-26T02:20:39.000Z</published>
    <updated>2018-07-26T14:58:08.355Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;有人问我为什么要写博客，必须要承认，现在网上一大推的优秀教程和现成的Demo，自己写的没有别人好，有些地方根本不够深入，但是看别人写文章、写代码和自己写完全是两件事，代码看看就能懂，但是自己过一遍，印象更深，消化的也就更彻底。对于iOS动画 ，一直都没有系统化的学习，只有用的时候才会查查api，之前写过一篇<a href="https://www.jianshu.com/p/92ac22afeeef" target="_blank" rel="noopener">红包雨</a>的文章，用的是关键帧动画，没有在继续下去。另一个就是在6月份面试的时候，有两个面试官都问到了基础动画，当时也回答的不好，现在详细地梳理一遍。现阶段，先把<code>Core Animation</code>弄清楚，以后再下沉到<code>OpenGL</code>和<code>CoreGraphics</code>。</p><a id="more"></a><h2 id="CAAnimation继承关系"><a href="#CAAnimation继承关系" class="headerlink" title="CAAnimation继承关系"></a>CAAnimation继承关系</h2><p>&ensp;&ensp;&ensp;&ensp;引用官方文档：</p><blockquote><p>Core Animation provides high frame rates and smooth animations without burdening the CPU and slowing down your app. Most of the work required to draw each frame of an animation is done for you. You configure animation parameters such as the start and end points, and Core Animation does the rest, handing off most of the work to dedicated graphics hardware, to accelerate rendering. For more details, see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="noopener">Core Animation Programming Guide</a>.</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;<code>Core Animation</code>提供了高帧率和流畅的动画，而不会加重CPU负担，也不会减慢应用程序的速度。你可以配置动画参数，如起始点和结束点，<code>Core animation</code>完成其余部分，将大部分工作交给专用的图形硬件，以加速渲染。</p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-98d399ad7b624a91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAAnimation类图.jpg"></p><p>&ensp;&ensp;&ensp;&ensp;对于<code>CAAnimation</code>,是核心动画基础类，不直接使用，一般用它的子类。<code>CAAnimation</code>有三个子类<code>CAPropertyAnimation、CATransition、CAAnimationGroup</code>。第二个<code>CATransition</code>是转场动画，第三个<code>CAAnimationGroup</code>是动画组。第一个<code>CAPropertyAnimation</code>又分为两个子类<code>CABasicAnimation、CAKeyframeAnimation</code>。<code>CAKeyframeAnimation</code>是关键帧动画。<code>CABasicAnimation</code>下面还有个子类<code>CASpringAnimation</code>是弹簧动画。</p><p>&ensp;&ensp;&ensp;&ensp;<code>CAPropertyAnimation</code>通过<code>animationWithKeyPath</code>来创建动画，可以看看有哪些属性可以创建动画。详见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW2" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">anchorPoint</span><br><span class="line">backgroundColor</span><br><span class="line">backgroundFilters</span><br><span class="line">borderColor</span><br><span class="line">borderWidth</span><br><span class="line">bounds</span><br><span class="line">compositingFilter</span><br><span class="line">contents</span><br><span class="line">contentsRect</span><br><span class="line">cornerRadius</span><br><span class="line">doubleSided</span><br><span class="line">filters</span><br><span class="line">frame</span><br><span class="line">hidden</span><br><span class="line">mask</span><br><span class="line">masksToBounds</span><br><span class="line">opacity</span><br><span class="line">position</span><br><span class="line">shadowColor</span><br><span class="line">shadowOffset</span><br><span class="line">shadowOpacity</span><br><span class="line">shadowPath</span><br><span class="line">shadowRadius</span><br><span class="line">sublayers</span><br><span class="line">sublayerTransform</span><br><span class="line">transform</span><br><span class="line">zPosition</span><br></pre></td></tr></table></figure><hr><h2 id="CAKeyframeAnimation-关键帧动画"><a href="#CAKeyframeAnimation-关键帧动画" class="headerlink" title="CAKeyframeAnimation 关键帧动画"></a>CAKeyframeAnimation 关键帧动画</h2><p>&ensp;&ensp;&ensp;&ensp;可以使用继承的<code>animationWithKeyPath:</code>方法创建一个<code>CAKeyframeAnimation</code>对象，并指定要在层上动画的属性的关键路径。然后可以指定用于控制时间和动画行为的关键帧值。对于大多数动画类型，可以使用值和<code>keyTimes</code>属性指定关键帧值。在动画期间，<code>Core animation</code>通过在您提供的值之间插入来生成中间值。当动画一个坐标点(例如layer的位置)的值时，你可以指定该点的路径，而不是单独的值。动画的节奏由你提供的时间信息控制。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>values</td><td style="text-align:center">用来存放关键帧的数组</td></tr><tr><td>path</td><td style="text-align:center">基于点的属性的路径。</td></tr><tr><td>keyTimes</td><td style="text-align:center">对应关键帧段的时间点的NSNumber数组</td></tr><tr><td>timingFunctions</td><td style="text-align:center">关键帧动画节奏的数组，比如快进慢出、慢进快出等</td></tr><tr><td>calculationMode</td><td style="text-align:center">确定沿路径动画的对象是否旋转以匹配路径切线</td></tr><tr><td>tensionValues</td><td style="text-align:center">定义曲线的紧密性的NSNumber数组</td></tr><tr><td>continuityValues</td><td style="text-align:center">定义时间曲线锐角的NSNumber数组</td></tr><tr><td>biasValues</td><td style="text-align:center">定义曲线相对于控制点的位置的NSNumber数组</td></tr><tr><td>Rotation Mode Values</td><td style="text-align:center">rotationMode属性使用这些常量</td></tr><tr><td>Value calculation modes</td><td style="text-align:center">calculationMode属性使用这些常量</td></tr></tbody></table><h3 id="效果代码"><a href="#效果代码" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 指定keyPath为position，通过Values来创建关键帧动画</span><br><span class="line">- (void)CAKeyframeAnimationWithValues</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat margin = 50.f;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animation];</span><br><span class="line">    animation.keyPath = @&quot;position&quot;;</span><br><span class="line">    NSValue * value0 = [NSValue valueWithCGPoint:CGPointMake(margin, margin)];</span><br><span class="line">    NSValue * value1 = [NSValue valueWithCGPoint:CGPointMake(margin, SCREENHEIGHT - margin)];</span><br><span class="line">    NSValue * value2 = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH - margin, SCREENHEIGHT - margin)];</span><br><span class="line">    NSValue * value3 = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH - margin, margin)];</span><br><span class="line">    NSValue * value4 = [NSValue valueWithCGPoint:CGPointMake(margin, margin)];</span><br><span class="line">    animation.values = @[value0,value1,value2,value3,value4];</span><br><span class="line"></span><br><span class="line">    //当我们动画完成时,如果希望动画就自动移除的话,我们可以设置此属性为YES,默认值为YES</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.duration = 4;</span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    //快入快出</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.pointView.layer addAnimation:animation forKey:@&quot;position.values&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 指定keyPath为position，通过path路径来创建关键帧动画</span><br><span class="line">- (void)CAKeyframeAnimationWithPath</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat margin = 50.f;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animation];</span><br><span class="line">    animation.keyPath = @&quot;position&quot;;</span><br><span class="line"></span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, CGRectMake(margin, margin, SCREENWIDTH - margin * 2, SCREENHEIGHT - margin * 2));</span><br><span class="line">    animation.path = path;</span><br><span class="line">    CGPathRelease(path);</span><br><span class="line"></span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.duration = 4;</span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    NSMutableArray * timingFunctionArray = [NSMutableArray new];</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; 5 ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        //每一段都是快出效果</span><br><span class="line">        CAMediaTimingFunction * timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">        [timingFunctionArray addObject:timingFunction];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    animation.timingFunctions = timingFunctionArray;</span><br><span class="line">    [self.pointView.layer addAnimation:animation forKey:@&quot;position.path&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-9916176ef3035803.gif?imageMogr2/auto-orient/strip" alt="CAKeyframeAnimation.gif"></p><p>&ensp;&ensp;&ensp;&ensp;需要注意的是removedOnCompletion设置为NO的时候，不需要layer的时候要根据key手动移除动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.pointView.layer removeAnimationForKey:@&quot;position.values&quot;];</span><br><span class="line">[self.pointView.layer removeAnimationForKey:@&quot;position.path&quot;];</span><br></pre></td></tr></table></figure></p><hr><h2 id="CATransition-转场动画"><a href="#CATransition-转场动画" class="headerlink" title="CATransition 转场动画"></a>CATransition 转场动画</h2><p>&ensp;&ensp;&ensp;&ensp;<code>CATransition</code>的父类是<code>CAAnimation</code>，和<code>CAPropertyAnimation</code>、<code>CAAnimationGroup</code>同级。<code>CATransition</code>是用来视图的转场动画。</p><blockquote><p>You can transition between a layer’s states by creating and adding a <a href="apple-reference-documentation://hckyNQAwLg" target="_blank" rel="noopener">CATransition</a> object to it. The default transition is a cross fade, but you can specify different effects from a set of predefined transitions.</p></blockquote><h3 id="重要属性-1"><a href="#重要属性-1" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>startProgress</td><td style="text-align:center">整个变形接收的起点</td></tr><tr><td>endProgress</td><td style="text-align:center">整个变形接收的终点</td></tr><tr><td>type</td><td style="text-align:center">指定转换类型</td></tr><tr><td>subtype</td><td style="text-align:center">转换方向的子类型</td></tr><tr><td>filter</td><td style="text-align:center">提供转换的图像过滤器对象</td></tr><tr><td>Common Transition Types</td><td style="text-align:center">指定可以与type属性一起使用的转换类型的常量</td></tr><tr><td>Common Transition Subtypes</td><td style="text-align:center">指定可以与subtype属性一起使用的转换类型的常量</td></tr></tbody></table><h3 id="效果代码-1"><a href="#效果代码-1" class="headerlink" title="效果代码"></a>效果代码</h3><p>&ensp;&ensp;&ensp;&ensp;其中<code>type</code>和<code>subtype</code>有官方指定的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Common transition types. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN NSString * const kCATransitionFade</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionMoveIn</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionPush</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionReveal</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line"></span><br><span class="line">/* Common transition subtypes. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromRight</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromLeft</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromTop</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromBottom</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;还有几种效果是私有API，在官方文档中找不到，<strong>慎用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cube,                     //立体</span><br><span class="line">SuckEffect,               //吮吸</span><br><span class="line">OglFlip,                  //翻转</span><br><span class="line">RippleEffect,             //波纹</span><br><span class="line">PageCurl,                 //翻页</span><br><span class="line">PageUnCurl,               //反翻页</span><br><span class="line">CameraIrisHollowOpen,     //开镜头</span><br><span class="line">CameraIrisHollowClose,    //关镜头</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;这里写了一个例子，有12种<code>type</code>转场效果和4种<code>subtype</code>转场方向，用枚举来封装一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger,CATransactionType) &#123;</span><br><span class="line">    CATransactionType_Fade = 0,                 //默认</span><br><span class="line">    CATransactionType_MoveIn,                   //覆盖</span><br><span class="line">    CATransactionType_Push,                     //推入</span><br><span class="line">    CATransactionType_Reveal,                   //揭开</span><br><span class="line"></span><br><span class="line">    CATransactionType_Cube,                     //立体</span><br><span class="line">    CATransactionType_SuckEffect,               //吮吸</span><br><span class="line">    CATransactionType_OglFlip,                  //翻转</span><br><span class="line">    CATransactionType_RippleEffect,             //波纹</span><br><span class="line">    CATransactionType_PageCurl,                 //翻页</span><br><span class="line">    CATransactionType_PageUnCurl,               //反翻页</span><br><span class="line">    CATransactionType_CameraIrisHollowOpen,     //开镜头</span><br><span class="line">    CATransactionType_CameraIrisHollowClose,    //关镜头</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (void)CATransitionWithType:(NSString *)type WithSubtype:(NSString *)subtype</span><br><span class="line">&#123;</span><br><span class="line">    CATransition * animation = [CATransition animation];</span><br><span class="line">    animation.duration = 2.f;</span><br><span class="line">    animation.type = type;</span><br><span class="line">    animation.subtype = subtype;</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.view.layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)btnClick:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    UIButton * lastBtn;</span><br><span class="line">    NSInteger index = sender.tag - 100;</span><br><span class="line">    if (index &gt; 11)</span><br><span class="line">    &#123;</span><br><span class="line">        lastBtn = (UIButton *)[self.view viewWithTag:_subtype + 100];</span><br><span class="line">        [lastBtn setBackgroundImage:[self createImageWithColor:self.subtypeNormalColor] forState:UIControlStateNormal];</span><br><span class="line">        [sender setBackgroundImage:[self createImageWithColor:self.subtypeSelectedColor] forState:UIControlStateNormal];</span><br><span class="line">        _subtype = index;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        lastBtn = (UIButton *)[self.view viewWithTag:_transactionType + 100];</span><br><span class="line">        [lastBtn setBackgroundImage:[self createImageWithColor:self.typeNormalColor] forState:UIControlStateNormal];</span><br><span class="line">        [sender setBackgroundImage:[self createImageWithColor:self.typeSelectedColor] forState:UIControlStateNormal];</span><br><span class="line">        _transactionType = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString * subtypeString ;</span><br><span class="line"></span><br><span class="line">    switch (_subtype % 4) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            subtypeString = kCATransitionFromTop;</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">            subtypeString = kCATransitionFromBottom;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            subtypeString = kCATransitionFromLeft;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            subtypeString = kCATransitionFromRight;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch (_transactionType) &#123;</span><br><span class="line">        case CATransactionType_Fade:</span><br><span class="line">            [self CATransitionWithType:kCATransitionFade WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_MoveIn:</span><br><span class="line">            [self CATransitionWithType:kCATransitionMoveIn WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_Push:</span><br><span class="line">            [self CATransitionWithType:kCATransitionPush WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_Reveal:</span><br><span class="line">            [self CATransitionWithType:kCATransitionReveal WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case CATransactionType_Cube:</span><br><span class="line">            [self CATransitionWithType:@&quot;cube&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_SuckEffect:</span><br><span class="line">            [self CATransitionWithType:@&quot;suckEffect&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_OglFlip:</span><br><span class="line">            [self CATransitionWithType:@&quot;oglFlip&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_RippleEffect:</span><br><span class="line">            [self CATransitionWithType:@&quot;rippleEffect&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_PageCurl:</span><br><span class="line">            [self CATransitionWithType:@&quot;pageCurl&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_PageUnCurl:</span><br><span class="line">            [self CATransitionWithType:@&quot;pageUnCurl&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_CameraIrisHollowOpen:</span><br><span class="line">            [self CATransitionWithType:@&quot;cameraIrisHollowOpen&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_CameraIrisHollowClose:</span><br><span class="line">            [self CATransitionWithType:@&quot;cameraIrisHollowClose&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static NSInteger i = 0;</span><br><span class="line">    self.bgView.image = i % 2 ? [UIImage imageNamed:@&quot;拉姆.jpeg&quot;] :[UIImage imageNamed:@&quot;蕾姆.jpeg&quot;];</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-1a8800f104907166.gif?imageMogr2/auto-orient/strip" alt="CATransition1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/1487718-1da95c682f270d71.gif?imageMogr2/auto-orient/strip" alt="CATransition2.gif"></p><hr><h2 id="CAAnimationGroup-动画组"><a href="#CAAnimationGroup-动画组" class="headerlink" title="CAAnimationGroup 动画组"></a>CAAnimationGroup 动画组</h2><p>&ensp;&ensp;&ensp;&ensp;分组动画在<code>CAAnimationGroup</code>实例指定的时间中运行。分组动画的持续时间不会被缩放到他们的<code>CAAnimationGroup</code>的持续时间。相反，动画被剪切到动画组的持续时间。例如，在一个动画组中分组的10秒动画，持续时间为5秒，只显示动画的前5秒。</p><h3 id="效果代码-2"><a href="#效果代码-2" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 一个红包雨的例子</span><br><span class="line">- (void)showRain</span><br><span class="line">&#123;</span><br><span class="line">    UIImageView * imageV = [UIImageView new];</span><br><span class="line">    imageV.image = [UIImage imageNamed:@&quot;page&quot;];</span><br><span class="line">    imageV.frame = CGRectMake(0, 0, 50 , 50 );</span><br><span class="line"></span><br><span class="line">    CALayer * layer = [CALayer layer];</span><br><span class="line">    layer.bounds = imageV.frame;</span><br><span class="line">    layer.contents = (id)imageV.image.CGImage;</span><br><span class="line">    layer.anchorPoint = CGPointMake(0, 0);</span><br><span class="line">    layer.position = CGPointMake(0, 0);</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [self addAnimationWithLayer:layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAnimationWithLayer:(CALayer *)layer</span><br><span class="line">&#123;</span><br><span class="line">    int height = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line">    int width = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    NSValue * A = [NSValue valueWithCGPoint:CGPointMake(arc4random() % width, 0)];</span><br><span class="line">    NSValue * B = [NSValue valueWithCGPoint:CGPointMake(arc4random() % width, height + 100)];</span><br><span class="line">    moveAnimation.values = @[A,B];</span><br><span class="line">    moveAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * tranAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    CATransform3D r0 = CATransform3DMakeRotation(M_PI/180 * (arc4random() % 360 ) , 0, 0, -1);</span><br><span class="line">    CATransform3D r1 = CATransform3DMakeRotation(M_PI/180 * (arc4random() % 360 ) , 0, 0, -1);</span><br><span class="line">    tranAnimation.values = @[[NSValue valueWithCATransform3D:r0],[NSValue valueWithCATransform3D:r1]];</span><br><span class="line">    tranAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line"></span><br><span class="line">    CAAnimationGroup * group = [[CAAnimationGroup alloc] init];</span><br><span class="line">    group.duration = arc4random() % 200 / 100.0 + 3.5;</span><br><span class="line">    group.fillMode = kCAFillModeForwards;</span><br><span class="line">    group.removedOnCompletion = NO;</span><br><span class="line">    group.animations = @[moveAnimation,tranAnimation];</span><br><span class="line">    [layer addAnimation:group forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-fbc767740432f20c.gif?imageMogr2/auto-orient/strip" alt="CAAnimationGroup.gif"></p><hr><h2 id="CASpringAnimation-弹簧动画"><a href="#CASpringAnimation-弹簧动画" class="headerlink" title="CASpringAnimation 弹簧动画"></a>CASpringAnimation 弹簧动画</h2><p>&ensp;&ensp;&ensp;&ensp;<code>CASpringAnimation</code>的父类是<code>CABasicAnimation</code>, <code>CABasicAnimation</code>可以看成是只有头尾有值的关键帧动画。</p><blockquote><p>You would typically use a spring animation to animate a layer’s position so that it appears to be pulled towards a target by a spring. The further the layer is from the target, the greater the acceleration towards it is.<br>CASpringAnimation allows control over physically based attributes such as the spring’s damping and stiffness.</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;<code>CASpringAnimation</code>是基于物理的属性控制，比如弹簧的阻尼和刚度。</p><h3 id="重要属性-2"><a href="#重要属性-2" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>damping</td><td style="text-align:center">定义弹簧运动如何受到阻尼的影响</td></tr><tr><td>initialVelocity</td><td style="text-align:center">初速度</td></tr><tr><td>mass</td><td style="text-align:center">连接到弹簧末端的物体的质量</td></tr><tr><td>settlingDuration</td><td style="text-align:center">预估静止时间</td></tr><tr><td>stiffness</td><td style="text-align:center">弹簧刚度系数</td></tr></tbody></table><h3 id="效果代码-3"><a href="#效果代码-3" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnClick:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    //frame属性不可动画化 只能通过 bounds 和 position完成</span><br><span class="line">    CASpringAnimation * animation = [CASpringAnimation animationWithKeyPath:@&quot;bounds&quot;];</span><br><span class="line"></span><br><span class="line">    //质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大</span><br><span class="line">    animation.mass = self.massSlider.value;</span><br><span class="line"></span><br><span class="line">    //刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快</span><br><span class="line">    animation.stiffness = self.stiffnessSlider.value;</span><br><span class="line"></span><br><span class="line">    //阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快</span><br><span class="line">    animation.damping = self.dampingSlider.value;</span><br><span class="line"></span><br><span class="line">    //初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反</span><br><span class="line">    animation.initialVelocity = self.velocitySlider.value;</span><br><span class="line"></span><br><span class="line">    animation.duration = 3.f;</span><br><span class="line">    animation.fromValue =  [NSValue valueWithCGRect:CGRectMake(0, 0, 80, 100)];</span><br><span class="line">    animation.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 80, 240)];</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.baseView.layer addAnimation:animation forKey:nil];</span><br><span class="line"></span><br><span class="line">    CASpringAnimation * animation1 = [CASpringAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    animation1.duration = 3.f;</span><br><span class="line">    animation1.fromValue = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH / 2 , 250)];</span><br><span class="line">    animation1.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH / 2 , 250 - 70)];</span><br><span class="line">    animation1.removedOnCompletion = NO;</span><br><span class="line">    animation1.fillMode = kCAFillModeForwards;</span><br><span class="line">    [self.baseView.layer addAnimation:animation1 forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ae46d1313229aaa6.gif?imageMogr2/auto-orient/strip" alt="CASpringAnimation.gif"></p><hr><h3 id="UIView的弹簧动画"><a href="#UIView的弹簧动画" class="headerlink" title="UIView的弹簧动画"></a>UIView的弹簧动画</h3><p>另外在看看<code>cell</code>上用<code>UIView Block</code>弹簧动画的特效</p><h4 id="效果代码-4"><a href="#效果代码-4" class="headerlink" title="效果代码"></a>效果代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration</span><br><span class="line">                      delay:(NSTimeInterval)delay</span><br><span class="line">     usingSpringWithDamping:(CGFloat)dampingRatio</span><br><span class="line">      initialSpringVelocity:(CGFloat)velocity</span><br><span class="line">                    options:(UIViewAnimationOptions)options</span><br><span class="line">                 animations:(void (^)(void))animations</span><br><span class="line">                 completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)cellAnimation</span><br><span class="line">&#123;</span><br><span class="line">    [self.springTableView reloadData];</span><br><span class="line"></span><br><span class="line">    NSArray * cellArrays = self.springTableView.visibleCells;</span><br><span class="line">    CGFloat height = self.springTableView.bounds.size.height;</span><br><span class="line"></span><br><span class="line">    for (UITableView * cell in cellArrays)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.transform = CGAffineTransformMakeTranslation(-SCREENWIDTH, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0 ; i &lt; cellArrays.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        UITableViewCell * cell = (UITableViewCell *)cellArrays[i];</span><br><span class="line">        [UIView animateWithDuration:1.5</span><br><span class="line">                              delay:0.05 * i</span><br><span class="line">             usingSpringWithDamping:0.8</span><br><span class="line">              initialSpringVelocity:0</span><br><span class="line">                            options:0 animations:^&#123;</span><br><span class="line">                    cell.transform = CGAffineTransformMakeTranslation(0, 0);</span><br><span class="line">            &#125; completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果图-4"><a href="#效果图-4" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/1487718-0a62c12dc5195c94.gif?imageMogr2/auto-orient/strip" alt="CellSpringAnimation.gif"></p><p><a href="https://github.com/iOS-Misaki/CAAnimation"><strong>源码: CAAnimation</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;有人问我为什么要写博客，必须要承认，现在网上一大推的优秀教程和现成的Demo，自己写的没有别人好，有些地方根本不够深入，但是看别人写文章、写代码和自己写完全是两件事，代码看看就能懂，但是自己过一遍，印象更深，消化的也就更彻底。对于iOS动画 ，一直都没有系统化的学习，只有用的时候才会查查api，之前写过一篇&lt;a href=&quot;https://www.jianshu.com/p/92ac22afeeef&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;红包雨&lt;/a&gt;的文章，用的是关键帧动画，没有在继续下去。另一个就是在6月份面试的时候，有两个面试官都问到了基础动画，当时也回答的不好，现在详细地梳理一遍。现阶段，先把&lt;code&gt;Core Animation&lt;/code&gt;弄清楚，以后再下沉到&lt;code&gt;OpenGL&lt;/code&gt;和&lt;code&gt;CoreGraphics&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化实践记录</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/15/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/15/iOS-组件化实践记录/</id>
    <published>2018-07-15T03:41:54.000Z</published>
    <updated>2018-07-27T03:44:24.320Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;之前，写过文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/" target="_blank" rel="noopener">CocoaPod创建私有库</a>记录创建私有库，但是发现创建Paas项目的基础库的时候，没有那么简单，基础库中又分为网络请求、数据存储、UI功能组件、基类等。好像一个<code>Spec</code>不够，难道我要创建多个单独的私有库么？<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/1487718-c1b6e8d8f12ffce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetworking.png"></p><p>&ensp;&ensp;&ensp;&ensp;再看看<code>AFNetworking</code>的结构，发现用<code>Subspecs</code>可以解决这个问题。每个<code>Subspecs</code>可以单独依赖第三方库，也可以依赖其他的<code>Subspecs</code>。这里需要注意的是每个<code>Subspecs</code>只能单向依赖，不能互相依赖。假如熟悉<code>ruby</code>的语法，<code>Subspecs</code>的格式很容易书写。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-a80a0e21b60e7e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Network子模块.png"></p><p>&ensp;&ensp;&ensp;&ensp;拿网络模块举例，依赖的第三方库是<code>YTKNetwork</code>，还依赖基础库中工具库、数据存储库、UI功能组件。（这里解释一下，为什么会依赖其他的库，每个网络请求的<code>header</code>里面都要塞入前一个请求的<code>response</code>里面的东西,请求前和回调里面显示<code>HUD</code>，<code>HUD</code>是UI功能组件的东西）。完整的<code>podSpec</code>格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             = &apos;YYPaasBaseLib&apos;</span><br><span class="line">s.version          = &apos;0.1.8&apos;</span><br><span class="line">s.summary          = &apos;Paas平台的基础库&apos;</span><br><span class="line"></span><br><span class="line">s.description      = &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">DESC</span><br><span class="line"></span><br><span class="line">s.homepage         = &apos;https://git.qianjiangcloud.com/products/paas-app-ios-plugin&apos;</span><br><span class="line">s.license          = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125;</span><br><span class="line">s.author           = &#123; &apos;yuyiios@163.com&apos; =&gt; &apos;yuyiios@163.com&apos; &#125;</span><br><span class="line">s.source           = &#123; :git =&gt; &apos;https://git.qianjiangcloud.com/products/paas-app-ios-plugin.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line"></span><br><span class="line">s.ios.deployment_target = &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Category&apos; do |category|</span><br><span class="line">category.source_files = &apos;YYPaasBaseLib/Classes/Category/*.&#123;h,m&#125;&apos;</span><br><span class="line">category.public_header_files = &apos;YYPaasBaseLib/Classes/Category/*.h&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;DataStore&apos; do |dataStore|</span><br><span class="line">dataStore.source_files = &apos;YYPaasBaseLib/Classes/DataStore/*.&#123;h,m&#125;&apos;</span><br><span class="line">dataStore.public_header_files = &apos;YYPaasBaseLib/Classes/DataStore/*.h&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Tool&apos; do |tool|</span><br><span class="line">tool.source_files = &apos;YYPaasBaseLib/Classes/Tool/*.&#123;h,m&#125;&apos;</span><br><span class="line">tool.public_header_files = &apos;YYPaasBaseLib/Classes/Tool/*.h&apos;</span><br><span class="line"></span><br><span class="line">tool.dependency &apos;YYModel&apos;, &apos;~&gt; 1.0.4&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;UI&apos; do |ui|</span><br><span class="line">ui.source_files = &apos;YYPaasBaseLib/Classes/UI/*.&#123;h,m&#125;&apos;</span><br><span class="line">ui.public_header_files = &apos;YYPaasBaseLib/Classes/UI/*.h&apos;</span><br><span class="line"></span><br><span class="line">ui.dependency &apos;Masonry&apos;, &apos;~&gt; 1.1.0&apos;</span><br><span class="line">ui.dependency &apos;MJRefresh&apos;, &apos;~&gt; 3.1.15.3&apos;</span><br><span class="line">ui.dependency &apos;MBProgressHUD&apos;, &apos;~&gt; 1.1.0&apos;</span><br><span class="line">ui.dependency &apos;IQKeyboardManager&apos;, &apos;~&gt; 6.0.4&apos;</span><br><span class="line">ui.dependency &apos;SDWebImage&apos;, &apos;~&gt; 4.4.1&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;View&apos; do |view|</span><br><span class="line">view.source_files = &apos;YYPaasBaseLib/Classes/View/*.&#123;h,m&#125;&apos;</span><br><span class="line">view.public_header_files = &apos;YYPaasBaseLib/Classes/View/*.h&apos;</span><br><span class="line">view.frameworks = &apos;WebKit&apos;</span><br><span class="line"></span><br><span class="line">view.dependency &apos;YYPaasBaseLib/Tool&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Network&apos; do |network|</span><br><span class="line">network.source_files = &apos;YYPaasBaseLib/Classes/Network/*.&#123;h,m&#125;&apos;</span><br><span class="line">network.public_header_files = &apos;YYPaasBaseLib/Classes/Network/*.h&apos;</span><br><span class="line"></span><br><span class="line">network.dependency &apos;YTKNetwork&apos;, &apos;~&gt; 2.0.4&apos;</span><br><span class="line"></span><br><span class="line">network.dependency &apos;YYPaasBaseLib/Tool&apos;</span><br><span class="line">network.dependency &apos;YYPaasBaseLib/DataStore&apos;</span><br><span class="line">network.dependency &apos;YYPaasBaseLib/UI&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Mediator&apos; do |mediator|</span><br><span class="line">mediator.source_files = &apos;YYPaasBaseLib/Classes/Mediator/*.&#123;h,m&#125;&apos;</span><br><span class="line">mediator.public_header_files = &apos;YYPaasBaseLib/Classes/Mediator/*.h&apos;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.frameworks = &apos;UIKit&apos;, &apos;Foundation&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-23b181626f3d3b6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YYPaasBaseLib.png"></p><p>&ensp;&ensp;&ensp;&ensp;一周前，就已经完成项目的基础库的创建，当时想着的是<strong>基础库和业务脱离</strong>，不需要太大的改变，但是从实际开发来看，<code>YYPaasBaseLib</code>已经从0.1.0版本更新到0.1.8版本，变动还是挺大的。关于功能的划分也是费了一番脑子，最后也把中间层<code>Mediator</code>放在基础模块里面（中间层+模块的<code>Category</code>和模块的<code>Target</code>都放在各自的业务模块中），放着这里其实不太好，但是目前没有找到更合适的方式。</p><p>&ensp;&ensp;&ensp;&ensp;其实还有些东西和基础库、业务模块都有联系。对于这块的划分很是头疼，比如<code>NSNotification</code>名称和数据存储的键名，还有网络请求关于业务成功回调的定义，有的是根据某个字段的定义，有的是判断某个对象的有无来的。暂且把这些东西叫做弱业务关系，把弱业务关系放入基础模块是不合适的，对于不同的业务模块或者项目，弱业务关系都不一样。放入具体的业务模块也不合适，冗余太大。只能单独抽出来一个弱业务关系组件，那么依赖关系应该是这样 <strong>业务组件–&gt; 弱业务组件–&gt;基础组件</strong>。想快速新建一个APP的话，要同时替换弱业务组件和部分业务组件。</p><p>&ensp;&ensp;&ensp;&ensp;<strong>组件化不是一蹴而就，需要慢慢的摸索。</strong>现在APP刚起步，模块还比较少，编译的时间比较快，属于可接受范围内，后期模块比较多的时候，编译时间会增加，而且模块成熟不需要做大量修改，那个时候再考虑二进制化，把组件的源码转换成静态库或者动态库，来提高编译速度。</p><p>&ensp;&ensp;&ensp;&ensp;iOS项目按照模块化的方式来开发，没有<code>tabBarController</code>,<code>RootController</code>直接指向首页，首页是一个<code>WKWebView</code>，业务实现都在<code>WKWebView</code>里面。原生的部分还包括登录、注册和忘记密码。<code>WkWebView</code>需要<code>token</code>的时候，H5调用原生页面去登录，从后台拿到<code>token</code>后，本地存储，然后注入<code>WKWebView</code>的<code>Cookie</code>里面。后面的工作是引入支付、加入<code>tabBarController</code>,把H5的功能都实现出来。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-efcce8811cb63474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="千匠星云下载二维码.png"></p><p>&ensp;&ensp;&ensp;&ensp;最后加一条硬广。APP在内测阶段，用企业级账号打了一个<code>.ipa</code>包，不大才<strong>2.1M</strong>,放在了免费的腾讯云上面，欢迎扫码下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;之前，写过文章&lt;a href=&quot;https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaPod创建私有库&lt;/a&gt;记录创建私有库，但是发现创建Paas项目的基础库的时候，没有那么简单，基础库中又分为网络请求、数据存储、UI功能组件、基类等。好像一个&lt;code&gt;Spec&lt;/code&gt;不够，难道我要创建多个单独的私有库么？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化尝试</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B0%9D%E8%AF%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/iOS-组件化尝试/</id>
    <published>2018-07-01T03:23:54.000Z</published>
    <updated>2018-07-27T03:38:19.227Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;<code>ReactiveCocoa</code>只更新了一篇，剩下结合登录例子来实践<code>MVVM</code>暂时没有时间，这周精力都放在了公司项目的组件化上面，以后有时间会慢慢补上。感觉欠的历史债好多。</p><a id="more"></a><h2 id="传统模块的耦合"><a href="#传统模块的耦合" class="headerlink" title="传统模块的耦合"></a>传统模块的耦合</h2><p>&ensp;&ensp;&ensp;&ensp;对于大型项目来说，业务模块之间的耦合度非常大，很难维护。模块之间会互相调用。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-14005383adc14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统模块"></p><p>&ensp;&ensp;&ensp;&ensp;为了解决这个问题，可以增加一个中间层。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-ed43c5ee1fb260b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加中间层"><br>&ensp;&ensp;&ensp;&ensp;但是模块和中间层还是互相依赖，之前耦合的问题还是存在，要改进的地方是消除中间层对业务模块的依赖。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-a1542a4366eedd5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终方案"></p><h2 id="模块的划分"><a href="#模块的划分" class="headerlink" title="模块的划分"></a>模块的划分</h2><p>&ensp;&ensp;&ensp;&ensp;组件化是把每个模块作为一个组件，在主工程里面集成所有的组件。关于用<code>CocoaPod</code>集成私有库，在上篇文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/" target="_blank" rel="noopener">CocoaPod创建私有库</a>有详细的介绍。<br>&ensp;&ensp;&ensp;&ensp;整个项目中模块的划分是分为基础模块、中间层和业务模块。</p><ul><li>基础模块里面是和业务没有任何关联的模块，里面包括网络请求、图片加载、数据存储、页面布局还有公共的工具类等。</li><li>业务模块是按照功能来划分的。根据业务需要，来确定颗粒度的大小，比如登录注册模块、用户信息模块、购物车模块、详情模块、订单模块等。业务模块是要依赖基础模块的。</li><li>中间层不依赖业务模块，只负责调度业务模块。</li></ul><h2 id="模块之间的通讯"><a href="#模块之间的通讯" class="headerlink" title="模块之间的通讯"></a>模块之间的通讯</h2><p>&ensp;&ensp;&ensp;&ensp;消除中间层对业务的依赖，有三种方案。</p><ul><li>蘑菇街 <a href="https://link.jianshu.com/?t=https://github.com/mogujie/MGJRouter.git" target="_blank" rel="noopener">MGJRouter</a> <code>URL -&gt; block</code></li><li>后来蘑菇街对这种方案提出改进<code>protocol -&gt; class</code></li><li>casatwy大神的 基于<a href="https://github.com/casatwy/CTMediator.git">CTMediator</a>的<code>Target -&gt; Action</code></li></ul><p>&ensp;&ensp;&ensp;&ensp;下面重点介绍第三种方案。把所有组件的调用都通过<code>category</code>的方式暴露出来，调用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;现在举个例子，首页要push登录页面。在中间层新建一个<code>CTMediator</code>的分类<code>CTMediator+UMAction</code>,暴露一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)CTMediator_viewControllerForDetailWithValue:(NSString *)value;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>Targe</code>t是<code>UM</code>,<code>Action</code>的对象是<code>LoginViewController</code>。然后再<code>UM</code>模块里面建立<code>Target_UM</code>文件，来处理<code>LoginViewController</code>的实例化。在首页调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIViewController * vc = [[CTMediator sharedInstance] CTMediator_viewControllerForDetailWithValue:@&quot;我是标题&quot;];</span><br><span class="line">[self.navigationController presentViewController:vc animated:YES completion:nil];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;可以看到首页并没有引入<code>LoginViewController</code>的头文件。<code>CTMediator</code> 实际上是基于<code>Runtime</code>进行类名反射，将<code>CTMediator+UMAction</code>调用生成一个<code>Target_UM</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">Class targetClass;</span><br><span class="line"></span><br><span class="line">NSObject *target = self.cachedTarget[targetClassString];</span><br><span class="line">if (target == nil) &#123;</span><br><span class="line">targetClass = NSClassFromString(targetClassString);</span><br><span class="line">target = [[targetClass alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEL action = NSSelectorFromString(actionString);</span><br><span class="line">return [self safePerformAction:action target:target params:params];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<strong>所以每添加一个模块，都要在中间层声明一个分类来调用，同时也要在相应的模块内去实现这个<code>Target</code>。</strong></p><h2 id="关于组件化的思考"><a href="#关于组件化的思考" class="headerlink" title="关于组件化的思考"></a>关于组件化的思考</h2><p>&ensp;&ensp;&ensp;&ensp;实施组件化的大致的步骤，首先是把项目解耦拆分成一个个单独的组件，然后实现组件间的通讯。</p><ul><li><p>组件化的好处<br><strong>简化了代码的整体结构，降低了维护成本，不同模块通过git管理，实现物理隔离，提高代码的稳定性，为模块的复用提供了基础，未来可以灵活的扩展业务。</strong></p></li><li><p>组件化的缺点。<br><strong>学习成本高，对开发人员掌握各种工具要求比较高，入门比较困难，个人学习制作私有库，也是踩了好多坑。前期基业务没有实现，要提前考虑模块之间的解耦，过多的关注组件间的通讯，必然导致开发效率的下降。</strong></p></li></ul><p>&ensp;&ensp;&ensp;&ensp;说一下项目，脱离实际项目谈架构都是扯淡。目前接手的项目是个电商类的项目，iOS 和安卓都还没有起步，web前端已经实现1.0版本，基本的电商的功能都实现了。iOS项目目前就两个人。项目想做成一个模板，然后给不同的客户提供可定制化的功能。项目管理人员想推行组件化，这周我在实践这一方案的可行性。<br>&ensp;&ensp;&ensp;&ensp;并不是所有项目是适用于组件化。就对于现在的项目来说，只有两个开发人员。我来确定代码规范，不存在多人协同冲突的情况。产品虽然说后端接口和web前端都实现了，但是iOS和安卓项目都还没起步，实现最基础的业务，快速迭代上线更加重要，现有MVC或者MVVM就足够现实了。当实现了基础业务，需要更多对细节关注，才差不多要考虑组件化。<br>&ensp;&ensp;&ensp;&ensp;组件化适合业务成熟且繁杂、开发人员多的大团队，对于我们两人且还没有开启项目的团队至少现在这个时间节点来说是不合适的。适合项目的架构就是好架构，组件化是好技术，但是在不合适的时候盲目追求组件化，是本末倒置的。</p><p><strong>参考 :</strong><br><a href="https://casatwy.com/modulization_in_action.html" target="_blank" rel="noopener">在现有工程中实施基于CTMediator的组件化方案</a><br><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;code&gt;ReactiveCocoa&lt;/code&gt;只更新了一篇，剩下结合登录例子来实践&lt;code&gt;MVVM&lt;/code&gt;暂时没有时间，这周精力都放在了公司项目的组件化上面，以后有时间会慢慢补上。感觉欠的历史债好多。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPod 创建私有库</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/CocoaPod-创建私有库/</id>
    <published>2018-07-01T01:35:21.000Z</published>
    <updated>2018-07-27T03:35:42.215Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在码云(<a href="https://gitee.com/yuyiios/events" target="_blank" rel="noopener">我的个人主页</a>)上创建两个远程仓库，其中<code>YYSpecs</code> 用来存放本地的<code>spec</code>,<code>YYToolProject</code>是用来存放私有库代码的。</p><h2 id="创建本地索引"><a href="#创建本地索引" class="headerlink" title="创建本地索引"></a>创建本地索引</h2><p>&ensp;&ensp;&ensp;&ensp;首先 进入<code>~/.cocoapods/repos</code>目录 查看有一个<code>master</code>的目录，<code>master</code>就是<code>cocoapod</code>官网的索引源，现在要做的就是创建自己私有的<code>Spec Repo</code>.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span><br><span class="line">pod repo add YYSpecs  https://gitee.com/yuyiios/YYSpecs.git</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1487718-8a8184268cf14700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="~:.cocoapods:repos目录.png"></p><p>&ensp;&ensp;&ensp;&ensp;然后可以看见<code>master</code>有个同级目录<code>YYSpecs</code>。私有<code>Spec Repo</code>就创建完成了。</p><h2 id="创建本地lib"><a href="#创建本地lib" class="headerlink" title="创建本地lib"></a>创建本地lib</h2><p>&ensp;&ensp;&ensp;&ensp;进入桌面目录，创建一个名为<code>YYToolSet</code>的<code>pod</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create YYToolSet</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;会有以下提示，按照问题回答就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide: </span><br><span class="line">- https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line">( hold cmd and double click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line">&gt; </span><br><span class="line">ios</span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line">&gt; ObjC</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line">&gt; No</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">&gt; None</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line">&gt; No</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line">&gt; YY</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;在Finder中，将<code>/YYToolSet/Classes</code>目录下的<code>ReplaceMe.m</code>删除 替换成自己的文件，如图。<img src="https://upload-images.jianshu.io/upload_images/1487718-465ead8a2f11b57d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="替换掉ReplaceMe文件.png"><br>&ensp;&ensp;&ensp;&ensp;打开工程，查看<code>YYToolSet.podspec</code>文件</p><ul><li>s.version 是pod的版本信息 这个后面打tag的时候用的到</li><li>s.summary 是简短的描述</li><li>s.source 是项目远程仓库的地址，这里不要用SSH，用HTTPS。</li><li>s.homepage 是项目主页地址 就是HTTPS地址后面去掉.git 就可以</li><li>s.source_files 是项目的文件 就是刚才替换ReplaceMe.m的那些文件 </li><li>s.resource_bundles 是资源文件</li><li>s.frameworks 是用到了系统的哪些库 例如UIKit、Foundation</li><li>s.dependency 是用到哪些第三方库 比如AFNetworking 有多个就写多个s.dependency</li><li>s.public_header_files 项目的公共头文件，举个例子，当引入Masonry、YTKNetwork的时候 可以创建一个header文件，然后将#import “Masonry.h”    #import “YTKNetwork.h”写入进去</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ed45e32c442d9704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置文件.png"></p><h2 id="验证本地lib"><a href="#验证本地lib" class="headerlink" title="验证本地lib"></a>验证本地lib</h2><p>&ensp;&ensp;&ensp;&ensp;修改完成后，切换到外面的<code>YYToolSet</code>目录，验证<code>podspec</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line">pod lib lint --verbose</span><br><span class="line">pod lib lint --allow-warnings</span><br><span class="line">pod lib lint --sources=https://gitee.com/yuyiios/YYSpecs.git</span><br><span class="line">pod lib lint --use-libraries</span><br></pre></td></tr></table></figure></p><ul><li>–verbose 假如有error,查看报错信息</li><li>–allow-warnings 假如有warning，可以通过来忽略错误信息通过验证 </li><li>–sources 假如这个私有库还依赖其他的私有库，一定要指定私有库的索引源（就是我上文说的YYSpecs的git地址）–sources=<a href="https://github.com/artsy/Specs,master">https://github.com/artsy/Specs,master</a></li><li>–use-libraries 如果用了第三方的framework或者静态库，要加上。</li></ul><h2 id="验证本地和远端的pod"><a href="#验证本地和远端的pod" class="headerlink" title="验证本地和远端的pod"></a>验证本地和远端的pod</h2><p>&ensp;&ensp;&ensp;&ensp;本地校验成功后，推送至远端，就是<code>YYToolProject</code>的git地址。进入外面的<code>YYToolSet</code>目录。执行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [GitHub HTTPS clone URL]</span><br><span class="line">git remote add origin https://gitee.com/yuyiios/YYToolProject.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;有冲突先解决冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;fix&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后给<code>pod</code>打上标签，并且推送至远端，注意这里的<code>tag</code>要和<code>podspec</code>文件里面的<code>s.version</code>对应起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -m &apos;0.1.0标签&apos; -a 0.1.0</span><br><span class="line">git push --tags</span><br><span class="line">git tag //查看标签</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;打完标签后，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>pod lib lint</code>和<code>pod spec lint</code>的区别是前者只会检验本地的<code>pod</code>,后者是本地和远端都会检验，所以之前用到的<code>--allow-warning  --sources --use-libraries</code> 等命令的这里都要带上。</p><h2 id="推送至索引源仓库"><a href="#推送至索引源仓库" class="headerlink" title="推送至索引源仓库"></a>推送至索引源仓库</h2><p>&ensp;&ensp;&ensp;&ensp;远端和本地都校验通过后就要将<code>YYToolSet.podspec</code>推送至<code>YYSpecs</code>仓库中 成功后去<code>~/.cocoapods/repos/YYSpecs</code> 有个<code>YYToolSet</code>目录 有个0.1.0的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [Repo名] [podspec 文件名字]</span><br><span class="line">pod repo push YYSpecs YYToolSet.podspec</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;最后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pod search YYToolSet </span><br><span class="line">-&gt; YYToolSet (0.1.0)</span><br><span class="line">工具集 YYToolSet.</span><br><span class="line">pod &apos;YYToolSet&apos;, &apos;~&gt; 0.1.0&apos;</span><br><span class="line">- Homepage: https://gitee.com/yuyiios/YYToolProject</span><br><span class="line">- Source:   https://gitee.com/yuyiios/YYToolProject.git</span><br><span class="line">- Versions: 0.1.0 [YYSpecs repo]</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;新建一个空项目，导入私有库验证一下，这里一定要带上<code>source</code> 就是<code>YYToolSet</code>所在索引源的远端地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pod init </span><br><span class="line">vim Podfile</span><br><span class="line"></span><br><span class="line">source &apos;https://gitee.com/yuyiios/YYToolProject.git&apos;</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">source &apos;https://gitee.com/yuyiios/YYSpecs.git&apos;</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;None&apos; do</span><br><span class="line">pod &apos;YYToolSet&apos;, &apos;~&gt; 0.1.0&apos;</span><br><span class="line"># use_frameworks!</span><br><span class="line"></span><br><span class="line"># Pods for None</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-685e87a6ae906c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证通过.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在码云(&lt;a href=&quot;https://gitee.com/yuyiios/events&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的个人主页&lt;/a&gt;)上创建两个远程仓库，其中&lt;code&gt;YYSpecs&lt;/code&gt; 用来存放本地的&lt;code&gt;spec&lt;/code&gt;,&lt;code&gt;YYToolProject&lt;/code&gt;是用来存放私有库代码的。&lt;/p&gt;
&lt;h2 id=&quot;创建本地索引&quot;&gt;&lt;a href=&quot;#创建本地索引&quot; class=&quot;headerlink&quot; title=&quot;创建本地索引&quot;&gt;&lt;/a&gt;创建本地索引&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;首先 进入&lt;code&gt;~/.cocoapods/repos&lt;/code&gt;目录 查看有一个&lt;code&gt;master&lt;/code&gt;的目录，&lt;code&gt;master&lt;/code&gt;就是&lt;code&gt;cocoapod&lt;/code&gt;官网的索引源，现在要做的就是创建自己私有的&lt;code&gt;Spec Repo&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 8种经典算法可视化</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/18/iOS-8%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/18/iOS-8种经典算法可视化/</id>
    <published>2018-04-18T15:32:26.000Z</published>
    <updated>2018-07-26T16:10:02.189Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;先看图，这里为了方便展示gif图片，在冒泡排序、选择排序、插入排序，视图更新停留的时间设置为0.001秒，其他排序设置视图更新时间为0.003秒。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/1487718-c67a8b114e5a12b8.gif?imageMogr2/auto-orient/strip" alt="0冒泡排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ab8a517890793cd8.gif?imageMogr2/auto-orient/strip" alt="1选择排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-94a562e4f40c9067.gif?imageMogr2/auto-orient/strip" alt="2插入排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-20d8e1c4744b3002.gif?imageMogr2/auto-orient/strip" alt="3快速排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-2db8865d136d7b27.gif?imageMogr2/auto-orient/strip" alt="4希尔排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-92b55075ee71d41f.gif?imageMogr2/auto-orient/strip" alt="5归并排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-f489ad65de02a3a1.gif?imageMogr2/auto-orient/strip" alt="6堆排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-333d51fc00d19b26.gif?imageMogr2/auto-orient/strip" alt="7基数排序（0.003s）.gif"></p><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><img src="https://upload-images.jianshu.io/upload_images/1487718-3fe0a1205ccd214d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复杂度.jpg"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="高度可视化"><a href="#高度可视化" class="headerlink" title="高度可视化"></a>高度可视化</h3><p>&ensp;&ensp;&ensp;&ensp;首先，用视图<code>SortView</code>的高度来代表随机数，为了便于查看，本身的颜色随着高度变化而变化，对外暴露一个更改高度的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SortView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SortView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        self.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat y = self.superview.frame.size.height - self.frame.size.height;</span><br><span class="line"></span><br><span class="line">    CGRect frame = self.frame;</span><br><span class="line">    frame.origin.y = y;</span><br><span class="line">    self.frame = frame;</span><br><span class="line"></span><br><span class="line">    CGFloat weight = frame.size.height / self.superview.frame.size.height;</span><br><span class="line">    UIColor * color = [UIColor colorWithHue:weight saturation:1 brightness:1 alpha:1];</span><br><span class="line">    self.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateHeight:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    CGRect temp = self.frame;</span><br><span class="line">    temp.size.height = height;</span><br><span class="line">    self.frame = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后再生成随机数数组和<code>sortView</code>数组一一对应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 生成随机数数组</span><br><span class="line">- (void)setup_random</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; self.count ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int height = (int)(SCREENHEIGHT - 200);</span><br><span class="line">        NSInteger random = arc4random() % height;</span><br><span class="line">        NSNumber * num = [NSNumber numberWithInteger:random];</span><br><span class="line">        [self.randomArray addObject:num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)addSortViews</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; self.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        CGFloat width = SCREENWIDTH / self.count;</span><br><span class="line">        SortView * sortView = [[SortView alloc]initWithFrame:CGRectMake(i * width, 0, width, [self.randomArray[i] integerValue])];</span><br><span class="line">        [self.containerView addSubview:sortView];</span><br><span class="line">        [self.sortViewArray addObject:sortView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="排序交换回调"><a href="#排序交换回调" class="headerlink" title="排序交换回调"></a>排序交换回调</h3><p>&ensp;&ensp;&ensp;&ensp;然后在排序类，定义一个回调<code>SortObjectBlock</code>，用于更新视图的高度。<code>index</code>参数是在数组的索引值，<code>value</code>是索引值对应元素要修改的高度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SortObjectBlock)(NSInteger index,NSNumber * value);</span><br><span class="line"></span><br><span class="line">@interface SortObject : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) SortObjectBlock sortObjectBlock;</span><br></pre></td></tr></table></figure></p><h3 id="阻塞时间完成视觉效果"><a href="#阻塞时间完成视觉效果" class="headerlink" title="阻塞时间完成视觉效果"></a>阻塞时间完成视觉效果</h3><p><code>SortObjectBlock</code>在排序的时候，接收回调,为了方面观察排序的变化，每次数组中有值发生变化的时候阻塞线程0.001s。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)sort</span><br><span class="line">&#123;</span><br><span class="line">    SortObject *  sortObject = [SortObject new];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    sortObject.sortObjectBlock = ^(NSInteger index,NSNumber * value)&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.001];</span><br><span class="line">        [weakSelf updateSortViewWithIndex:index widthValue:value];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 更新视图</span><br><span class="line">- (void)updateSortViewWithIndex:(NSInteger)index widthValue:(NSNumber *)value</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        SortView * sortView = (SortView *)[weakSelf.sortViewArray objectAtIndex:index];</span><br><span class="line">        [sortView updateHeight:[value integerValue]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8种算法"><a href="#8种算法" class="headerlink" title="8种算法"></a>8种算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 冒泡</span><br><span class="line">- (NSMutableArray *)sort0:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger j = 0 ; j &lt; i ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i] &lt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(i,array[j]);</span><br><span class="line">                    _sortObjectBlock(j,array[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 选择排序</span><br><span class="line">- (NSMutableArray *)sort1:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger j = i + 1 ; j &lt; array.count ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i] &gt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(i,array[j]);</span><br><span class="line">                    _sortObjectBlock(j,array[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark - 插入排序</span><br><span class="line">- (NSMutableArray *)sort2:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSNumber * temp = array[i];</span><br><span class="line">        for (NSInteger j = i - 1 ; j &gt;= 0 &amp;&amp; temp &lt; array[j] ; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(j,array[j + 1]);</span><br><span class="line">                _sortObjectBlock(j + 1,array[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            [array exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>&ensp;&ensp;&ensp;&ensp;快速排序是对冒泡排序的一种改进，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 快速排序</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)sort3:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self quickSort:array leftIndex:0 rightIndex:array.count - 1];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)quickSort:(NSMutableArray *)array leftIndex:(NSInteger)left rightIndex:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    if (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        NSInteger temp = [self getMiddleIndex:array leftIndex:left rightIndex:right];</span><br><span class="line">        //递归前半部分</span><br><span class="line">        [self quickSort:array leftIndex:left rightIndex:temp - 1];</span><br><span class="line">        //递归后半部分</span><br><span class="line">        [self quickSort:array leftIndex:temp + 1 rightIndex:right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组以第一个值为准分成两部分，前半部分比该值要小，后半部分比该值要大</span><br><span class="line">- (NSInteger)getMiddleIndex:(NSMutableArray *)array leftIndex:(NSInteger)left rightIndex:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * temp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; temp &lt;= array[right]) &#123;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(left,array[right]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = array[right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt;= temp) &#123;</span><br><span class="line">            left ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(right,array[left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[right] = array[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_sortObjectBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sortObjectBlock(left,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[left] = temp;</span><br><span class="line"></span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>&ensp;&ensp;&ensp;&ensp;希尔排序又叫缩小增量排序，属于插入排序的一种。把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。这里取得的增量为一半。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 希尔排序</span><br><span class="line">- (NSMutableArray *)sort4:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger increment = array.count / 2 ; increment &gt; 0 ; increment /= 2 )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger i = increment ; i &lt; array.count ; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSInteger j = i ;</span><br><span class="line">            for (; j - increment &gt;= 0 &amp;&amp; array[j] &lt; array[j-increment]; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(j,array[j - increment]);</span><br><span class="line">                    _sortObjectBlock(j - increment,array[j]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:j withObjectAtIndex:(j - increment)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&ensp;&ensp;&ensp;&ensp;归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 归并排序</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)sort5:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self megerSortWithArray:array];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)megerSortWithArray:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * tempArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    //将数组中的每一个元素放入一个数组中</span><br><span class="line">    for (NSNumber * num in array)</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * subArray = [NSMutableArray array];</span><br><span class="line">        [subArray addObject:num];</span><br><span class="line">        [tempArray addObject:subArray];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对这个数组中的数组进行合并，直到合并完毕为止</span><br><span class="line">    while (tempArray.count != 1) &#123;</span><br><span class="line">        NSInteger i = 0 ;</span><br><span class="line">        while (i &lt; tempArray.count - 1) &#123;</span><br><span class="line">            //将tempArray[i] 和 tempArray[i+1]合并</span><br><span class="line">            tempArray[i] = [self mergeArrayFirstList:tempArray[i] secondList:tempArray[i + 1]];</span><br><span class="line">            [tempArray removeObjectAtIndex:(i + 1)];</span><br><span class="line">            </span><br><span class="line">            for (NSInteger subIndex = 0 ; subIndex &lt; [tempArray[i] count]; subIndex ++)</span><br><span class="line">            &#123;</span><br><span class="line">                NSInteger index = [self countEndIndex:i SubItemIndex:subIndex TempArray:tempArray];</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(index,tempArray[i][subIndex]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    array = tempArray[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将两个有序数组进行合并,返回一个排序好的数组</span><br><span class="line">- (NSArray *)mergeArrayFirstList:(NSArray *)array1 secondList:(NSArray *)array2</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * resultArray = [NSMutableArray array];</span><br><span class="line">    NSInteger firstIndex = 0;</span><br><span class="line">    NSInteger secondIndex = 0;</span><br><span class="line">    while (firstIndex &lt; array1.count &amp;&amp; secondIndex &lt; array2.count) &#123;</span><br><span class="line">        if ([array1[firstIndex] integerValue] &lt; [array2[secondIndex] integerValue])</span><br><span class="line">        &#123;</span><br><span class="line">            [resultArray addObject:array1[firstIndex]];</span><br><span class="line">            firstIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [resultArray addObject:array2[secondIndex]];</span><br><span class="line">            secondIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (firstIndex &lt; array1.count) &#123;</span><br><span class="line">        [resultArray addObject:array1[firstIndex]];</span><br><span class="line">        firstIndex ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (secondIndex &lt; array2.count) &#123;</span><br><span class="line">        [resultArray addObject:array2[secondIndex]];</span><br><span class="line">        secondIndex ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return resultArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)countEndIndex:(NSInteger)endIndex SubItemIndex:(NSInteger)subItemIndex TempArray:(NSMutableArray *)tempArray</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger sum = 0 ;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; endIndex ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += [tempArray[i] count];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum + subItemIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>&ensp;&ensp;&ensp;&ensp;它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 堆排序</span><br><span class="line">- (NSMutableArray *)sort6:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    return [self heapSort:array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)heapSort:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * list = [NSMutableArray arrayWithArray:array];</span><br><span class="line">    NSInteger endIndex = array.count - 1;</span><br><span class="line">    //创建大顶堆 把array 转换为大顶堆层次的遍历结果</span><br><span class="line">    [self heapCreate:list];</span><br><span class="line"></span><br><span class="line">    while (endIndex &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">        //交换大顶堆的收尾两个值</span><br><span class="line">        if (_sortObjectBlock)</span><br><span class="line">        &#123;</span><br><span class="line">            _sortObjectBlock(0,list[endIndex]);</span><br><span class="line">            _sortObjectBlock(endIndex,list[0]);</span><br><span class="line"></span><br><span class="line">            [list exchangeObjectAtIndex:0 withObjectAtIndex:endIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //缩小大顶堆的范围</span><br><span class="line">        endIndex -- ;</span><br><span class="line">        [self heapAdjast:list withStartIndex:0 withEndIndex:endIndex + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构建大顶堆的层次遍历序列</span><br><span class="line">- (void)heapCreate:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger i = array.count;</span><br><span class="line">    for (; i &gt; 0; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        [self heapAdjast:array withStartIndex:i - 1 withEndIndex:array.count];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对大顶堆的局部调整，使其改节点的所有父类符合大顶堆的特点</span><br><span class="line">- (void)heapAdjast:(NSMutableArray *)array withStartIndex:(NSInteger)startIndex withEndIndex:(NSInteger)endIndex</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * temp = array[startIndex];</span><br><span class="line">    //父节点下标</span><br><span class="line">    NSInteger fatherIndex = startIndex + 1;</span><br><span class="line">    //左孩子下标</span><br><span class="line">    NSInteger leftChildIndex = fatherIndex * 2;</span><br><span class="line">    while (leftChildIndex &lt;= endIndex) &#123;</span><br><span class="line">        //比较左右节点 找出较大的角标</span><br><span class="line">        if (leftChildIndex &lt; endIndex &amp;&amp; array[leftChildIndex - 1] &lt; array[leftChildIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            leftChildIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果较大的子节点比根节点大 赋值为父节点</span><br><span class="line">        if (temp &lt; array[leftChildIndex - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(fatherIndex - 1,array[leftChildIndex - 1]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[fatherIndex - 1] = array[leftChildIndex - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fatherIndex = leftChildIndex;</span><br><span class="line">        leftChildIndex = fatherIndex * 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_sortObjectBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sortObjectBlock(fatherIndex - 1,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[fatherIndex - 1] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>&ensp;&ensp;&ensp;&ensp;它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 基数排序</span><br><span class="line">- (NSMutableArray *)sort7:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self radixSort:array];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)radixSort:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    //创建空桶</span><br><span class="line">    NSMutableArray * bucket = [self createBucket];</span><br><span class="line"></span><br><span class="line">    //待排数组的最大数值</span><br><span class="line">    NSNumber * maxNumber = [self listMaxItem:array];</span><br><span class="line"></span><br><span class="line">    //最大数值的数字位数</span><br><span class="line">    NSInteger maxLength = [self numberLength:maxNumber];</span><br><span class="line"></span><br><span class="line">    //按照从低位到高位的顺序执行排序过程</span><br><span class="line">    for (NSInteger digit = 1 ; digit &lt;= maxLength ; digit ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        //入桶</span><br><span class="line">        for (NSNumber * item in array)</span><br><span class="line">        &#123;</span><br><span class="line">            //确定item 归属哪个桶 以digit位数为基数</span><br><span class="line">            NSInteger baseNumber = [self fetchBaseNumber:item digit:digit];</span><br><span class="line">            NSMutableArray * mutArray = bucket[baseNumber];</span><br><span class="line">            //将数据放入空桶上</span><br><span class="line">            [mutArray addObject:item];            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSInteger index = 0;</span><br><span class="line"></span><br><span class="line">        //出桶</span><br><span class="line">        for (NSInteger i = 0 ; i &lt; bucket.count ; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSMutableArray * subArray = bucket[i];</span><br><span class="line">            //将桶的数据放回待排数组中</span><br><span class="line">            while (subArray.count != 0) &#123;</span><br><span class="line">                NSNumber * number = [subArray objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(index,number);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[index] = number;</span><br><span class="line">                [subArray removeObjectAtIndex:0];</span><br><span class="line">                index ++ ;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建空桶</span><br><span class="line">- (NSMutableArray *)createBucket</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * bucket = [NSMutableArray array];</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; 10 ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * array = [NSMutableArray array];</span><br><span class="line">        [bucket addObject:array];</span><br><span class="line">    &#125;</span><br><span class="line">    return bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取列表最大值</span><br><span class="line">- (NSNumber *)listMaxItem:(NSArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * maxNumber = array[0];</span><br><span class="line">    for (NSNumber * number in array)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxNumber &lt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNumber = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数字的位数</span><br><span class="line">- (NSInteger)numberLength:(NSNumber *)number</span><br><span class="line">&#123;</span><br><span class="line">    NSString * string = [NSString stringWithFormat:@&quot;%ld&quot;,(long)[number integerValue]];</span><br><span class="line">    return string.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//number 操作的数字  digit 位数  返回该位数上的数字</span><br><span class="line">- (NSInteger)fetchBaseNumber:(NSNumber *)number digit:(NSInteger)digit</span><br><span class="line">&#123;</span><br><span class="line">    //digit为基数位数</span><br><span class="line">    if (digit &gt; 0 &amp;&amp; digit &lt;= [self numberLength:number])</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * numbersArray = [NSMutableArray array];</span><br><span class="line">        NSString * string = [NSString stringWithFormat:@&quot;%ld&quot;,[number integerValue]];</span><br><span class="line">        for (NSInteger index = 0 ; index &lt; [self numberLength:number] ; index ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSString * temp = [string substringWithRange:NSMakeRange(index, 1)];</span><br><span class="line">            [numbersArray addObject:temp];</span><br><span class="line">        &#125;</span><br><span class="line">        NSString * str = numbersArray[numbersArray.count - digit];</span><br><span class="line">        return [str integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考:<a href="https://www.cnblogs.com/ludashi/p/6065086.html" target="_blank" rel="noopener">iOS可视化动态绘制八种排序过程(Swift版)</a></strong></p><p><strong>源码:<a href="https://github.com/iOS-Misaki/SortDemo">SortDemo</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;先看图，这里为了方便展示gif图片，在冒泡排序、选择排序、插入排序，视图更新停留的时间设置为0.001秒，其他排序设置视图更新时间为0.003秒。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage 源码浅析</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/11/SDWebImage-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/11/SDWebImage-源码浅析/</id>
    <published>2018-04-11T03:49:26.000Z</published>
    <updated>2018-07-27T06:39:51.109Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在iOS的图片加载框架中，SDWebImage可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件。在项目中使用SDWebImage来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。本篇文章会着重讲解<code>SDImageCache</code>、<code>SDWebImageDownloader</code>这两个类。<br><a id="more"></a></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-7bd27225e029042f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage类图.png"></p><h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>&ensp;&ensp;&ensp;&ensp;在<code>SDWebImage</code>中，图片的下载是由<code>SDWebImageDownloader</code>完成的。<code>SDWebImageDownloader</code>是个单例，先来看下载选项，<code>SDWebImageDownloaderOptions</code>枚举。主要涉及到下载的优先级、缓存、后台执行、<code>cookies</code>这些方面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 默认请求不使用缓存</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 如果冲缓存中读取图片，使用nil来传参完成block</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    /**</span><br><span class="line">    * 在iOS 4.0以上的系统可以后台下载</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 可以自定义下载的cookies</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 允许不受信任的SSL证书</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 图片下载放在高优先级</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下载顺序也定义了一个枚举，默认的是队列的方式，先进先出，另一种是先进后出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>图片下载是在<code>NSOperationQueue</code>队列中完成的，默认队列的最大并发数6。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br></pre></td></tr></table></figure></p><p>下载图片的操作对应一些回调，进度条的回调，下载完成的回调，<code>header</code>过滤等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"></span><br><span class="line">typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"></span><br><span class="line">typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) NSMutableDictionary *URLCallbacks;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;在下载器的<code>URLCallbacks</code>属性中，是个可变字典，<code>key</code>是图片的<code>url</code>,<code>value</code>是个数组，存放每张图片的多组回调信息。由于允许多个图片同时下载，所以会有多个线程同时操作<code>URLCallbacks</code>，所以把这下操作都放在<code>GCD</code>的栅栏队列中，隔离开来，避免线程的不安全性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback </span><br><span class="line">&#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) </span><br><span class="line">    &#123;</span><br><span class="line">        if (completedBlock != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first = NO;</span><br><span class="line">        if (!self.URLCallbacks[url]) </span><br><span class="line">        &#123;</span><br><span class="line">            self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">            first = YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Handle single download of simultaneous download request for the same URL</span><br><span class="line">        NSMutableArray *callbacksForURL = self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        if (first) </span><br><span class="line">        &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;图片下载器下载的时候放在<code>downloadImageWithURL:options:progress:completed:</code>方法来处理的，里面调用刚才提到的方法，把请求的信息存入管理器中，同时在创建回调的<code>block</code>中创建新的操作，配置后放入<code>downloadQueue</code>的操作队列中，最后方法返回新创建的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock </span><br><span class="line">&#123;</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __weak __typeof(self)wself = self;</span><br><span class="line"></span><br><span class="line">    [self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) </span><br><span class="line">        &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建请求对象，根据options参数设置属性</span><br><span class="line">        // 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        if (wself.headersFilter) </span><br><span class="line">        &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建SDWebImageDownloaderOperation，配置参数，包括是否需要认证、优先级</span><br><span class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                          options:options</span><br><span class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line"></span><br><span class="line">                                                        //从管理器的callbacksForURL中找出URL所有的进度处理回调并调用</span><br><span class="line">                                                        SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                        if (!sself) return;</span><br><span class="line">                                                        __block NSArray *callbacksForURL;</span><br><span class="line">                                                        dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                            callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                        &#125;);</span><br><span class="line">                                                        </span><br><span class="line">                                                        for (NSDictionary *callbacks in callbacksForURL) </span><br><span class="line">                                                        &#123;</span><br><span class="line">                                                            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) </span><br><span class="line">                                                        &#123;</span><br><span class="line">                                                            //从管理器的callbacksForURL中找出该URL所有的进度处理回调并且调用</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            if (!sself) return;</span><br><span class="line">                                                            __block NSArray *callbacksForURL;</span><br><span class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                                //完成后，将URL对应的回调信息从URLCallbacks中删除</span><br><span class="line">                                                                if (finished) </span><br><span class="line">                                                                &#123;</span><br><span class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                                &#125;</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                            for (NSDictionary *callbacks in callbacksForURL) </span><br><span class="line">                                                            &#123;</span><br><span class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                        cancelled:^&#123;</span><br><span class="line">                                                            //取消操作将该url对应的回调信息从URLCallbacks中删除</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            if (!sself) return;</span><br><span class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;];</span><br><span class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">        if (wself.username &amp;&amp; wself.password) </span><br><span class="line">        &#123;</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) </span><br><span class="line">        &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (options &amp; SDWebImageDownloaderLowPriority) </span><br><span class="line">        &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将操作加入到操作队列downloadQueue中</span><br><span class="line">        //根据下载枚举的顺序来确定队列的顺序</span><br><span class="line">        [wself.downloadQueue addOperation:operation];</span><br><span class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) </span><br><span class="line">        &#123;</span><br><span class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">            [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">            wself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下载操作<br><code>SDWebImage</code>定义了一个协议<code>SDWebImageOperation</code>，协议只声明了一个<code>cancel</code>方法，用于取消操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)cancel;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><code>SDWebImageDownloaderOperation</code>在分类中采用了<code>NSURLConnectionDataDelegate</code>协议，并且实现了该协议的一下几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</span><br><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection __unused *)connection;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</span><br></pre></td></tr></table></figure></p><p>重点来看<code>didReceiveData</code>方法，主要任务是接收数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 附加数据</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        // 获取已下载数据总大小</span><br><span class="line">        const NSInteger totalSize = self.imageData.length;</span><br><span class="line"></span><br><span class="line">        // 更新数据源 这里要传入所有的数据，而不仅是新数据</span><br><span class="line">        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);</span><br><span class="line"></span><br><span class="line">        // 第一次获取数据时，从这些数据获取图片的长、宽、方向</span><br><span class="line">        if (width + height == 0) </span><br><span class="line">        &#123;</span><br><span class="line">            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);</span><br><span class="line">            if (properties) </span><br><span class="line">            &#123;</span><br><span class="line">                NSInteger orientationValue = -1;</span><br><span class="line">                CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);</span><br><span class="line">                val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;width);</span><br><span class="line">                val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">                CFRelease(properties);</span><br><span class="line"></span><br><span class="line">                // 制到Core Graphics的时候，会丢失方向信息，有时候由initWithCGIImage创建的方向会不对，所以在里面先保存方向信息</span><br><span class="line">                orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //图片还没有下载完成</span><br><span class="line">        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) </span><br><span class="line">        &#123;</span><br><span class="line">            // 使用现有的数据创建图片对象，如果数据中存有多张图片，取第一张</span><br><span class="line"></span><br><span class="line">            #ifdef TARGET_OS_IPHONE</span><br><span class="line">            // iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理</span><br><span class="line">            if (partialImageRef) </span><br><span class="line">            &#123;</span><br><span class="line">                const size_t partialHeight = CGImageGetHeight(partialImageRef);</span><br><span class="line">                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">                CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">                CGColorSpaceRelease(colorSpace);</span><br><span class="line">                if (bmContext) </span><br><span class="line">                &#123;</span><br><span class="line">                    CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef = CGBitmapContextCreateImage(bmContext);</span><br><span class="line">                    CGContextRelease(bmContext);</span><br><span class="line">                &#125;   </span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef = nil;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            //图片的缩放、解码操作</span><br><span class="line">            if (partialImageRef) </span><br><span class="line">            &#123;</span><br><span class="line">                UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];</span><br><span class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                UIImage *scaledImage = [self scaledImageForKey:key image:image];</span><br><span class="line">                if (self.shouldDecompressImages) </span><br><span class="line">                &#123;</span><br><span class="line">                    image = [UIImage decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    image = scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                CGImageRelease(partialImageRef);</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    if (self.completedBlock) </span><br><span class="line">                    &#123;</span><br><span class="line">                        self.completedBlock(image, nil, nil, NO);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CFRelease(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.progressBlock) </span><br><span class="line">    &#123;</span><br><span class="line">        self.progressBlock(self.imageData.length, self.expectedSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SDWebImageDownloaderOperation</code>继承自<code>NSOperation</code>，没有实现<code>main</code>方法。而是采用<code>start</code>方法，方便自己管理下载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)start </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span><br><span class="line">    @synchronized (self) </span><br><span class="line">    &#123;</span><br><span class="line">        if (self.isCancelled) </span><br><span class="line">        &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line"></span><br><span class="line">        //如果设置后台执行，就后台执行</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) </span><br><span class="line">        &#123;</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                if (sself) </span><br><span class="line">                &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        self.executing = YES;</span><br><span class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">        self.thread = [NSThread currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.connection start];</span><br><span class="line"></span><br><span class="line">    if (self.connection) </span><br><span class="line">    &#123;</span><br><span class="line">        if (self.progressBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //主线程抛出下载开始通知</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //启动run loop</span><br><span class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) </span><br><span class="line">        &#123;</span><br><span class="line">            // Make sure to run the runloop in our background thread so it can process downloaded data</span><br><span class="line">            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br><span class="line">            //       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            CFRunLoopRun();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果未完成，则取消连接</span><br><span class="line">        if (!self.isFinished) </span><br><span class="line">        &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        if (self.completedBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) </span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) </span><br><span class="line">    &#123;</span><br><span class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;下载完成或者下载失败后，需要停止当前线程的<code>run loop</code>，清除连接，并且抛出下载停止的通知。如果下载成功，就会处理完整的图片数据，对图片进行缩放和解压缩操作，提供给完成回调使用。</p><h2 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h2><p>&ensp;&ensp;&ensp;&ensp;缓存的功能由<code>SDImageCache</code>完成，负责处理内存缓存和一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，不会卡死UI。<br>&ensp;&ensp;&ensp;&ensp;在iOS 中内存缓存的是使用<code>NSCache对</code>象来实现的。<code>NSCache</code>和字典类似，存储键值对。磁盘缓存的处理是使用<code>NSFileManager</code>来实现的，图片存储的位置位于<code>Cache</code>文件夹，<code>SDImageCache</code>定义了一个串行队列，来异步存储图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache ()</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSCache *memCache;</span><br><span class="line">@property (strong, nonatomic) NSString *diskCachePath;</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *customPaths;</span><br><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory </span><br><span class="line">&#123;</span><br><span class="line">    if ((self = [super init])) </span><br><span class="line">    &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line"></span><br><span class="line">        // initialise PNG signature data</span><br><span class="line">        kPNGSignatureData = [NSData dataWithBytes:kPNGSignatureBytes length:8];</span><br><span class="line"></span><br><span class="line">        // Create IO serial queue</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        // Init default values</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line"></span><br><span class="line">        // Init the memory cache</span><br><span class="line">        _memCache = [[AutoPurgeCache alloc] init];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // Init the disk cache</span><br><span class="line">        if (directory != nil) </span><br><span class="line">        &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set decompression to YES</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line"></span><br><span class="line">        // memory cache enabled</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line"></span><br><span class="line">        // Disable iCloud</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            _fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        #if TARGET_OS_IPHONE</span><br><span class="line">        // Subscribe to app events</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cleanDisk) name:UIApplicationWillTerminateNotification object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundCleanDisk) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">        </span><br><span class="line">        #endif</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>SDImageCache</code>中提供了很多方法来缓存、获取、移除图片。对于图片，方便操作我们需要一个<code>key</code>来索引它。在内存中，把它设置为<code>NSCache</code>中的<code>key</code>值，在磁盘中，把<code>key</code>作为图片的文件名。这个<code>key</code>就是图片的<code>url</code>。<br>图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，就降磁盘缓存操作作为一个<code>task</code>放到串行队列中处理，在iOS中，会先检测图片是<code>PNG</code>还是<code>JPEG</code>，<br>然后转换为相应的图片数据，最后将数据写入磁盘中，具体实现如下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk </span><br><span class="line">&#123;</span><br><span class="line">    if (!image || !key) </span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 内存缓存，存入NSCache中，同时存入图片的消耗值</span><br><span class="line">    </span><br><span class="line">    if (self.shouldCacheImagesInMemory) </span><br><span class="line">    &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toDisk) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //如果确定需要磁盘缓存，将缓存操作作为一个任务放入ioQueue中</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            NSData *data = imageData;</span><br><span class="line"></span><br><span class="line">            if (image &amp;&amp; (recalculate || !data)) </span><br><span class="line">            &#123;</span><br><span class="line">                #if TARGET_OS_IPHONE</span><br><span class="line">                // 这里需要确定是PNG还是JPEG，PNG图片容易检测，因为有一个唯一签名。PNG图片的前8个字节总是包含以下值： 137 80 78 71 13 10 26 10</span><br><span class="line">                // 在data为nil的情况下假定图片为PNG，以避免丢失透明度。而当图片有数据时，会检测前缀，确定图片的类型</span><br><span class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);</span><br><span class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone || alphaInfo == kCGImageAlphaNoneSkipFirst ||alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">                BOOL imageIsPng = hasAlpha;</span><br><span class="line"></span><br><span class="line">                // But if we have an image data, we will look at the preffix</span><br><span class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) </span><br><span class="line">                &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (imageIsPng) </span><br><span class="line">                &#123;</span><br><span class="line">                    data = UIImagePNGRepresentation(image);</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">                &#125;</span><br><span class="line">                #else</span><br><span class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line">            //创建缓存文件并且存储图片</span><br><span class="line">            if (data) </span><br><span class="line">            &#123;</span><br><span class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) </span><br><span class="line">                &#123;</span><br><span class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // get cache Path for image key</span><br><span class="line">                NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">                // transform to NSUrl</span><br><span class="line">                NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</span><br><span class="line"></span><br><span class="line">                // disable iCloud backup</span><br><span class="line">                if (self.shouldDisableiCloud) </span><br><span class="line">                &#123;</span><br><span class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询图片是通过指定的<code>key</code>来查询。下面分别为内存和磁盘查询<code>key</code>的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;</span><br><span class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p><p>如果只是想查看本地是否存在<code>key</code>指定的图片，不管是在磁盘上还是内存上，可以使用以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock </span><br><span class="line">&#123;</span><br><span class="line">    if (!doneBlock) </span><br><span class="line">    &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!key) </span><br><span class="line">    &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 首先查看内存缓存，如果找到，直接回调doneBlock返回</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) </span><br><span class="line">    &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内存中没有，去磁盘查找，如果找到，将其放到内存缓存中，回调doneBlock返回</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) </span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) </span><br><span class="line">            &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;清理缓存有两个方法。可以分为完全清空和部分清理。完全清空是直接把缓存的文件夹移除，部分清理可以设置参数来移除文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearDisk;</span><br><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;部分清理可以设置参数来移除文件，主要有两个指标：文件的缓存有效期和最大缓存空间大小，缓存的有效期通过<code>maxCacheAge</code>设置，默认<br>一周时间。如果文件的的缓存时间超过这个时间值，则将其移除。最大缓存空间通过<code>maxCacheSize</code>属性设置，如果所有缓存文件的总大小超过<br>这个大小，会按照文件最后修改的时间的逆序，每次一半的递归来移除过早的文件，一直到缓存的实际大小小于设置的最大使用空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock </span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line">        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // 枚举器先获取缓存文件的有用属性</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</span><br><span class="line">        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        // 枚举缓存文件中所有的文件夹，移除比过期日期更早的文件，还有存储文件属性方便后面执行基于缓存大小的清理操作</span><br><span class="line">        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) </span><br><span class="line">        &#123;</span><br><span class="line">            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];</span><br><span class="line"></span><br><span class="line">            // 跳过文件夹</span><br><span class="line">            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) </span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 移除早于过期日期的文件</span><br><span class="line">            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) </span><br><span class="line">            &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 计算存储文件的总大小</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) </span><br><span class="line">        &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果磁盘缓存的大小大于配置值，则执行基于文件大小的清理，首先删除最早的文件</span><br><span class="line">        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) </span><br><span class="line">        &#123;</span><br><span class="line">            // 递归设置最大缓存的一半作为清理目标</span><br><span class="line">            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">            // 按照最后修改时间来排序剩下的缓存文件</span><br><span class="line">            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) </span><br><span class="line">            &#123;</span><br><span class="line">                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            // 删除文件知道满足期望值</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) </span><br><span class="line">            &#123;</span><br><span class="line">                if ([_fileManager removeItemAtURL:fileURL error:nil]) </span><br><span class="line">                &#123;</span><br><span class="line">                    NSDictionary *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) </span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (completionBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;在实际使用中，不会直接使用<code>SDWebImageDownloader</code>和<code>SDImageCache</code>来执行图片的下载和缓存，<code>SDWebImage</code>提供了<code>SDWebImageManager</code>来管理图片的<br>下载和缓存，这个对象的<code>delegate</code>声明了两个可选的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic, readwrite) SDImageCache *imageCache;</span><br><span class="line">@property (strong, nonatomic, readwrite) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line">@protocol SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">//控制当图片在缓存中没有找到时，应该下载哪个图片</span><br><span class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">//图片下载完成时，且被缓存到内存或者磁盘前立即转换</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure></p><p>来看看这两个方法怎么调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress (SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock </span><br><span class="line">&#123;</span><br><span class="line">    // 判断url的合法性</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) </span><br><span class="line">    &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    </span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) </span><br><span class="line">    &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建SDWebImageCombinedOperation对象</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    //判断是否下载失败过</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空URL或者在不可重试情况下且是个下载失败过的URL ，直接返回操作</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) </span><br><span class="line">    &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //下载</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) </span><br><span class="line">    &#123;</span><br><span class="line">        if (operation.isCancelled) </span><br><span class="line">        &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]))</span><br><span class="line">        &#123;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) </span><br><span class="line">            &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) </span><br><span class="line">            &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) </span><br><span class="line">            &#123;</span><br><span class="line">                if (weakOperation.isCancelled) </span><br><span class="line">                &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) </span><br><span class="line">                &#123;</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        if (!weakOperation.isCancelled) </span><br><span class="line">                        &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    if (error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) </span><br><span class="line">                    &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) </span><br><span class="line">                    &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) </span><br><span class="line">                    &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            if (transformedImage &amp;&amp; finished) </span><br><span class="line">                            &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (!weakOperation.isCancelled) </span><br><span class="line">                                &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else </span><br><span class="line">                    &#123;</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) </span><br><span class="line">                        &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (!weakOperation.isCancelled) </span><br><span class="line">                            &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) </span><br><span class="line">                &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:operation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">    </span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line"></span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    [self.runningOperations removeObject:weakOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) </span><br><span class="line">        &#123;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) </span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) </span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h2><p><code>SDWebImage</code>的主要功能是图片的下载和缓存，用到了知识点非常多</p><ul><li><code>GCD</code>的<code>dispatch_barrier_sync</code>函数，这个我在<a href="https://www.jianshu.com/p/32f7d4cb051c" target="_blank" rel="noopener">GCD的使用（三）</a>中说明过。</li><li><code>NSOperationQueue</code>队列操作，<code>NSOperationQueue</code>是基于<code>GCD</code>来实现的，对<code>SDWebImage</code>中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。</li><li><code>NSURLConnection</code>网络请求。</li><li><code>NSCache</code>:类似于集合的容器，存储键值对。</li><li>清理缓存策略，设置过期日期和最大缓存空间大小。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在iOS的图片加载框架中，SDWebImage可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件。在项目中使用SDWebImage来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。本篇文章会着重讲解&lt;code&gt;SDImageCache&lt;/code&gt;、&lt;code&gt;SDWebImageDownloader&lt;/code&gt;这两个类。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtime的常见用法</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/01/08/Runtime%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/01/08/Runtime的常见用法/</id>
    <published>2018-01-08T08:46:19.000Z</published>
    <updated>2018-10-26T09:29:46.022Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;这半年，原生iOS基本上没有开发任务，都是一些无关紧要的迭代。大部分开发时间放在了前端<code>Angular</code>项目上，现在的前端水平也仅仅是，依葫芦画瓢，刚好完成开发任务而已。iOS的基础东西虽然说没有丢，但是一直没有往更深的方向去专研，<code>Swift</code>也是刚好会用，没有深究。温水煮青蛙，和刚进公司的那一会比，心态差距很大。今天把一些基础性的东西<code>Runtime</code>，重拾一下吧。</p><a id="more"></a><h2 id="Runtime-给category添加属性"><a href="#Runtime-给category添加属性" class="headerlink" title="Runtime 给category添加属性"></a>Runtime 给category添加属性</h2><p>&ensp;&ensp;<code>category</code>和继承，有相似的功能。继承既能添加方法，也能添加成员变量。继承是子类继承自父类，子类中增加的方法不会成为父类的一部分。<code>category</code>可以在不知道类源码的情况下，为类添加新方法，不能添加成员变量，但是可以用过<code>Runtime</code>来实现。以前项目中很多通用的属性都用继承实现，但是不太好维护（安慰自己罢了☺，两年了，一直都是自己一个人维护项目），改成<code>category</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString * fileName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIViewController+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">//getter</span><br><span class="line">- (void)setFileName:(NSString *)fileName</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(fileName), fileName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//setter</span><br><span class="line">- (NSString *)fileName</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _fileName = objc_getAssociatedObject(self, @selector(fileName));</span><br><span class="line">    if (!_fileName)</span><br><span class="line">    &#123;</span><br><span class="line">        _fileName = @&quot;xx.mp3&quot;;</span><br><span class="line">        objc_setAssociatedObject(self, @selector(fileName), _fileName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    return _fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime-方法交换"><a href="#Runtime-方法交换" class="headerlink" title="Runtime 方法交换"></a>Runtime 方法交换</h2><p>&ensp;&ensp;这个其实很多地方都用到了，比如用<code>NullSafe</code>来避免遇到<code>null</code>崩溃等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    //类加载时调用，确保只执行一次</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        //原始方法 这里只是举例，viewWillAppear</span><br><span class="line">        Method originalM = class_getClassMethod([self class], @selector(viewWillAppear:));</span><br><span class="line"></span><br><span class="line">        //自定义方法</span><br><span class="line">        Method customM = class_getClassMethod(self, @selector(yy_viewVillAppear:));</span><br><span class="line"></span><br><span class="line">        //交换</span><br><span class="line">        method_exchangeImplementations(originalM, customM);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)yy_viewVillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    //这里已经替换了方法viewWillAppear，所以不是递归调用</span><br><span class="line">    [self yy_viewVillAppear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Runtime-给Model赋值"><a href="#Runtime-给Model赋值" class="headerlink" title="Runtime 给Model赋值"></a>Runtime 给Model赋值</h2><h3 id="字典的Key和Model的属性名称相同"><a href="#字典的Key和Model的属性名称相同" class="headerlink" title="字典的Key和Model的属性名称相同"></a>字典的Key和Model的属性名称相同</h3><h4 id="新建基类BaseModel"><a href="#新建基类BaseModel" class="headerlink" title="新建基类BaseModel"></a>新建基类BaseModel</h4><p>&ensp;&ensp;继承NSObject，里面写一些公共方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BaseModel.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation BaseModel</span><br><span class="line"></span><br><span class="line">#pragma mark - 通过字符串创建字符串的setter方法，并返回</span><br><span class="line">- (SEL)creatSetterWithPropertyName:(NSString *)properyName</span><br><span class="line">&#123;</span><br><span class="line">    //首字母大写</span><br><span class="line">    properyName = properyName.capitalizedString;</span><br><span class="line"></span><br><span class="line">    properyName = [NSString stringWithFormat:@&quot;set%@:&quot;,properyName];</span><br><span class="line"></span><br><span class="line">    return NSSelectorFromString(properyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 把字典中的value赋值给实体类的属性</span><br><span class="line">- (void)assignToPropertyWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    if (dictionary == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray * keyArray = [dictionary allKeys];</span><br><span class="line"></span><br><span class="line">    //循环遍历字典的key,动态生成实体类的setter方法，然后把字典的value通过setter方法赋值给实体类的属性</span><br><span class="line">    for (int i = 0 ; i &lt; keyArray.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        //获取实体类的setter方法</span><br><span class="line">        SEL setSel = [self creatSetterWithPropertyName:keyArray[i]];</span><br><span class="line"></span><br><span class="line">        if ([self respondsToSelector:setSel])</span><br><span class="line">        &#123;</span><br><span class="line">            //获取字典中key对应的value</span><br><span class="line">            NSString * value = [NSString stringWithFormat:@&quot;%@&quot;,dictionary[keyArray[i]]];</span><br><span class="line"></span><br><span class="line">            //把value通过setter方法赋值给实体类的属性</span><br><span class="line">            [self performSelectorOnMainThread:setSel withObject:value waitUntilDone:[NSThread isMainThread]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;然后给实体类提供初始化方法和构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 实例方法</span><br><span class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        [self assignToPropertyWithDictionary:dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 类方法返回一个实例</span><br><span class="line">+ (instancetype)initWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    return [[self alloc] initWithDictionary:dictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实例girlModel-继承自BaseModel"><a href="#实例girlModel-继承自BaseModel" class="headerlink" title="实例girlModel,继承自BaseModel"></a>实例girlModel,继承自BaseModel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BaseModel.h&quot;</span><br><span class="line"></span><br><span class="line">@interface girlModel : BaseModel</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString * girl0;</span><br><span class="line">@property (nonatomic,copy) NSString * girl1;</span><br><span class="line">@property (nonatomic,copy) NSString * girl2;</span><br><span class="line">@property (nonatomic,copy) NSString * girl3;</span><br><span class="line">@property (nonatomic,copy) NSString * girl4;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="创建字典给model赋值"><a href="#创建字典给model赋值" class="headerlink" title="创建字典给model赋值"></a>创建字典给model赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary * dic = [[NSMutableDictionary alloc]initWithCapacity:11];</span><br><span class="line">for (int i = 0 ; i &lt; 5 ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    NSString * key = [NSString stringWithFormat:@&quot;girl%d&quot;,i];</span><br><span class="line">    NSString * value = [NSString stringWithFormat:@&quot;我是第%d个女孩&quot;,i];</span><br><span class="line">    [dic setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">girlModel * model1 = [girlModel initWithDictionary:dic];</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl0);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl1);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl2);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl3);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl4);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;或者用setValuesForKeysWithDictionary来验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">girlModel * model2 = [girlModel new];</span><br><span class="line">[model2 setValuesForKeysWithDictionary:dic];</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl0);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl1);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl2);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl3);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl4);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;上面的方法适用与字典中的key 和model属性名一一对应的情况。下面会给出如何去遍历Model中属性的值，并且给出字典的Key和Model的属性名<strong>不一样</strong>的情况我们该如何赋值。</p><h3 id="字典的Key和Model的属性名称不同"><a href="#字典的Key和Model的属性名称不同" class="headerlink" title="字典的Key和Model的属性名称不同"></a>字典的Key和Model的属性名称不同</h3><h4 id="获取Model的实体属性"><a href="#获取Model的实体属性" class="headerlink" title="获取Model的实体属性"></a>获取Model的实体属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 通过runtime来获取model中所有属性的名称</span><br><span class="line">- (NSArray *)allPropertNames</span><br><span class="line">&#123;</span><br><span class="line">    //存储所有的属性名称</span><br><span class="line">    NSMutableArray * allNames = [[NSMutableArray alloc]init];</span><br><span class="line"></span><br><span class="line">    //存储属性的个数</span><br><span class="line">    unsigned int propertyCount = 0;</span><br><span class="line"></span><br><span class="line">    //通过运行时获取当前类的属性</span><br><span class="line">    objc_property_t * propertys = class_copyPropertyList([self class], &amp;propertyCount);</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; propertyCount ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        objc_property_t property = propertys[i];</span><br><span class="line">        const char * propertName = property_getName(property);</span><br><span class="line">        [allNames addObject:[NSString stringWithUTF8String:propertName]];</span><br><span class="line">    &#125;</span><br><span class="line">    //释放</span><br><span class="line">    free(propertys);</span><br><span class="line"></span><br><span class="line">    return allNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 通过字符串来创建改字符串的setter方法，并返回</span><br><span class="line">- (SEL)creatGetterWithPropertyName:(NSString *)propertyName</span><br><span class="line">&#123;</span><br><span class="line">    //OC中getter方法就是属性本身</span><br><span class="line">    return NSSelectorFromString(propertyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Model的属性动态的执行getter方法"><a href="#Model的属性动态的执行getter方法" class="headerlink" title="Model的属性动态的执行getter方法"></a>Model的属性动态的执行getter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayCurrentModelPropert</span><br><span class="line">&#123;</span><br><span class="line">    //获取实体类的属性名</span><br><span class="line">    NSArray * array = [self allPropertNames];</span><br><span class="line"></span><br><span class="line">    NSMutableString * resultString = [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        SEL getSel = [self creatGetterWithPropertyName:array[i]];</span><br><span class="line"></span><br><span class="line">        if ([self respondsToSelector:getSel])</span><br><span class="line">        &#123;</span><br><span class="line">            //获得类和方法的签名</span><br><span class="line">            NSMethodSignature * signature = [self methodSignatureForSelector:getSel];</span><br><span class="line"></span><br><span class="line">            //从签名获取调用对象</span><br><span class="line">            NSInvocation * invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line"></span><br><span class="line">            //设置target 和 selector</span><br><span class="line">            [invocation setTarget:self];</span><br><span class="line"></span><br><span class="line">            [invocation setSelector:getSel];</span><br><span class="line"></span><br><span class="line">            NSObject * __unsafe_unretained returnValue = nil;</span><br><span class="line"></span><br><span class="line">            [invocation invoke];</span><br><span class="line"></span><br><span class="line">            [invocation getReturnValue:&amp;returnValue];</span><br><span class="line"></span><br><span class="line">            [resultString appendFormat:@&quot;%@\n&quot;,returnValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,resultString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;下面来验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[model1 displayCurrentModelPropert];</span><br></pre></td></tr></table></figure></p><p>输出结果<br><img src="http://upload-images.jianshu.io/upload_images/1487718-bb56ac83763e1a5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-17 下午8.56.45.png"></p><p>&ensp;&ensp;<strong>当字典的key和model中属性不一样，我们就需要用一个映射来维护。基类中添加一个返回映射字典的一个方法，然后在子类中进行重写，这个映射方法在基类中返回nil, 如果子类需要重写的话就对这个方法进行重写并返回映射字典</strong>。</p><h4 id="构建映射关系"><a href="#构建映射关系" class="headerlink" title="构建映射关系"></a>构建映射关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 构建映射关系</span><br><span class="line">- (NSDictionary *)propertMap</span><br><span class="line">&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;修改一下初始化方法，在有映射字典的情况和没有映射字典的情况下调用的方法是不一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 实例方法</span><br><span class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([self propertMap] == nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self assignToPropertyWithDictionary:dictionary];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self assignToPropertyWithNoMapDictionary:dictionary];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)assignToPropertyWithNoMapDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    //获取字典和model属性的映射关系</span><br><span class="line">    NSDictionary * propertyMapDictionary = [self propertMap];</span><br><span class="line"></span><br><span class="line">    NSArray * dicKeyArray = [dictionary allKeys];</span><br><span class="line"></span><br><span class="line">    NSMutableDictionary * tempDic = [[NSMutableDictionary alloc]initWithCapacity:dicKeyArray.count];</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; dicKeyArray.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSString * key = dicKeyArray[i];</span><br><span class="line">        [tempDic setObject:dictionary[key] forKey:propertyMapDictionary[key]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self assignToPropertyWithDictionary:tempDic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;下面新建一个boyMdoel继承BaseModel，并且重写映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy) NSString * boy0;</span><br><span class="line">@property (nonatomic,copy) NSString * boy1;</span><br><span class="line">@property (nonatomic,copy) NSString * boy2;</span><br><span class="line">@property (nonatomic,copy) NSString * boy3;</span><br><span class="line">@property (nonatomic,copy) NSString * boy4;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)propertMap</span><br><span class="line">&#123;</span><br><span class="line">    return @&#123;@&quot;key0&quot;:@&quot;boy0&quot;,</span><br><span class="line">             @&quot;key1&quot;:@&quot;boy1&quot;,</span><br><span class="line">             @&quot;key2&quot;:@&quot;boy2&quot;,</span><br><span class="line">             @&quot;key3&quot;:@&quot;boy3&quot;,</span><br><span class="line">             @&quot;key4&quot;:@&quot;boy4&quot;,&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;然后生成数据验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary * dic1 = [[NSMutableDictionary alloc]initWithCapacity:5];</span><br><span class="line">for (int i = 0 ; i &lt; 5 ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    NSString * key = [NSString stringWithFormat:@&quot;key%d&quot;,i];</span><br><span class="line">    NSString * value = [NSString stringWithFormat:@&quot;我是第%d个男孩&quot;,i];</span><br><span class="line">    [dic1 setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line">boyModel * model3 = [boyModel initWithDictionary:dic1];</span><br><span class="line">[model3 displayCurrentModelPropert];</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1487718-4c39b491400e4cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-17 下午9.21.47.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;这半年，原生iOS基本上没有开发任务，都是一些无关紧要的迭代。大部分开发时间放在了前端&lt;code&gt;Angular&lt;/code&gt;项目上，现在的前端水平也仅仅是，依葫芦画瓢，刚好完成开发任务而已。iOS的基础东西虽然说没有丢，但是一直没有往更深的方向去专研，&lt;code&gt;Swift&lt;/code&gt;也是刚好会用，没有深究。温水煮青蛙，和刚进公司的那一会比，心态差距很大。今天把一些基础性的东西&lt;code&gt;Runtime&lt;/code&gt;，重拾一下吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
