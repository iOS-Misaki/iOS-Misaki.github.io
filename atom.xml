<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki的小站</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/iOS-Misaki.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/"/>
  <updated>2018-10-30T07:58:06.354Z</updated>
  <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Runtime消息转发及其应用</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/10/30/Runtime%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/10/30/Runtime消息转发及其应用/</id>
    <published>2018-10-30T11:39:40.000Z</published>
    <updated>2018-10-30T07:58:06.354Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;之前写过文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/01/08/Runtime%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">Runtime的常见用法</a>里面有介绍过利用<code>Objective-C</code>的<code>Runtime</code>特性来给<code>Category</code>生成属性、实现方法交换和给<code>Model</code>赋值。今天整理一下<code>Objective-C</code>消息传递和消息转发机制以及来防止应用闪退的问题。</p><a id="more"></a><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>&ensp;&ensp;打开#import&lt;objc/runtime.h&gt;文件，看到<code>struct objc_class</code>的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;<strong>结构体中有很多变量，分别是父类的指针、类的名字、类的版本、实例大小、变量列表、方法列表、方法缓存、协议列表。一个类对象就是一个结构体<code>struct objc_class</code>  ，这个结构体存放的数据称为<code>metadata(元数据)</code>，结构体的第一个成员变量是一个isa指针，isa指针指向<code>metaclass（元类）</code>。</strong></p><p>&ensp;&ensp;在看看<code>Method</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method(objc_method)</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    char * _Nullable method_types                            OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP _Nonnull method_imp                                  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;这个就是平常使用的函数，能够独立完成一个功能的一段代码</p><ul><li><code>SEL method_name</code> 方法名</li><li><code>char* method_types</code>方法类型</li><li><code>IMP method_imp</code> 方法实现的指针</li><li><code>SEL</code>和<code>IMP</code>都是Method的属性</li></ul><p>&ensp;&ensp;一般OC中函数调用例如 <code>[obj dosomthing]</code>都会被编译器转义成<code>objc_msgsend(obj,dosomething)</code>,<code>obj</code>就是对象实例，<code>dosomething</code>是<code>SEL</code>类型。<code>Runtime</code>的执行的流程是</p><ul><li>1.通过<code>obj</code>的<code>isa</code>指针找到他的<code>class</code>，然后在<code>class</code>中的<code>objc_cache</code>中查找方法</li><li>2.假如没有找到，就去<code>objc_method_list</code>中查找对应的方法</li><li>3.如果在<code>class</code>中种没有找到相关的方法，则会继续向上查找，在<code>父类（super_class）</code>重复步骤1、2。</li><li>4.假如一直没有找到这个方法，通常会<code>crash</code>并抛出异常，在抛出异常前会执行消息转发。</li></ul><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>&ensp;&ensp;发生消息转发，还有三次机会，假如都失败了就会执行<code>doesNotRecognizeSelector：</code>报错<code>unrecognized selector</code>。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-574c486162950666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS 消息转发流程图.png"></p><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(testMethod:) withObject:@&quot;something&quot;];</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;我在<code>ViewController</code>里面调用<code>testMethod</code>方法，但是没有在<code>ViewController</code>申明这个方法，运行起来肯定是崩溃的。<br>在运行时，如果找不到要执行的方法，会首先执行<code>resolveClassMethod:</code>或者<code>resolveInstanceMethod：</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 添加的IMP</span><br><span class="line">void myMethod(id self, SEL cmd, id value)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 找不到对象方法时候调用</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(testMethod:))</span><br><span class="line">    &#123;</span><br><span class="line">        class_addMethod([self class],sel,(IMP)myMethod,&quot;v@:@&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return [super resolveInstanceMethod:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 找不到类方法时调用</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;当<code>ViewController</code>对象找不到<code>testMethod</code>方法，首先调用<code>resolveInstanceMethod</code>进行拦截补救。判断<code>ViewController</code>找不到的方法是否为<code>testMethod</code><br>如果是<code>testMethod</code>，调用<code>class_addMethod</code>为<code>ViewController</code>动态的添加<code>testMethod</code>方法。<br><code>class_addMethod</code>的四个参数分别是</p><ul><li>动态添加方法的类</li><li>动态添加的方法</li><li>方法实现</li><li>参数类型<br>&ensp;&ensp;这里假如说想在<code>resolveClassMethod</code>动态的添加类方法，<code>class_addMethod</code>的第一参数替换成<code>[self superClass]</code>即可。</li></ul><h3 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h3><p>&ensp;&ensp;假如没有在<code>resolveInstanceMethod</code>里面动态添加方法，还是会崩溃，这个时候需要另外一个对象来接收这个消息。新建一个<code>BackupViewController</code>类，然后让<code>BackupViewController</code>去执行<code>testMethod</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation BackupViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testMethod:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 找不到对象方法时候调用</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 找不到类方法时调用</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [super resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 寻找备用接收者</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    BackupViewController * backup = [[BackupViewController alloc] init];</span><br><span class="line">    if ([backup respondsToSelector:@selector(testMethod:)])</span><br><span class="line">    &#123;</span><br><span class="line">        return backup;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;这个很好理解，既然自己不能动态添加方法，那就让其他的对象来接收这个消息，但是需要注意的是，这个备用者不能是<code>self</code>本身，否则会陷入循环中。</p><h3 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h3><p>&ensp;&ensp;假如不动态添加方法，也不转发给备用接收者，这个时候就需要完整消息转发<code>NSInvocation</code>来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - ViewController找不到方法的实现签名，需要给aSelector新建方法签名，在交给Backup处理</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature * signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature)</span><br><span class="line">    &#123;</span><br><span class="line">        signature = [BackupViewController instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 方法签名后进入forwardInvocation方法</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = anInvocation.selector;</span><br><span class="line">    BackupViewController * backup = [[BackupViewController alloc] init];</span><br><span class="line">    if ([backup respondsToSelector:sel])</span><br><span class="line">    &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:backup];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        [self doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;首先创建<code>NSInvocation</code>对象，把尚未处理的那条消息有关的全部细节封装于这个<code>NSInvocation</code>对象中。此对象中包含选择子（<code>selector</code>）、目标（<code>target</code>）及参数。在触发<code>NSInvocation</code>对象时，会调用<code>forwardInvocation</code>来转发消息，如果发现调用操作不由本类来处理，则需要沿着继承体系，调用父类的同名方法，一直到<code>NSObject</code>类，调用<code>doesNotRecognizeSelector</code>来抛出异常，消息转发结束。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&ensp;&ensp;在这里消息转发三个步骤中，第一步<code>resolveInstanceMethod</code>可以解决问题，但是需要在当前对象添加不存在的方法。第三步，会导致消息流转的周期变长，还会产生<code>NSInvocation</code>，增加额外的开销。所以在应用中，在第二步处理消息防止应用闪退。<br>&ensp;&ensp;<strong>可以动态的创建一个类，动态的给该类添加对应的<code>Selector</code>,通过一个通用的返回0的函数来实现改<code>SEL</code>的<code>IMP</code>。然后将消息转发到这个类上。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ForwardingTarget.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation ForwardingTarget</span><br><span class="line"></span><br><span class="line">id ForwardingTarget_dynamicMethod(id self, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    return [NSNull null];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    class_addMethod([self class], sel, (IMP)ForwardingTarget_dynamicMethod, &quot;@@:&quot;);</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    id result = [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    id result = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    [super doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;NSObject+DoesNotRecognizeSelectorExtension.h&quot;</span><br><span class="line"></span><br><span class="line">#import &quot;ForwardingTarget.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static ForwardingTarget * _target = nil;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (DoesNotRecognizeSelectorExtension)</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _target = [ForwardingTarget new];;</span><br><span class="line">        not_recognize_selector_classMethodSwizzle([self class], @selector(forwardingTargetForSelector:), @selector(doesnot_recognize_selector_swizzleForwardingTargetForSelector:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (id)doesnot_recognize_selector_swizzleForwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    id result = [self doesnot_recognize_selector_swizzleForwardingTargetForSelector:aSelector];</span><br><span class="line">    if (result)</span><br><span class="line">    &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - private method</span><br><span class="line"></span><br><span class="line">BOOL not_recognize_selector_classMethodSwizzle(Class aClass, SEL originalSelector, SEL swizzleSelector)</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class="line">    Method swizzleMethod = class_getInstanceMethod(aClass, swizzleSelector);</span><br><span class="line">    BOOL didAddMethod = class_addMethod(aClass,originalSelector,method_getImplementation(swizzleMethod),method_getTypeEncoding(swizzleMethod));</span><br><span class="line">    if (didAddMethod)</span><br><span class="line">    &#123;</span><br><span class="line">        class_replaceMethod(aClass,swizzleSelector,method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>参考<br><a href="https://yq.aliyun.com/articles/348673" target="_blank" rel="noopener">iOS unrecognized selector crash 自修复技术实现与原理解析</a><br><a href="https://neyoufan.github.io/2017/01/13/ios/BayMax_HTSafetyGuard/" target="_blank" rel="noopener">大白健康系统–iOS APP运行时Crash自动修复系统</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;之前写过文章&lt;a href=&quot;https://ios-misaki.github.io/iOS-Misaki.github.io/2018/01/08/Runtime%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Runtime的常见用法&lt;/a&gt;里面有介绍过利用&lt;code&gt;Objective-C&lt;/code&gt;的&lt;code&gt;Runtime&lt;/code&gt;特性来给&lt;code&gt;Category&lt;/code&gt;生成属性、实现方法交换和给&lt;code&gt;Model&lt;/code&gt;赋值。今天整理一下&lt;code&gt;Objective-C&lt;/code&gt;消息传递和消息转发机制以及来防止应用闪退的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TransitionAnimation 自定义转场动画</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/08/04/TransitionAnimation-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/08/04/TransitionAnimation-自定义转场动画/</id>
    <published>2018-08-04T12:40:27.000Z</published>
    <updated>2018-08-04T14:53:14.814Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在<code>iOS 7</code>之后，苹果就开放了自定义转场的相关<code>api</code>，现在都快<code>iOS 12</code>了，一直都没有好好研究转场动画，一个是之前没有重视，觉得花里胡哨的，另外一个是所做的项目中没有这样的转场动画需求。这里说的转场动画和上一篇<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/" target="_blank" rel="noopener">CAAnimation 系统动画</a>中<code>CATransition</code>动画不是一个概念，上一篇指的是单个View的转场特效，这里指的是整个控制器的转场特效。其实写上篇文章的目前也是为今天打下铺垫，复杂的转场效果也是由单个动画来组成的。</p><a id="more"></a><p><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E7%B1%BB%E5%9B%BE.png" alt="自定义转场动画类图"></p><p>&ensp;&ensp;&ensp;&ensp;由图中可以看出要完成自定义转场动画，必须遵从<code>UIViewControllerAnimatedTransitioning</code>协议，协议中有两个必须实现的方法一个是返回转场时间，一个是具体转场的实现。文章会结合5个最常用的动画场景来说明转场动画。</p><p>&ensp;&ensp;&ensp;&ensp;先来看看网易严选App的转场效果，可以看出当前页面想要<code>Push</code>其他的页面的时候，当前页面会下沉同时其他页面从右边平移至左边。<code>Present</code>页面的时候，当前页面也会下沉，目标视图从底部弹出。<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89Push%E5%92%8CPop%E5%8A%A8%E7%94%BB.gif" alt="网易严选Push和Pop动画.gif"></p><p><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89Present%E5%92%8CDismiss%E5%8A%A8%E7%94%BB.gif" alt="网易严选Present和Dismiss动画.gif"></p><p>&ensp;&ensp;&ensp;&ensp;来看代码，在<code>ViewController</code>里面有两个按钮，分别是<code>Push</code>出<code>SecondVC</code>和<code>Present</code>出<code>ThirdVC</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)pushBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    SecondViewController * vc = [[SecondViewController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)presentBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    ThirdViewController * vc = [[ThirdViewController alloc] init];</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Push和Pop动画"><a href="#Push和Pop动画" class="headerlink" title="Push和Pop动画"></a>Push和Pop动画</h2><h3 id="UIViewControllerAnimatedTransitioning协议"><a href="#UIViewControllerAnimatedTransitioning协议" class="headerlink" title="UIViewControllerAnimatedTransitioning协议"></a>UIViewControllerAnimatedTransitioning协议</h3><p>&ensp;&ensp;&ensp;&ensp;这里新建一个<code>AnimatedTransitioningObject</code>类，然后要遵循<code>UIViewControllerAnimatedTransitioning</code>协议。这个为了方便，把<code>Push、Pop、Present、Dismiss</code>这四个效果写在一起，用枚举来区分，当然也可以把每种动画效果单独用一个<code>AnimatedTransitioningObject</code>类来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger,TransitionAnimationObjectType) &#123;</span><br><span class="line">    TransitionAnimationObjectType_Push,</span><br><span class="line">    TransitionAnimationObjectType_Pop,</span><br><span class="line">    TransitionAnimationObjectType_present,</span><br><span class="line">    TransitionAnimationObjectType_Dismiss</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@interface TransitionAnimationObject : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,assign) TransitionAnimationObjectType type;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithTransitionAnimationObjectType:(TransitionAnimationObjectType)type;</span><br><span class="line"></span><br><span class="line">+ (instancetype)initWithTransitionAnimationObjectType:(TransitionAnimationObjectType)type;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;来看看两个必须实现的方法，在返回转场时间里也可以根据<code>type</code>来返回不同的动画时间，这里统一返回0.5秒。<code>pushAnimateTransition</code>里面实现<code>Push</code>效果转场。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    return 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    switch (_type) &#123;</span><br><span class="line">        case TransitionAnimationObjectType_Push:</span><br><span class="line">            [self pushAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransitionAnimationObjectType_Pop:</span><br><span class="line">            [self popAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransitionAnimationObjectType_present:</span><br><span class="line">            [self presentAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransitionAnimationObjectType_Dismiss:</span><br><span class="line">            [self dismissAnimateTransition:transitionContext];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Push实现"><a href="#Push实现" class="headerlink" title="Push实现"></a>Push实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (void)pushAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //获取目标View(secondVC.view) 和 来源View(ViewController.view)</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //这里截图做动画 隐藏来源View</span><br><span class="line">    UIView * tempView = [fromView snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    fromView.hidden = YES;</span><br><span class="line"></span><br><span class="line">    //将需要做转场的View按照顺序添加到转场容器中</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line"></span><br><span class="line">    CGFloat width = containerView.frame.size.width;</span><br><span class="line">    CGFloat height = containerView.frame.size.height;</span><br><span class="line"></span><br><span class="line">    //设置目标View的初始位置</span><br><span class="line">    toView.frame = CGRectMake(width, 0, width, height);</span><br><span class="line"></span><br><span class="line">    //开始做动画</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line">    [UIView animateWithDuration:duration animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformMakeScale(0.9, 0.9);</span><br><span class="line">        toView.transform = CGAffineTransformMakeTranslation(-width, 0);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //这里要标记转场成功 假如不标记 系统会认为还在转场中 无法交互</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line"></span><br><span class="line">        //转场失败 也要做相应的处理</span><br><span class="line">        if ([transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            fromView.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pop实现"><a href="#Pop实现" class="headerlink" title="Pop实现"></a>Pop实现</h3><p>&ensp;&ensp;&ensp;&ensp; <code>Push</code>和<code>Pop</code>是相对的关系，所以在<code>Pop</code>动画中，目标视图和来源视图互换身份，实现也是用<code>CGAffineTransformIdentity</code>来还原<code>Push</code>动画即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)popAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //注意这里是还原 所以toView和fromView 身份互换了 toView是ViewController.view</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //获取相应的视图</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    UIView * tempView = [[containerView subviews] firstObject];</span><br><span class="line"></span><br><span class="line">    //在fromView 下面插入toView 不然回来的时候回黑屏</span><br><span class="line">    [containerView insertSubview:toView belowSubview:fromView];</span><br><span class="line"></span><br><span class="line">    //将动画直接还原即可</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line">    [UIView animateWithDuration:duration animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformIdentity;</span><br><span class="line">        fromView.transform = CGAffineTransformIdentity;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //标记转场</span><br><span class="line">        [transitionContext completeTransition:!transitionContext.transitionWasCancelled];</span><br><span class="line"></span><br><span class="line">        //转场成功的处理</span><br><span class="line">        if (![transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">            toView.hidden = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="UINavigationControllerDelegate代理方法"><a href="#UINavigationControllerDelegate代理方法" class="headerlink" title="UINavigationControllerDelegate代理方法"></a>UINavigationControllerDelegate代理方法</h3><p>&ensp;&ensp;&ensp;&ensp;完成<code>AnimatedTransitioningObject</code>类后，再返回<code>ViewController</code>中，<code>ViewController</code>要遵循<code>UINavigationBarDelegate</code>和<code>UIViewControllerTransitioningDelegate</code>，把<code>SecondVC</code>的<code>transitioningDelegate</code>设置为自己。然后根据不同的<code>operation</code>，来返回不同的动画实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController () &lt;UINavigationControllerDelegate,UIViewControllerTransitioningDelegate&gt;</span><br><span class="line"></span><br><span class="line">- (IBAction)pushBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    SecondViewController * vc = [[SecondViewController alloc] init];</span><br><span class="line">    vc.transitioningDelegate = self;</span><br><span class="line">    [self.navigationController pushViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Push &amp;&amp; Pop</span><br><span class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</span><br><span class="line">animationControllerForOperation:(UINavigationControllerOperation)operation</span><br><span class="line">fromViewController:(UIViewController *)fromVC</span><br><span class="line">toViewController:(UIViewController *)toVC</span><br><span class="line">&#123;</span><br><span class="line">    if (operation == UINavigationControllerOperationPush)</span><br><span class="line">    &#123;</span><br><span class="line">        return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_Push];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (operation == UINavigationControllerOperationPop)</span><br><span class="line">    &#123;</span><br><span class="line">        return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_Pop];</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;看看实现效果<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/Push%E5%92%8CPop%E6%95%88%E6%9E%9C.gif" alt="Push和Pop效果.gif"></p><h2 id="Present动画和Dismiss动画"><a href="#Present动画和Dismiss动画" class="headerlink" title="Present动画和Dismiss动画"></a>Present动画和Dismiss动画</h2><h3 id="Present实现"><a href="#Present实现" class="headerlink" title="Present实现"></a>Present实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //获取目标View(ThirdVC.view) 和 来源View(ViewController.view)</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //截图做动画</span><br><span class="line">    UIView * tempView = [fromView snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    tempView.frame = fromView.frame;</span><br><span class="line">    fromView.hidden = YES;</span><br><span class="line"></span><br><span class="line">    //按照顺序假如转场动画容器中</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toView];</span><br><span class="line"></span><br><span class="line">    CGFloat width = containerView.frame.size.width;</span><br><span class="line">    CGFloat height = containerView.frame.size.height;</span><br><span class="line"></span><br><span class="line">    //设置toView的初始化位置 在屏幕底部</span><br><span class="line">    toView.frame = CGRectMake(0, height, width, 400);</span><br><span class="line"></span><br><span class="line">    //做转场动画</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line">    [UIView animateWithDuration:duration delay:0 usingSpringWithDamping:0.55 initialSpringVelocity:1 options:0 animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformMakeScale(0.9, 0.9);</span><br><span class="line">        toView.transform = CGAffineTransformMakeTranslation(0, -400);</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //转场结束后一定要标记 否则会认为还在转场 无法交互</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">        if ([transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            //转场失败</span><br><span class="line">            fromView.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dismiss实现"><a href="#Dismiss实现" class="headerlink" title="Dismiss实现"></a>Dismiss实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)dismissAnimateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    //dismiss的时候 fromVC和toVC身份倒过来了</span><br><span class="line">    UIView * toView = [transitionContext viewForKey:UITransitionContextToViewKey];</span><br><span class="line">    UIView * fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</span><br><span class="line"></span><br><span class="line">    //containerView里面的顺序也倒过来了 截图在最上面</span><br><span class="line">    UIView * containerView = [transitionContext containerView];</span><br><span class="line">    UIView * tempView = [[containerView subviews] firstObject];</span><br><span class="line"></span><br><span class="line">    //做还原动画就可以了</span><br><span class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</span><br><span class="line"></span><br><span class="line">    [UIView animateWithDuration:duration delay:0 usingSpringWithDamping:0.55 initialSpringVelocity:1 options:0 animations:^&#123;</span><br><span class="line">        tempView.transform = CGAffineTransformIdentity;</span><br><span class="line">        fromView.transform = CGAffineTransformIdentity;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //转场结束后一定要标记 否则会认为还在转场 无法交互</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">        if (![transitionContext transitionWasCancelled])</span><br><span class="line">        &#123;</span><br><span class="line">            //转场成功</span><br><span class="line">            toView.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UIViewControllerTransitioningDelegate代理方法"><a href="#UIViewControllerTransitioningDelegate代理方法" class="headerlink" title="UIViewControllerTransitioningDelegate代理方法"></a>UIViewControllerTransitioningDelegate代理方法</h3><p>&ensp;&ensp;&ensp;&ensp;回到<code>ViewController</code>，把<code>ThirdVC</code>的<code>transitioningDelegate</code>设置为自己,然后在代理方法中自定类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)presentBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    ThirdViewController * vc = [[ThirdViewController alloc] init];</span><br><span class="line">    vc.transitioningDelegate = self;</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Present &amp;&amp; Dismiss</span><br><span class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</span><br><span class="line">&#123;</span><br><span class="line">    return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_present];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed</span><br><span class="line">&#123;</span><br><span class="line">    return [TransitionAnimationObject initWithTransitionAnimationObjectType:TransitionAnimationObjectType_Dismiss];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="手势动画"><a href="#手势动画" class="headerlink" title="手势动画"></a>手势动画</h2><h3 id="UIPercentDrivenInteractiveTransition创建手势类"><a href="#UIPercentDrivenInteractiveTransition创建手势类" class="headerlink" title="UIPercentDrivenInteractiveTransition创建手势类"></a>UIPercentDrivenInteractiveTransition创建手势类</h3><p>&ensp;&ensp;&ensp;&ensp;新建一个手势类<code>GestureObject</code>继承自<code>UIPercentDrivenInteractiveTransition</code>，<code>addGestureToViewController</code>是给目标控制器添加手势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface GestureObject : UIPercentDrivenInteractiveTransition</span><br><span class="line"></span><br><span class="line">//判断是交互的手势</span><br><span class="line">@property (nonatomic,assign) BOOL interacting;</span><br><span class="line"></span><br><span class="line">- (void)addGestureToViewController:(UIViewController *)viewController;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后再手势的状态之间来判断是否执行动画，这里是判断手势偏移量超过屏幕一半的高度就生效，执行相关动画，否则还原动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleGesture:(UIPanGestureRecognizer *)ges</span><br><span class="line">&#123;</span><br><span class="line">    CGPoint point = [ges translationInView:ges.view];</span><br><span class="line"></span><br><span class="line">    switch (ges.state) &#123;</span><br><span class="line">        case UIGestureRecognizerStateBegan:</span><br><span class="line">        &#123;</span><br><span class="line">            self.interacting = YES;</span><br><span class="line">            [self.targetVC dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case UIGestureRecognizerStateChanged:</span><br><span class="line">        &#123;</span><br><span class="line">            CGFloat fraction = point.y / ges.view.frame.size.height;</span><br><span class="line">            //限制在0和1之间</span><br><span class="line">            fraction = MAX(0.0, MIN(fraction, 1.0));</span><br><span class="line">            self.shouldComplete = fraction &gt; 0.5;</span><br><span class="line">            [self updateInteractiveTransition:fraction];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        case UIGestureRecognizerStateEnded:</span><br><span class="line">        case UIGestureRecognizerStateCancelled:</span><br><span class="line">        &#123;</span><br><span class="line">            self.interacting = NO;</span><br><span class="line">            if (!self.shouldComplete || ges.state == UIGestureRecognizerStateCancelled)</span><br><span class="line">            &#123;</span><br><span class="line">                //还原动画</span><br><span class="line">                [self cancelInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //完成动画</span><br><span class="line">                [self finishInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="UIViewControllerTransitioningDelegate代理方法-1"><a href="#UIViewControllerTransitioningDelegate代理方法-1" class="headerlink" title="UIViewControllerTransitioningDelegate代理方法"></a>UIViewControllerTransitioningDelegate代理方法</h3><p>&ensp;&ensp;&ensp;&ensp;回到<code>ViewController</code>中，在<code>Present</code>出<code>ThirdVC</code>的时候添加手势，在代理方法<code>interactionControllerForDismissal</code>中指定手势。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)presentBtnClick:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    ThirdViewController * vc = [[ThirdViewController alloc] init];</span><br><span class="line">    vc.transitioningDelegate = self;</span><br><span class="line">    [self.gestureObject addGestureToViewController:vc];</span><br><span class="line">    [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animator</span><br><span class="line">&#123;</span><br><span class="line">    return self.gestureObject.interacting ? self.gestureObject : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看效果<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/Present%E5%92%8CDismiss%E6%95%88%E6%9E%9C.gif" alt="Present和Dismiss效果.gif"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&ensp;&ensp;&ensp;&ensp; <code>Push</code>、<code>Pop</code>、<code>Present</code>、<code>Dismiss</code>、手势动画都讲解完了，可以看出，自定义转场大致的步骤是</p><ul><li><strong>根据<code>viewForKey</code>来获取转场上下文</strong></li><li><strong>将要转场的视图加入转场容器中</strong></li><li><strong>做出转场动画</strong></li><li><strong>标记转场成功的状态，根据状态做相应的处理</strong></li></ul><p>&ensp;&ensp;&ensp;&ensp;理解了这些，再复杂的转场动画都能一步步分解出来，下面是格瓦拉App的转场效果，第一次看的时候，觉得很酷炫，现在了解了转场的核心后，觉得不那么难了，有时间再把它的效果写出来吧。<br><img src="https://yuyiios-work.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2/TransitionAnimation%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/%E6%A0%BC%E7%93%A6%E6%8B%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB.gif" alt="格瓦拉转场动画.gif"></p><p><a href="https://github.com/iOS-Misaki/TransitionAnimation"><strong>源码：TransitionAnimation</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在&lt;code&gt;iOS 7&lt;/code&gt;之后，苹果就开放了自定义转场的相关&lt;code&gt;api&lt;/code&gt;，现在都快&lt;code&gt;iOS 12&lt;/code&gt;了，一直都没有好好研究转场动画，一个是之前没有重视，觉得花里胡哨的，另外一个是所做的项目中没有这样的转场动画需求。这里说的转场动画和上一篇&lt;a href=&quot;https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CAAnimation 系统动画&lt;/a&gt;中&lt;code&gt;CATransition&lt;/code&gt;动画不是一个概念，上一篇指的是单个View的转场特效，这里指的是整个控制器的转场特效。其实写上篇文章的目前也是为今天打下铺垫，复杂的转场效果也是由单个动画来组成的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CAAnimation 系列动画</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/26/CAAnimation 系列动画/</id>
    <published>2018-07-26T02:20:39.000Z</published>
    <updated>2018-07-26T14:58:08.355Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;有人问我为什么要写博客，必须要承认，现在网上一大推的优秀教程和现成的Demo，自己写的没有别人好，有些地方根本不够深入，但是看别人写文章、写代码和自己写完全是两件事，代码看看就能懂，但是自己过一遍，印象更深，消化的也就更彻底。对于iOS动画 ，一直都没有系统化的学习，只有用的时候才会查查api，之前写过一篇<a href="https://www.jianshu.com/p/92ac22afeeef" target="_blank" rel="noopener">红包雨</a>的文章，用的是关键帧动画，没有在继续下去。另一个就是在6月份面试的时候，有两个面试官都问到了基础动画，当时也回答的不好，现在详细地梳理一遍。现阶段，先把<code>Core Animation</code>弄清楚，以后再下沉到<code>OpenGL</code>和<code>CoreGraphics</code>。</p><a id="more"></a><h2 id="CAAnimation继承关系"><a href="#CAAnimation继承关系" class="headerlink" title="CAAnimation继承关系"></a>CAAnimation继承关系</h2><p>&ensp;&ensp;&ensp;&ensp;引用官方文档：</p><blockquote><p>Core Animation provides high frame rates and smooth animations without burdening the CPU and slowing down your app. Most of the work required to draw each frame of an animation is done for you. You configure animation parameters such as the start and end points, and Core Animation does the rest, handing off most of the work to dedicated graphics hardware, to accelerate rendering. For more details, see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="noopener">Core Animation Programming Guide</a>.</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;<code>Core Animation</code>提供了高帧率和流畅的动画，而不会加重CPU负担，也不会减慢应用程序的速度。你可以配置动画参数，如起始点和结束点，<code>Core animation</code>完成其余部分，将大部分工作交给专用的图形硬件，以加速渲染。</p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-98d399ad7b624a91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAAnimation类图.jpg"></p><p>&ensp;&ensp;&ensp;&ensp;对于<code>CAAnimation</code>,是核心动画基础类，不直接使用，一般用它的子类。<code>CAAnimation</code>有三个子类<code>CAPropertyAnimation、CATransition、CAAnimationGroup</code>。第二个<code>CATransition</code>是转场动画，第三个<code>CAAnimationGroup</code>是动画组。第一个<code>CAPropertyAnimation</code>又分为两个子类<code>CABasicAnimation、CAKeyframeAnimation</code>。<code>CAKeyframeAnimation</code>是关键帧动画。<code>CABasicAnimation</code>下面还有个子类<code>CASpringAnimation</code>是弹簧动画。</p><p>&ensp;&ensp;&ensp;&ensp;<code>CAPropertyAnimation</code>通过<code>animationWithKeyPath</code>来创建动画，可以看看有哪些属性可以创建动画。详见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW2" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">anchorPoint</span><br><span class="line">backgroundColor</span><br><span class="line">backgroundFilters</span><br><span class="line">borderColor</span><br><span class="line">borderWidth</span><br><span class="line">bounds</span><br><span class="line">compositingFilter</span><br><span class="line">contents</span><br><span class="line">contentsRect</span><br><span class="line">cornerRadius</span><br><span class="line">doubleSided</span><br><span class="line">filters</span><br><span class="line">frame</span><br><span class="line">hidden</span><br><span class="line">mask</span><br><span class="line">masksToBounds</span><br><span class="line">opacity</span><br><span class="line">position</span><br><span class="line">shadowColor</span><br><span class="line">shadowOffset</span><br><span class="line">shadowOpacity</span><br><span class="line">shadowPath</span><br><span class="line">shadowRadius</span><br><span class="line">sublayers</span><br><span class="line">sublayerTransform</span><br><span class="line">transform</span><br><span class="line">zPosition</span><br></pre></td></tr></table></figure><hr><h2 id="CAKeyframeAnimation-关键帧动画"><a href="#CAKeyframeAnimation-关键帧动画" class="headerlink" title="CAKeyframeAnimation 关键帧动画"></a>CAKeyframeAnimation 关键帧动画</h2><p>&ensp;&ensp;&ensp;&ensp;可以使用继承的<code>animationWithKeyPath:</code>方法创建一个<code>CAKeyframeAnimation</code>对象，并指定要在层上动画的属性的关键路径。然后可以指定用于控制时间和动画行为的关键帧值。对于大多数动画类型，可以使用值和<code>keyTimes</code>属性指定关键帧值。在动画期间，<code>Core animation</code>通过在您提供的值之间插入来生成中间值。当动画一个坐标点(例如layer的位置)的值时，你可以指定该点的路径，而不是单独的值。动画的节奏由你提供的时间信息控制。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>values</td><td style="text-align:center">用来存放关键帧的数组</td></tr><tr><td>path</td><td style="text-align:center">基于点的属性的路径。</td></tr><tr><td>keyTimes</td><td style="text-align:center">对应关键帧段的时间点的NSNumber数组</td></tr><tr><td>timingFunctions</td><td style="text-align:center">关键帧动画节奏的数组，比如快进慢出、慢进快出等</td></tr><tr><td>calculationMode</td><td style="text-align:center">确定沿路径动画的对象是否旋转以匹配路径切线</td></tr><tr><td>tensionValues</td><td style="text-align:center">定义曲线的紧密性的NSNumber数组</td></tr><tr><td>continuityValues</td><td style="text-align:center">定义时间曲线锐角的NSNumber数组</td></tr><tr><td>biasValues</td><td style="text-align:center">定义曲线相对于控制点的位置的NSNumber数组</td></tr><tr><td>Rotation Mode Values</td><td style="text-align:center">rotationMode属性使用这些常量</td></tr><tr><td>Value calculation modes</td><td style="text-align:center">calculationMode属性使用这些常量</td></tr></tbody></table><h3 id="效果代码"><a href="#效果代码" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 指定keyPath为position，通过Values来创建关键帧动画</span><br><span class="line">- (void)CAKeyframeAnimationWithValues</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat margin = 50.f;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animation];</span><br><span class="line">    animation.keyPath = @&quot;position&quot;;</span><br><span class="line">    NSValue * value0 = [NSValue valueWithCGPoint:CGPointMake(margin, margin)];</span><br><span class="line">    NSValue * value1 = [NSValue valueWithCGPoint:CGPointMake(margin, SCREENHEIGHT - margin)];</span><br><span class="line">    NSValue * value2 = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH - margin, SCREENHEIGHT - margin)];</span><br><span class="line">    NSValue * value3 = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH - margin, margin)];</span><br><span class="line">    NSValue * value4 = [NSValue valueWithCGPoint:CGPointMake(margin, margin)];</span><br><span class="line">    animation.values = @[value0,value1,value2,value3,value4];</span><br><span class="line"></span><br><span class="line">    //当我们动画完成时,如果希望动画就自动移除的话,我们可以设置此属性为YES,默认值为YES</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.duration = 4;</span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    //快入快出</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.pointView.layer addAnimation:animation forKey:@&quot;position.values&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 指定keyPath为position，通过path路径来创建关键帧动画</span><br><span class="line">- (void)CAKeyframeAnimationWithPath</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat margin = 50.f;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animation];</span><br><span class="line">    animation.keyPath = @&quot;position&quot;;</span><br><span class="line"></span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, CGRectMake(margin, margin, SCREENWIDTH - margin * 2, SCREENHEIGHT - margin * 2));</span><br><span class="line">    animation.path = path;</span><br><span class="line">    CGPathRelease(path);</span><br><span class="line"></span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.duration = 4;</span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    NSMutableArray * timingFunctionArray = [NSMutableArray new];</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; 5 ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        //每一段都是快出效果</span><br><span class="line">        CAMediaTimingFunction * timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">        [timingFunctionArray addObject:timingFunction];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    animation.timingFunctions = timingFunctionArray;</span><br><span class="line">    [self.pointView.layer addAnimation:animation forKey:@&quot;position.path&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-9916176ef3035803.gif?imageMogr2/auto-orient/strip" alt="CAKeyframeAnimation.gif"></p><p>&ensp;&ensp;&ensp;&ensp;需要注意的是removedOnCompletion设置为NO的时候，不需要layer的时候要根据key手动移除动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.pointView.layer removeAnimationForKey:@&quot;position.values&quot;];</span><br><span class="line">[self.pointView.layer removeAnimationForKey:@&quot;position.path&quot;];</span><br></pre></td></tr></table></figure></p><hr><h2 id="CATransition-转场动画"><a href="#CATransition-转场动画" class="headerlink" title="CATransition 转场动画"></a>CATransition 转场动画</h2><p>&ensp;&ensp;&ensp;&ensp;<code>CATransition</code>的父类是<code>CAAnimation</code>，和<code>CAPropertyAnimation</code>、<code>CAAnimationGroup</code>同级。<code>CATransition</code>是用来视图的转场动画。</p><blockquote><p>You can transition between a layer’s states by creating and adding a <a href="apple-reference-documentation://hckyNQAwLg" target="_blank" rel="noopener">CATransition</a> object to it. The default transition is a cross fade, but you can specify different effects from a set of predefined transitions.</p></blockquote><h3 id="重要属性-1"><a href="#重要属性-1" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>startProgress</td><td style="text-align:center">整个变形接收的起点</td></tr><tr><td>endProgress</td><td style="text-align:center">整个变形接收的终点</td></tr><tr><td>type</td><td style="text-align:center">指定转换类型</td></tr><tr><td>subtype</td><td style="text-align:center">转换方向的子类型</td></tr><tr><td>filter</td><td style="text-align:center">提供转换的图像过滤器对象</td></tr><tr><td>Common Transition Types</td><td style="text-align:center">指定可以与type属性一起使用的转换类型的常量</td></tr><tr><td>Common Transition Subtypes</td><td style="text-align:center">指定可以与subtype属性一起使用的转换类型的常量</td></tr></tbody></table><h3 id="效果代码-1"><a href="#效果代码-1" class="headerlink" title="效果代码"></a>效果代码</h3><p>&ensp;&ensp;&ensp;&ensp;其中<code>type</code>和<code>subtype</code>有官方指定的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Common transition types. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN NSString * const kCATransitionFade</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionMoveIn</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionPush</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionReveal</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line"></span><br><span class="line">/* Common transition subtypes. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromRight</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromLeft</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromTop</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromBottom</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;还有几种效果是私有API，在官方文档中找不到，<strong>慎用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cube,                     //立体</span><br><span class="line">SuckEffect,               //吮吸</span><br><span class="line">OglFlip,                  //翻转</span><br><span class="line">RippleEffect,             //波纹</span><br><span class="line">PageCurl,                 //翻页</span><br><span class="line">PageUnCurl,               //反翻页</span><br><span class="line">CameraIrisHollowOpen,     //开镜头</span><br><span class="line">CameraIrisHollowClose,    //关镜头</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;这里写了一个例子，有12种<code>type</code>转场效果和4种<code>subtype</code>转场方向，用枚举来封装一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger,CATransactionType) &#123;</span><br><span class="line">    CATransactionType_Fade = 0,                 //默认</span><br><span class="line">    CATransactionType_MoveIn,                   //覆盖</span><br><span class="line">    CATransactionType_Push,                     //推入</span><br><span class="line">    CATransactionType_Reveal,                   //揭开</span><br><span class="line"></span><br><span class="line">    CATransactionType_Cube,                     //立体</span><br><span class="line">    CATransactionType_SuckEffect,               //吮吸</span><br><span class="line">    CATransactionType_OglFlip,                  //翻转</span><br><span class="line">    CATransactionType_RippleEffect,             //波纹</span><br><span class="line">    CATransactionType_PageCurl,                 //翻页</span><br><span class="line">    CATransactionType_PageUnCurl,               //反翻页</span><br><span class="line">    CATransactionType_CameraIrisHollowOpen,     //开镜头</span><br><span class="line">    CATransactionType_CameraIrisHollowClose,    //关镜头</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (void)CATransitionWithType:(NSString *)type WithSubtype:(NSString *)subtype</span><br><span class="line">&#123;</span><br><span class="line">    CATransition * animation = [CATransition animation];</span><br><span class="line">    animation.duration = 2.f;</span><br><span class="line">    animation.type = type;</span><br><span class="line">    animation.subtype = subtype;</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.view.layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)btnClick:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    UIButton * lastBtn;</span><br><span class="line">    NSInteger index = sender.tag - 100;</span><br><span class="line">    if (index &gt; 11)</span><br><span class="line">    &#123;</span><br><span class="line">        lastBtn = (UIButton *)[self.view viewWithTag:_subtype + 100];</span><br><span class="line">        [lastBtn setBackgroundImage:[self createImageWithColor:self.subtypeNormalColor] forState:UIControlStateNormal];</span><br><span class="line">        [sender setBackgroundImage:[self createImageWithColor:self.subtypeSelectedColor] forState:UIControlStateNormal];</span><br><span class="line">        _subtype = index;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        lastBtn = (UIButton *)[self.view viewWithTag:_transactionType + 100];</span><br><span class="line">        [lastBtn setBackgroundImage:[self createImageWithColor:self.typeNormalColor] forState:UIControlStateNormal];</span><br><span class="line">        [sender setBackgroundImage:[self createImageWithColor:self.typeSelectedColor] forState:UIControlStateNormal];</span><br><span class="line">        _transactionType = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString * subtypeString ;</span><br><span class="line"></span><br><span class="line">    switch (_subtype % 4) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            subtypeString = kCATransitionFromTop;</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">            subtypeString = kCATransitionFromBottom;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            subtypeString = kCATransitionFromLeft;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            subtypeString = kCATransitionFromRight;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch (_transactionType) &#123;</span><br><span class="line">        case CATransactionType_Fade:</span><br><span class="line">            [self CATransitionWithType:kCATransitionFade WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_MoveIn:</span><br><span class="line">            [self CATransitionWithType:kCATransitionMoveIn WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_Push:</span><br><span class="line">            [self CATransitionWithType:kCATransitionPush WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_Reveal:</span><br><span class="line">            [self CATransitionWithType:kCATransitionReveal WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case CATransactionType_Cube:</span><br><span class="line">            [self CATransitionWithType:@&quot;cube&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_SuckEffect:</span><br><span class="line">            [self CATransitionWithType:@&quot;suckEffect&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_OglFlip:</span><br><span class="line">            [self CATransitionWithType:@&quot;oglFlip&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_RippleEffect:</span><br><span class="line">            [self CATransitionWithType:@&quot;rippleEffect&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_PageCurl:</span><br><span class="line">            [self CATransitionWithType:@&quot;pageCurl&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_PageUnCurl:</span><br><span class="line">            [self CATransitionWithType:@&quot;pageUnCurl&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_CameraIrisHollowOpen:</span><br><span class="line">            [self CATransitionWithType:@&quot;cameraIrisHollowOpen&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_CameraIrisHollowClose:</span><br><span class="line">            [self CATransitionWithType:@&quot;cameraIrisHollowClose&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static NSInteger i = 0;</span><br><span class="line">    self.bgView.image = i % 2 ? [UIImage imageNamed:@&quot;拉姆.jpeg&quot;] :[UIImage imageNamed:@&quot;蕾姆.jpeg&quot;];</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-1a8800f104907166.gif?imageMogr2/auto-orient/strip" alt="CATransition1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/1487718-1da95c682f270d71.gif?imageMogr2/auto-orient/strip" alt="CATransition2.gif"></p><hr><h2 id="CAAnimationGroup-动画组"><a href="#CAAnimationGroup-动画组" class="headerlink" title="CAAnimationGroup 动画组"></a>CAAnimationGroup 动画组</h2><p>&ensp;&ensp;&ensp;&ensp;分组动画在<code>CAAnimationGroup</code>实例指定的时间中运行。分组动画的持续时间不会被缩放到他们的<code>CAAnimationGroup</code>的持续时间。相反，动画被剪切到动画组的持续时间。例如，在一个动画组中分组的10秒动画，持续时间为5秒，只显示动画的前5秒。</p><h3 id="效果代码-2"><a href="#效果代码-2" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 一个红包雨的例子</span><br><span class="line">- (void)showRain</span><br><span class="line">&#123;</span><br><span class="line">    UIImageView * imageV = [UIImageView new];</span><br><span class="line">    imageV.image = [UIImage imageNamed:@&quot;page&quot;];</span><br><span class="line">    imageV.frame = CGRectMake(0, 0, 50 , 50 );</span><br><span class="line"></span><br><span class="line">    CALayer * layer = [CALayer layer];</span><br><span class="line">    layer.bounds = imageV.frame;</span><br><span class="line">    layer.contents = (id)imageV.image.CGImage;</span><br><span class="line">    layer.anchorPoint = CGPointMake(0, 0);</span><br><span class="line">    layer.position = CGPointMake(0, 0);</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [self addAnimationWithLayer:layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAnimationWithLayer:(CALayer *)layer</span><br><span class="line">&#123;</span><br><span class="line">    int height = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line">    int width = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    NSValue * A = [NSValue valueWithCGPoint:CGPointMake(arc4random() % width, 0)];</span><br><span class="line">    NSValue * B = [NSValue valueWithCGPoint:CGPointMake(arc4random() % width, height + 100)];</span><br><span class="line">    moveAnimation.values = @[A,B];</span><br><span class="line">    moveAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * tranAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    CATransform3D r0 = CATransform3DMakeRotation(M_PI/180 * (arc4random() % 360 ) , 0, 0, -1);</span><br><span class="line">    CATransform3D r1 = CATransform3DMakeRotation(M_PI/180 * (arc4random() % 360 ) , 0, 0, -1);</span><br><span class="line">    tranAnimation.values = @[[NSValue valueWithCATransform3D:r0],[NSValue valueWithCATransform3D:r1]];</span><br><span class="line">    tranAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line"></span><br><span class="line">    CAAnimationGroup * group = [[CAAnimationGroup alloc] init];</span><br><span class="line">    group.duration = arc4random() % 200 / 100.0 + 3.5;</span><br><span class="line">    group.fillMode = kCAFillModeForwards;</span><br><span class="line">    group.removedOnCompletion = NO;</span><br><span class="line">    group.animations = @[moveAnimation,tranAnimation];</span><br><span class="line">    [layer addAnimation:group forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-fbc767740432f20c.gif?imageMogr2/auto-orient/strip" alt="CAAnimationGroup.gif"></p><hr><h2 id="CASpringAnimation-弹簧动画"><a href="#CASpringAnimation-弹簧动画" class="headerlink" title="CASpringAnimation 弹簧动画"></a>CASpringAnimation 弹簧动画</h2><p>&ensp;&ensp;&ensp;&ensp;<code>CASpringAnimation</code>的父类是<code>CABasicAnimation</code>, <code>CABasicAnimation</code>可以看成是只有头尾有值的关键帧动画。</p><blockquote><p>You would typically use a spring animation to animate a layer’s position so that it appears to be pulled towards a target by a spring. The further the layer is from the target, the greater the acceleration towards it is.<br>CASpringAnimation allows control over physically based attributes such as the spring’s damping and stiffness.</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;<code>CASpringAnimation</code>是基于物理的属性控制，比如弹簧的阻尼和刚度。</p><h3 id="重要属性-2"><a href="#重要属性-2" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>damping</td><td style="text-align:center">定义弹簧运动如何受到阻尼的影响</td></tr><tr><td>initialVelocity</td><td style="text-align:center">初速度</td></tr><tr><td>mass</td><td style="text-align:center">连接到弹簧末端的物体的质量</td></tr><tr><td>settlingDuration</td><td style="text-align:center">预估静止时间</td></tr><tr><td>stiffness</td><td style="text-align:center">弹簧刚度系数</td></tr></tbody></table><h3 id="效果代码-3"><a href="#效果代码-3" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnClick:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    //frame属性不可动画化 只能通过 bounds 和 position完成</span><br><span class="line">    CASpringAnimation * animation = [CASpringAnimation animationWithKeyPath:@&quot;bounds&quot;];</span><br><span class="line"></span><br><span class="line">    //质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大</span><br><span class="line">    animation.mass = self.massSlider.value;</span><br><span class="line"></span><br><span class="line">    //刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快</span><br><span class="line">    animation.stiffness = self.stiffnessSlider.value;</span><br><span class="line"></span><br><span class="line">    //阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快</span><br><span class="line">    animation.damping = self.dampingSlider.value;</span><br><span class="line"></span><br><span class="line">    //初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反</span><br><span class="line">    animation.initialVelocity = self.velocitySlider.value;</span><br><span class="line"></span><br><span class="line">    animation.duration = 3.f;</span><br><span class="line">    animation.fromValue =  [NSValue valueWithCGRect:CGRectMake(0, 0, 80, 100)];</span><br><span class="line">    animation.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 80, 240)];</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.baseView.layer addAnimation:animation forKey:nil];</span><br><span class="line"></span><br><span class="line">    CASpringAnimation * animation1 = [CASpringAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    animation1.duration = 3.f;</span><br><span class="line">    animation1.fromValue = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH / 2 , 250)];</span><br><span class="line">    animation1.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH / 2 , 250 - 70)];</span><br><span class="line">    animation1.removedOnCompletion = NO;</span><br><span class="line">    animation1.fillMode = kCAFillModeForwards;</span><br><span class="line">    [self.baseView.layer addAnimation:animation1 forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ae46d1313229aaa6.gif?imageMogr2/auto-orient/strip" alt="CASpringAnimation.gif"></p><hr><h3 id="UIView的弹簧动画"><a href="#UIView的弹簧动画" class="headerlink" title="UIView的弹簧动画"></a>UIView的弹簧动画</h3><p>另外在看看<code>cell</code>上用<code>UIView Block</code>弹簧动画的特效</p><h4 id="效果代码-4"><a href="#效果代码-4" class="headerlink" title="效果代码"></a>效果代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration</span><br><span class="line">                      delay:(NSTimeInterval)delay</span><br><span class="line">     usingSpringWithDamping:(CGFloat)dampingRatio</span><br><span class="line">      initialSpringVelocity:(CGFloat)velocity</span><br><span class="line">                    options:(UIViewAnimationOptions)options</span><br><span class="line">                 animations:(void (^)(void))animations</span><br><span class="line">                 completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)cellAnimation</span><br><span class="line">&#123;</span><br><span class="line">    [self.springTableView reloadData];</span><br><span class="line"></span><br><span class="line">    NSArray * cellArrays = self.springTableView.visibleCells;</span><br><span class="line">    CGFloat height = self.springTableView.bounds.size.height;</span><br><span class="line"></span><br><span class="line">    for (UITableView * cell in cellArrays)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.transform = CGAffineTransformMakeTranslation(-SCREENWIDTH, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0 ; i &lt; cellArrays.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        UITableViewCell * cell = (UITableViewCell *)cellArrays[i];</span><br><span class="line">        [UIView animateWithDuration:1.5</span><br><span class="line">                              delay:0.05 * i</span><br><span class="line">             usingSpringWithDamping:0.8</span><br><span class="line">              initialSpringVelocity:0</span><br><span class="line">                            options:0 animations:^&#123;</span><br><span class="line">                    cell.transform = CGAffineTransformMakeTranslation(0, 0);</span><br><span class="line">            &#125; completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果图-4"><a href="#效果图-4" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/1487718-0a62c12dc5195c94.gif?imageMogr2/auto-orient/strip" alt="CellSpringAnimation.gif"></p><p><a href="https://github.com/iOS-Misaki/CAAnimation"><strong>源码: CAAnimation</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;有人问我为什么要写博客，必须要承认，现在网上一大推的优秀教程和现成的Demo，自己写的没有别人好，有些地方根本不够深入，但是看别人写文章、写代码和自己写完全是两件事，代码看看就能懂，但是自己过一遍，印象更深，消化的也就更彻底。对于iOS动画 ，一直都没有系统化的学习，只有用的时候才会查查api，之前写过一篇&lt;a href=&quot;https://www.jianshu.com/p/92ac22afeeef&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;红包雨&lt;/a&gt;的文章，用的是关键帧动画，没有在继续下去。另一个就是在6月份面试的时候，有两个面试官都问到了基础动画，当时也回答的不好，现在详细地梳理一遍。现阶段，先把&lt;code&gt;Core Animation&lt;/code&gt;弄清楚，以后再下沉到&lt;code&gt;OpenGL&lt;/code&gt;和&lt;code&gt;CoreGraphics&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化实践记录</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/15/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/15/iOS-组件化实践记录/</id>
    <published>2018-07-15T03:41:54.000Z</published>
    <updated>2018-07-27T03:44:24.320Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;之前，写过文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/" target="_blank" rel="noopener">CocoaPod创建私有库</a>记录创建私有库，但是发现创建Paas项目的基础库的时候，没有那么简单，基础库中又分为网络请求、数据存储、UI功能组件、基类等。好像一个<code>Spec</code>不够，难道我要创建多个单独的私有库么？<br><a id="more"></a><br><img src="https://upload-images.jianshu.io/upload_images/1487718-c1b6e8d8f12ffce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetworking.png"></p><p>&ensp;&ensp;&ensp;&ensp;再看看<code>AFNetworking</code>的结构，发现用<code>Subspecs</code>可以解决这个问题。每个<code>Subspecs</code>可以单独依赖第三方库，也可以依赖其他的<code>Subspecs</code>。这里需要注意的是每个<code>Subspecs</code>只能单向依赖，不能互相依赖。假如熟悉<code>ruby</code>的语法，<code>Subspecs</code>的格式很容易书写。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-a80a0e21b60e7e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Network子模块.png"></p><p>&ensp;&ensp;&ensp;&ensp;拿网络模块举例，依赖的第三方库是<code>YTKNetwork</code>，还依赖基础库中工具库、数据存储库、UI功能组件。（这里解释一下，为什么会依赖其他的库，每个网络请求的<code>header</code>里面都要塞入前一个请求的<code>response</code>里面的东西,请求前和回调里面显示<code>HUD</code>，<code>HUD</code>是UI功能组件的东西）。完整的<code>podSpec</code>格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">s.name             = &apos;YYPaasBaseLib&apos;</span><br><span class="line">s.version          = &apos;0.1.8&apos;</span><br><span class="line">s.summary          = &apos;Paas平台的基础库&apos;</span><br><span class="line"></span><br><span class="line">s.description      = &lt;&lt;-DESC</span><br><span class="line">TODO: Add long description of the pod here.</span><br><span class="line">DESC</span><br><span class="line"></span><br><span class="line">s.homepage         = &apos;https://git.qianjiangcloud.com/products/paas-app-ios-plugin&apos;</span><br><span class="line">s.license          = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125;</span><br><span class="line">s.author           = &#123; &apos;yuyiios@163.com&apos; =&gt; &apos;yuyiios@163.com&apos; &#125;</span><br><span class="line">s.source           = &#123; :git =&gt; &apos;https://git.qianjiangcloud.com/products/paas-app-ios-plugin.git&apos;, :tag =&gt; s.version.to_s &#125;</span><br><span class="line"></span><br><span class="line">s.ios.deployment_target = &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Category&apos; do |category|</span><br><span class="line">category.source_files = &apos;YYPaasBaseLib/Classes/Category/*.&#123;h,m&#125;&apos;</span><br><span class="line">category.public_header_files = &apos;YYPaasBaseLib/Classes/Category/*.h&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;DataStore&apos; do |dataStore|</span><br><span class="line">dataStore.source_files = &apos;YYPaasBaseLib/Classes/DataStore/*.&#123;h,m&#125;&apos;</span><br><span class="line">dataStore.public_header_files = &apos;YYPaasBaseLib/Classes/DataStore/*.h&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Tool&apos; do |tool|</span><br><span class="line">tool.source_files = &apos;YYPaasBaseLib/Classes/Tool/*.&#123;h,m&#125;&apos;</span><br><span class="line">tool.public_header_files = &apos;YYPaasBaseLib/Classes/Tool/*.h&apos;</span><br><span class="line"></span><br><span class="line">tool.dependency &apos;YYModel&apos;, &apos;~&gt; 1.0.4&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;UI&apos; do |ui|</span><br><span class="line">ui.source_files = &apos;YYPaasBaseLib/Classes/UI/*.&#123;h,m&#125;&apos;</span><br><span class="line">ui.public_header_files = &apos;YYPaasBaseLib/Classes/UI/*.h&apos;</span><br><span class="line"></span><br><span class="line">ui.dependency &apos;Masonry&apos;, &apos;~&gt; 1.1.0&apos;</span><br><span class="line">ui.dependency &apos;MJRefresh&apos;, &apos;~&gt; 3.1.15.3&apos;</span><br><span class="line">ui.dependency &apos;MBProgressHUD&apos;, &apos;~&gt; 1.1.0&apos;</span><br><span class="line">ui.dependency &apos;IQKeyboardManager&apos;, &apos;~&gt; 6.0.4&apos;</span><br><span class="line">ui.dependency &apos;SDWebImage&apos;, &apos;~&gt; 4.4.1&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;View&apos; do |view|</span><br><span class="line">view.source_files = &apos;YYPaasBaseLib/Classes/View/*.&#123;h,m&#125;&apos;</span><br><span class="line">view.public_header_files = &apos;YYPaasBaseLib/Classes/View/*.h&apos;</span><br><span class="line">view.frameworks = &apos;WebKit&apos;</span><br><span class="line"></span><br><span class="line">view.dependency &apos;YYPaasBaseLib/Tool&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Network&apos; do |network|</span><br><span class="line">network.source_files = &apos;YYPaasBaseLib/Classes/Network/*.&#123;h,m&#125;&apos;</span><br><span class="line">network.public_header_files = &apos;YYPaasBaseLib/Classes/Network/*.h&apos;</span><br><span class="line"></span><br><span class="line">network.dependency &apos;YTKNetwork&apos;, &apos;~&gt; 2.0.4&apos;</span><br><span class="line"></span><br><span class="line">network.dependency &apos;YYPaasBaseLib/Tool&apos;</span><br><span class="line">network.dependency &apos;YYPaasBaseLib/DataStore&apos;</span><br><span class="line">network.dependency &apos;YYPaasBaseLib/UI&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &apos;Mediator&apos; do |mediator|</span><br><span class="line">mediator.source_files = &apos;YYPaasBaseLib/Classes/Mediator/*.&#123;h,m&#125;&apos;</span><br><span class="line">mediator.public_header_files = &apos;YYPaasBaseLib/Classes/Mediator/*.h&apos;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.frameworks = &apos;UIKit&apos;, &apos;Foundation&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-23b181626f3d3b6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YYPaasBaseLib.png"></p><p>&ensp;&ensp;&ensp;&ensp;一周前，就已经完成项目的基础库的创建，当时想着的是<strong>基础库和业务脱离</strong>，不需要太大的改变，但是从实际开发来看，<code>YYPaasBaseLib</code>已经从0.1.0版本更新到0.1.8版本，变动还是挺大的。关于功能的划分也是费了一番脑子，最后也把中间层<code>Mediator</code>放在基础模块里面（中间层+模块的<code>Category</code>和模块的<code>Target</code>都放在各自的业务模块中），放着这里其实不太好，但是目前没有找到更合适的方式。</p><p>&ensp;&ensp;&ensp;&ensp;其实还有些东西和基础库、业务模块都有联系。对于这块的划分很是头疼，比如<code>NSNotification</code>名称和数据存储的键名，还有网络请求关于业务成功回调的定义，有的是根据某个字段的定义，有的是判断某个对象的有无来的。暂且把这些东西叫做弱业务关系，把弱业务关系放入基础模块是不合适的，对于不同的业务模块或者项目，弱业务关系都不一样。放入具体的业务模块也不合适，冗余太大。只能单独抽出来一个弱业务关系组件，那么依赖关系应该是这样 <strong>业务组件–&gt; 弱业务组件–&gt;基础组件</strong>。想快速新建一个APP的话，要同时替换弱业务组件和部分业务组件。</p><p>&ensp;&ensp;&ensp;&ensp;<strong>组件化不是一蹴而就，需要慢慢的摸索。</strong>现在APP刚起步，模块还比较少，编译的时间比较快，属于可接受范围内，后期模块比较多的时候，编译时间会增加，而且模块成熟不需要做大量修改，那个时候再考虑二进制化，把组件的源码转换成静态库或者动态库，来提高编译速度。</p><p>&ensp;&ensp;&ensp;&ensp;iOS项目按照模块化的方式来开发，没有<code>tabBarController</code>,<code>RootController</code>直接指向首页，首页是一个<code>WKWebView</code>，业务实现都在<code>WKWebView</code>里面。原生的部分还包括登录、注册和忘记密码。<code>WkWebView</code>需要<code>token</code>的时候，H5调用原生页面去登录，从后台拿到<code>token</code>后，本地存储，然后注入<code>WKWebView</code>的<code>Cookie</code>里面。后面的工作是引入支付、加入<code>tabBarController</code>,把H5的功能都实现出来。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-efcce8811cb63474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="千匠星云下载二维码.png"></p><p>&ensp;&ensp;&ensp;&ensp;最后加一条硬广。APP在内测阶段，用企业级账号打了一个<code>.ipa</code>包，不大才<strong>2.1M</strong>,放在了免费的腾讯云上面，欢迎扫码下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;之前，写过文章&lt;a href=&quot;https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaPod创建私有库&lt;/a&gt;记录创建私有库，但是发现创建Paas项目的基础库的时候，没有那么简单，基础库中又分为网络请求、数据存储、UI功能组件、基类等。好像一个&lt;code&gt;Spec&lt;/code&gt;不够，难道我要创建多个单独的私有库么？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化尝试</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B0%9D%E8%AF%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/iOS-组件化尝试/</id>
    <published>2018-07-01T03:23:54.000Z</published>
    <updated>2018-07-27T03:38:19.227Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;<code>ReactiveCocoa</code>只更新了一篇，剩下结合登录例子来实践<code>MVVM</code>暂时没有时间，这周精力都放在了公司项目的组件化上面，以后有时间会慢慢补上。感觉欠的历史债好多。</p><a id="more"></a><h2 id="传统模块的耦合"><a href="#传统模块的耦合" class="headerlink" title="传统模块的耦合"></a>传统模块的耦合</h2><p>&ensp;&ensp;&ensp;&ensp;对于大型项目来说，业务模块之间的耦合度非常大，很难维护。模块之间会互相调用。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-14005383adc14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统模块"></p><p>&ensp;&ensp;&ensp;&ensp;为了解决这个问题，可以增加一个中间层。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-ed43c5ee1fb260b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加中间层"><br>&ensp;&ensp;&ensp;&ensp;但是模块和中间层还是互相依赖，之前耦合的问题还是存在，要改进的地方是消除中间层对业务模块的依赖。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-a1542a4366eedd5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终方案"></p><h2 id="模块的划分"><a href="#模块的划分" class="headerlink" title="模块的划分"></a>模块的划分</h2><p>&ensp;&ensp;&ensp;&ensp;组件化是把每个模块作为一个组件，在主工程里面集成所有的组件。关于用<code>CocoaPod</code>集成私有库，在上篇文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/" target="_blank" rel="noopener">CocoaPod创建私有库</a>有详细的介绍。<br>&ensp;&ensp;&ensp;&ensp;整个项目中模块的划分是分为基础模块、中间层和业务模块。</p><ul><li>基础模块里面是和业务没有任何关联的模块，里面包括网络请求、图片加载、数据存储、页面布局还有公共的工具类等。</li><li>业务模块是按照功能来划分的。根据业务需要，来确定颗粒度的大小，比如登录注册模块、用户信息模块、购物车模块、详情模块、订单模块等。业务模块是要依赖基础模块的。</li><li>中间层不依赖业务模块，只负责调度业务模块。</li></ul><h2 id="模块之间的通讯"><a href="#模块之间的通讯" class="headerlink" title="模块之间的通讯"></a>模块之间的通讯</h2><p>&ensp;&ensp;&ensp;&ensp;消除中间层对业务的依赖，有三种方案。</p><ul><li>蘑菇街 <a href="https://link.jianshu.com/?t=https://github.com/mogujie/MGJRouter.git" target="_blank" rel="noopener">MGJRouter</a> <code>URL -&gt; block</code></li><li>后来蘑菇街对这种方案提出改进<code>protocol -&gt; class</code></li><li>casatwy大神的 基于<a href="https://github.com/casatwy/CTMediator.git">CTMediator</a>的<code>Target -&gt; Action</code></li></ul><p>&ensp;&ensp;&ensp;&ensp;下面重点介绍第三种方案。把所有组件的调用都通过<code>category</code>的方式暴露出来，调用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;现在举个例子，首页要push登录页面。在中间层新建一个<code>CTMediator</code>的分类<code>CTMediator+UMAction</code>,暴露一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)CTMediator_viewControllerForDetailWithValue:(NSString *)value;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>Targe</code>t是<code>UM</code>,<code>Action</code>的对象是<code>LoginViewController</code>。然后再<code>UM</code>模块里面建立<code>Target_UM</code>文件，来处理<code>LoginViewController</code>的实例化。在首页调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIViewController * vc = [[CTMediator sharedInstance] CTMediator_viewControllerForDetailWithValue:@&quot;我是标题&quot;];</span><br><span class="line">[self.navigationController presentViewController:vc animated:YES completion:nil];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;可以看到首页并没有引入<code>LoginViewController</code>的头文件。<code>CTMediator</code> 实际上是基于<code>Runtime</code>进行类名反射，将<code>CTMediator+UMAction</code>调用生成一个<code>Target_UM</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">Class targetClass;</span><br><span class="line"></span><br><span class="line">NSObject *target = self.cachedTarget[targetClassString];</span><br><span class="line">if (target == nil) &#123;</span><br><span class="line">targetClass = NSClassFromString(targetClassString);</span><br><span class="line">target = [[targetClass alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEL action = NSSelectorFromString(actionString);</span><br><span class="line">return [self safePerformAction:action target:target params:params];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<strong>所以每添加一个模块，都要在中间层声明一个分类来调用，同时也要在相应的模块内去实现这个<code>Target</code>。</strong></p><h2 id="关于组件化的思考"><a href="#关于组件化的思考" class="headerlink" title="关于组件化的思考"></a>关于组件化的思考</h2><p>&ensp;&ensp;&ensp;&ensp;实施组件化的大致的步骤，首先是把项目解耦拆分成一个个单独的组件，然后实现组件间的通讯。</p><ul><li><p>组件化的好处<br><strong>简化了代码的整体结构，降低了维护成本，不同模块通过git管理，实现物理隔离，提高代码的稳定性，为模块的复用提供了基础，未来可以灵活的扩展业务。</strong></p></li><li><p>组件化的缺点。<br><strong>学习成本高，对开发人员掌握各种工具要求比较高，入门比较困难，个人学习制作私有库，也是踩了好多坑。前期基业务没有实现，要提前考虑模块之间的解耦，过多的关注组件间的通讯，必然导致开发效率的下降。</strong></p></li></ul><p>&ensp;&ensp;&ensp;&ensp;说一下项目，脱离实际项目谈架构都是扯淡。目前接手的项目是个电商类的项目，iOS 和安卓都还没有起步，web前端已经实现1.0版本，基本的电商的功能都实现了。iOS项目目前就两个人。项目想做成一个模板，然后给不同的客户提供可定制化的功能。项目管理人员想推行组件化，这周我在实践这一方案的可行性。<br>&ensp;&ensp;&ensp;&ensp;并不是所有项目是适用于组件化。就对于现在的项目来说，只有两个开发人员。我来确定代码规范，不存在多人协同冲突的情况。产品虽然说后端接口和web前端都实现了，但是iOS和安卓项目都还没起步，实现最基础的业务，快速迭代上线更加重要，现有MVC或者MVVM就足够现实了。当实现了基础业务，需要更多对细节关注，才差不多要考虑组件化。<br>&ensp;&ensp;&ensp;&ensp;组件化适合业务成熟且繁杂、开发人员多的大团队，对于我们两人且还没有开启项目的团队至少现在这个时间节点来说是不合适的。适合项目的架构就是好架构，组件化是好技术，但是在不合适的时候盲目追求组件化，是本末倒置的。</p><p><strong>参考 :</strong><br><a href="https://casatwy.com/modulization_in_action.html" target="_blank" rel="noopener">在现有工程中实施基于CTMediator的组件化方案</a><br><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;code&gt;ReactiveCocoa&lt;/code&gt;只更新了一篇，剩下结合登录例子来实践&lt;code&gt;MVVM&lt;/code&gt;暂时没有时间，这周精力都放在了公司项目的组件化上面，以后有时间会慢慢补上。感觉欠的历史债好多。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPod 创建私有库</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/CocoaPod-创建私有库/</id>
    <published>2018-07-01T01:35:21.000Z</published>
    <updated>2018-07-27T03:35:42.215Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在码云(<a href="https://gitee.com/yuyiios/events" target="_blank" rel="noopener">我的个人主页</a>)上创建两个远程仓库，其中<code>YYSpecs</code> 用来存放本地的<code>spec</code>,<code>YYToolProject</code>是用来存放私有库代码的。</p><h2 id="创建本地索引"><a href="#创建本地索引" class="headerlink" title="创建本地索引"></a>创建本地索引</h2><p>&ensp;&ensp;&ensp;&ensp;首先 进入<code>~/.cocoapods/repos</code>目录 查看有一个<code>master</code>的目录，<code>master</code>就是<code>cocoapod</code>官网的索引源，现在要做的就是创建自己私有的<code>Spec Repo</code>.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span><br><span class="line">pod repo add YYSpecs  https://gitee.com/yuyiios/YYSpecs.git</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1487718-8a8184268cf14700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="~:.cocoapods:repos目录.png"></p><p>&ensp;&ensp;&ensp;&ensp;然后可以看见<code>master</code>有个同级目录<code>YYSpecs</code>。私有<code>Spec Repo</code>就创建完成了。</p><h2 id="创建本地lib"><a href="#创建本地lib" class="headerlink" title="创建本地lib"></a>创建本地lib</h2><p>&ensp;&ensp;&ensp;&ensp;进入桌面目录，创建一个名为<code>YYToolSet</code>的<code>pod</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create YYToolSet</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;会有以下提示，按照问题回答就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide: </span><br><span class="line">- https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line">( hold cmd and double click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line">&gt; </span><br><span class="line">ios</span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line">&gt; ObjC</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line">&gt; No</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">&gt; None</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line">&gt; No</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line">&gt; YY</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;在Finder中，将<code>/YYToolSet/Classes</code>目录下的<code>ReplaceMe.m</code>删除 替换成自己的文件，如图。<img src="https://upload-images.jianshu.io/upload_images/1487718-465ead8a2f11b57d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="替换掉ReplaceMe文件.png"><br>&ensp;&ensp;&ensp;&ensp;打开工程，查看<code>YYToolSet.podspec</code>文件</p><ul><li>s.version 是pod的版本信息 这个后面打tag的时候用的到</li><li>s.summary 是简短的描述</li><li>s.source 是项目远程仓库的地址，这里不要用SSH，用HTTPS。</li><li>s.homepage 是项目主页地址 就是HTTPS地址后面去掉.git 就可以</li><li>s.source_files 是项目的文件 就是刚才替换ReplaceMe.m的那些文件 </li><li>s.resource_bundles 是资源文件</li><li>s.frameworks 是用到了系统的哪些库 例如UIKit、Foundation</li><li>s.dependency 是用到哪些第三方库 比如AFNetworking 有多个就写多个s.dependency</li><li>s.public_header_files 项目的公共头文件，举个例子，当引入Masonry、YTKNetwork的时候 可以创建一个header文件，然后将#import “Masonry.h”    #import “YTKNetwork.h”写入进去</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ed45e32c442d9704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置文件.png"></p><h2 id="验证本地lib"><a href="#验证本地lib" class="headerlink" title="验证本地lib"></a>验证本地lib</h2><p>&ensp;&ensp;&ensp;&ensp;修改完成后，切换到外面的<code>YYToolSet</code>目录，验证<code>podspec</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line">pod lib lint --verbose</span><br><span class="line">pod lib lint --allow-warnings</span><br><span class="line">pod lib lint --sources=https://gitee.com/yuyiios/YYSpecs.git</span><br><span class="line">pod lib lint --use-libraries</span><br></pre></td></tr></table></figure></p><ul><li>–verbose 假如有error,查看报错信息</li><li>–allow-warnings 假如有warning，可以通过来忽略错误信息通过验证 </li><li>–sources 假如这个私有库还依赖其他的私有库，一定要指定私有库的索引源（就是我上文说的YYSpecs的git地址）–sources=<a href="https://github.com/artsy/Specs,master">https://github.com/artsy/Specs,master</a></li><li>–use-libraries 如果用了第三方的framework或者静态库，要加上。</li></ul><h2 id="验证本地和远端的pod"><a href="#验证本地和远端的pod" class="headerlink" title="验证本地和远端的pod"></a>验证本地和远端的pod</h2><p>&ensp;&ensp;&ensp;&ensp;本地校验成功后，推送至远端，就是<code>YYToolProject</code>的git地址。进入外面的<code>YYToolSet</code>目录。执行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [GitHub HTTPS clone URL]</span><br><span class="line">git remote add origin https://gitee.com/yuyiios/YYToolProject.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;有冲突先解决冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;fix&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后给<code>pod</code>打上标签，并且推送至远端，注意这里的<code>tag</code>要和<code>podspec</code>文件里面的<code>s.version</code>对应起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -m &apos;0.1.0标签&apos; -a 0.1.0</span><br><span class="line">git push --tags</span><br><span class="line">git tag //查看标签</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;打完标签后，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>pod lib lint</code>和<code>pod spec lint</code>的区别是前者只会检验本地的<code>pod</code>,后者是本地和远端都会检验，所以之前用到的<code>--allow-warning  --sources --use-libraries</code> 等命令的这里都要带上。</p><h2 id="推送至索引源仓库"><a href="#推送至索引源仓库" class="headerlink" title="推送至索引源仓库"></a>推送至索引源仓库</h2><p>&ensp;&ensp;&ensp;&ensp;远端和本地都校验通过后就要将<code>YYToolSet.podspec</code>推送至<code>YYSpecs</code>仓库中 成功后去<code>~/.cocoapods/repos/YYSpecs</code> 有个<code>YYToolSet</code>目录 有个0.1.0的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [Repo名] [podspec 文件名字]</span><br><span class="line">pod repo push YYSpecs YYToolSet.podspec</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;最后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pod search YYToolSet </span><br><span class="line">-&gt; YYToolSet (0.1.0)</span><br><span class="line">工具集 YYToolSet.</span><br><span class="line">pod &apos;YYToolSet&apos;, &apos;~&gt; 0.1.0&apos;</span><br><span class="line">- Homepage: https://gitee.com/yuyiios/YYToolProject</span><br><span class="line">- Source:   https://gitee.com/yuyiios/YYToolProject.git</span><br><span class="line">- Versions: 0.1.0 [YYSpecs repo]</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;新建一个空项目，导入私有库验证一下，这里一定要带上<code>source</code> 就是<code>YYToolSet</code>所在索引源的远端地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pod init </span><br><span class="line">vim Podfile</span><br><span class="line"></span><br><span class="line">source &apos;https://gitee.com/yuyiios/YYToolProject.git&apos;</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">source &apos;https://gitee.com/yuyiios/YYSpecs.git&apos;</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;None&apos; do</span><br><span class="line">pod &apos;YYToolSet&apos;, &apos;~&gt; 0.1.0&apos;</span><br><span class="line"># use_frameworks!</span><br><span class="line"></span><br><span class="line"># Pods for None</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-685e87a6ae906c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证通过.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在码云(&lt;a href=&quot;https://gitee.com/yuyiios/events&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的个人主页&lt;/a&gt;)上创建两个远程仓库，其中&lt;code&gt;YYSpecs&lt;/code&gt; 用来存放本地的&lt;code&gt;spec&lt;/code&gt;,&lt;code&gt;YYToolProject&lt;/code&gt;是用来存放私有库代码的。&lt;/p&gt;
&lt;h2 id=&quot;创建本地索引&quot;&gt;&lt;a href=&quot;#创建本地索引&quot; class=&quot;headerlink&quot; title=&quot;创建本地索引&quot;&gt;&lt;/a&gt;创建本地索引&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;首先 进入&lt;code&gt;~/.cocoapods/repos&lt;/code&gt;目录 查看有一个&lt;code&gt;master&lt;/code&gt;的目录，&lt;code&gt;master&lt;/code&gt;就是&lt;code&gt;cocoapod&lt;/code&gt;官网的索引源，现在要做的就是创建自己私有的&lt;code&gt;Spec Repo&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 8种经典算法可视化</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/18/iOS-8%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/18/iOS-8种经典算法可视化/</id>
    <published>2018-04-18T15:32:26.000Z</published>
    <updated>2018-07-26T16:10:02.189Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;先看图，这里为了方便展示gif图片，在冒泡排序、选择排序、插入排序，视图更新停留的时间设置为0.001秒，其他排序设置视图更新时间为0.003秒。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/1487718-c67a8b114e5a12b8.gif?imageMogr2/auto-orient/strip" alt="0冒泡排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ab8a517890793cd8.gif?imageMogr2/auto-orient/strip" alt="1选择排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-94a562e4f40c9067.gif?imageMogr2/auto-orient/strip" alt="2插入排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-20d8e1c4744b3002.gif?imageMogr2/auto-orient/strip" alt="3快速排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-2db8865d136d7b27.gif?imageMogr2/auto-orient/strip" alt="4希尔排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-92b55075ee71d41f.gif?imageMogr2/auto-orient/strip" alt="5归并排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-f489ad65de02a3a1.gif?imageMogr2/auto-orient/strip" alt="6堆排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-333d51fc00d19b26.gif?imageMogr2/auto-orient/strip" alt="7基数排序（0.003s）.gif"></p><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><img src="https://upload-images.jianshu.io/upload_images/1487718-3fe0a1205ccd214d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复杂度.jpg"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="高度可视化"><a href="#高度可视化" class="headerlink" title="高度可视化"></a>高度可视化</h3><p>&ensp;&ensp;&ensp;&ensp;首先，用视图<code>SortView</code>的高度来代表随机数，为了便于查看，本身的颜色随着高度变化而变化，对外暴露一个更改高度的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SortView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SortView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        self.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat y = self.superview.frame.size.height - self.frame.size.height;</span><br><span class="line"></span><br><span class="line">    CGRect frame = self.frame;</span><br><span class="line">    frame.origin.y = y;</span><br><span class="line">    self.frame = frame;</span><br><span class="line"></span><br><span class="line">    CGFloat weight = frame.size.height / self.superview.frame.size.height;</span><br><span class="line">    UIColor * color = [UIColor colorWithHue:weight saturation:1 brightness:1 alpha:1];</span><br><span class="line">    self.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateHeight:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    CGRect temp = self.frame;</span><br><span class="line">    temp.size.height = height;</span><br><span class="line">    self.frame = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后再生成随机数数组和<code>sortView</code>数组一一对应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 生成随机数数组</span><br><span class="line">- (void)setup_random</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; self.count ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int height = (int)(SCREENHEIGHT - 200);</span><br><span class="line">        NSInteger random = arc4random() % height;</span><br><span class="line">        NSNumber * num = [NSNumber numberWithInteger:random];</span><br><span class="line">        [self.randomArray addObject:num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)addSortViews</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; self.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        CGFloat width = SCREENWIDTH / self.count;</span><br><span class="line">        SortView * sortView = [[SortView alloc]initWithFrame:CGRectMake(i * width, 0, width, [self.randomArray[i] integerValue])];</span><br><span class="line">        [self.containerView addSubview:sortView];</span><br><span class="line">        [self.sortViewArray addObject:sortView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="排序交换回调"><a href="#排序交换回调" class="headerlink" title="排序交换回调"></a>排序交换回调</h3><p>&ensp;&ensp;&ensp;&ensp;然后在排序类，定义一个回调<code>SortObjectBlock</code>，用于更新视图的高度。<code>index</code>参数是在数组的索引值，<code>value</code>是索引值对应元素要修改的高度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SortObjectBlock)(NSInteger index,NSNumber * value);</span><br><span class="line"></span><br><span class="line">@interface SortObject : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) SortObjectBlock sortObjectBlock;</span><br></pre></td></tr></table></figure></p><h3 id="阻塞时间完成视觉效果"><a href="#阻塞时间完成视觉效果" class="headerlink" title="阻塞时间完成视觉效果"></a>阻塞时间完成视觉效果</h3><p><code>SortObjectBlock</code>在排序的时候，接收回调,为了方面观察排序的变化，每次数组中有值发生变化的时候阻塞线程0.001s。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)sort</span><br><span class="line">&#123;</span><br><span class="line">    SortObject *  sortObject = [SortObject new];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    sortObject.sortObjectBlock = ^(NSInteger index,NSNumber * value)&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.001];</span><br><span class="line">        [weakSelf updateSortViewWithIndex:index widthValue:value];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 更新视图</span><br><span class="line">- (void)updateSortViewWithIndex:(NSInteger)index widthValue:(NSNumber *)value</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        SortView * sortView = (SortView *)[weakSelf.sortViewArray objectAtIndex:index];</span><br><span class="line">        [sortView updateHeight:[value integerValue]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8种算法"><a href="#8种算法" class="headerlink" title="8种算法"></a>8种算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 冒泡</span><br><span class="line">- (NSMutableArray *)sort0:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger j = 0 ; j &lt; i ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i] &lt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(i,array[j]);</span><br><span class="line">                    _sortObjectBlock(j,array[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 选择排序</span><br><span class="line">- (NSMutableArray *)sort1:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger j = i + 1 ; j &lt; array.count ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i] &gt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(i,array[j]);</span><br><span class="line">                    _sortObjectBlock(j,array[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark - 插入排序</span><br><span class="line">- (NSMutableArray *)sort2:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSNumber * temp = array[i];</span><br><span class="line">        for (NSInteger j = i - 1 ; j &gt;= 0 &amp;&amp; temp &lt; array[j] ; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(j,array[j + 1]);</span><br><span class="line">                _sortObjectBlock(j + 1,array[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            [array exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>&ensp;&ensp;&ensp;&ensp;快速排序是对冒泡排序的一种改进，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 快速排序</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)sort3:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self quickSort:array leftIndex:0 rightIndex:array.count - 1];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)quickSort:(NSMutableArray *)array leftIndex:(NSInteger)left rightIndex:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    if (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        NSInteger temp = [self getMiddleIndex:array leftIndex:left rightIndex:right];</span><br><span class="line">        //递归前半部分</span><br><span class="line">        [self quickSort:array leftIndex:left rightIndex:temp - 1];</span><br><span class="line">        //递归后半部分</span><br><span class="line">        [self quickSort:array leftIndex:temp + 1 rightIndex:right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组以第一个值为准分成两部分，前半部分比该值要小，后半部分比该值要大</span><br><span class="line">- (NSInteger)getMiddleIndex:(NSMutableArray *)array leftIndex:(NSInteger)left rightIndex:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * temp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; temp &lt;= array[right]) &#123;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(left,array[right]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = array[right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt;= temp) &#123;</span><br><span class="line">            left ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(right,array[left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[right] = array[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_sortObjectBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sortObjectBlock(left,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[left] = temp;</span><br><span class="line"></span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>&ensp;&ensp;&ensp;&ensp;希尔排序又叫缩小增量排序，属于插入排序的一种。把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。这里取得的增量为一半。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 希尔排序</span><br><span class="line">- (NSMutableArray *)sort4:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger increment = array.count / 2 ; increment &gt; 0 ; increment /= 2 )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger i = increment ; i &lt; array.count ; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSInteger j = i ;</span><br><span class="line">            for (; j - increment &gt;= 0 &amp;&amp; array[j] &lt; array[j-increment]; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(j,array[j - increment]);</span><br><span class="line">                    _sortObjectBlock(j - increment,array[j]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:j withObjectAtIndex:(j - increment)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&ensp;&ensp;&ensp;&ensp;归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 归并排序</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)sort5:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self megerSortWithArray:array];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)megerSortWithArray:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * tempArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    //将数组中的每一个元素放入一个数组中</span><br><span class="line">    for (NSNumber * num in array)</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * subArray = [NSMutableArray array];</span><br><span class="line">        [subArray addObject:num];</span><br><span class="line">        [tempArray addObject:subArray];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对这个数组中的数组进行合并，直到合并完毕为止</span><br><span class="line">    while (tempArray.count != 1) &#123;</span><br><span class="line">        NSInteger i = 0 ;</span><br><span class="line">        while (i &lt; tempArray.count - 1) &#123;</span><br><span class="line">            //将tempArray[i] 和 tempArray[i+1]合并</span><br><span class="line">            tempArray[i] = [self mergeArrayFirstList:tempArray[i] secondList:tempArray[i + 1]];</span><br><span class="line">            [tempArray removeObjectAtIndex:(i + 1)];</span><br><span class="line">            </span><br><span class="line">            for (NSInteger subIndex = 0 ; subIndex &lt; [tempArray[i] count]; subIndex ++)</span><br><span class="line">            &#123;</span><br><span class="line">                NSInteger index = [self countEndIndex:i SubItemIndex:subIndex TempArray:tempArray];</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(index,tempArray[i][subIndex]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    array = tempArray[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将两个有序数组进行合并,返回一个排序好的数组</span><br><span class="line">- (NSArray *)mergeArrayFirstList:(NSArray *)array1 secondList:(NSArray *)array2</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * resultArray = [NSMutableArray array];</span><br><span class="line">    NSInteger firstIndex = 0;</span><br><span class="line">    NSInteger secondIndex = 0;</span><br><span class="line">    while (firstIndex &lt; array1.count &amp;&amp; secondIndex &lt; array2.count) &#123;</span><br><span class="line">        if ([array1[firstIndex] integerValue] &lt; [array2[secondIndex] integerValue])</span><br><span class="line">        &#123;</span><br><span class="line">            [resultArray addObject:array1[firstIndex]];</span><br><span class="line">            firstIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [resultArray addObject:array2[secondIndex]];</span><br><span class="line">            secondIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (firstIndex &lt; array1.count) &#123;</span><br><span class="line">        [resultArray addObject:array1[firstIndex]];</span><br><span class="line">        firstIndex ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (secondIndex &lt; array2.count) &#123;</span><br><span class="line">        [resultArray addObject:array2[secondIndex]];</span><br><span class="line">        secondIndex ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return resultArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)countEndIndex:(NSInteger)endIndex SubItemIndex:(NSInteger)subItemIndex TempArray:(NSMutableArray *)tempArray</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger sum = 0 ;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; endIndex ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += [tempArray[i] count];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum + subItemIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>&ensp;&ensp;&ensp;&ensp;它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 堆排序</span><br><span class="line">- (NSMutableArray *)sort6:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    return [self heapSort:array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)heapSort:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * list = [NSMutableArray arrayWithArray:array];</span><br><span class="line">    NSInteger endIndex = array.count - 1;</span><br><span class="line">    //创建大顶堆 把array 转换为大顶堆层次的遍历结果</span><br><span class="line">    [self heapCreate:list];</span><br><span class="line"></span><br><span class="line">    while (endIndex &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">        //交换大顶堆的收尾两个值</span><br><span class="line">        if (_sortObjectBlock)</span><br><span class="line">        &#123;</span><br><span class="line">            _sortObjectBlock(0,list[endIndex]);</span><br><span class="line">            _sortObjectBlock(endIndex,list[0]);</span><br><span class="line"></span><br><span class="line">            [list exchangeObjectAtIndex:0 withObjectAtIndex:endIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //缩小大顶堆的范围</span><br><span class="line">        endIndex -- ;</span><br><span class="line">        [self heapAdjast:list withStartIndex:0 withEndIndex:endIndex + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构建大顶堆的层次遍历序列</span><br><span class="line">- (void)heapCreate:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger i = array.count;</span><br><span class="line">    for (; i &gt; 0; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        [self heapAdjast:array withStartIndex:i - 1 withEndIndex:array.count];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对大顶堆的局部调整，使其改节点的所有父类符合大顶堆的特点</span><br><span class="line">- (void)heapAdjast:(NSMutableArray *)array withStartIndex:(NSInteger)startIndex withEndIndex:(NSInteger)endIndex</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * temp = array[startIndex];</span><br><span class="line">    //父节点下标</span><br><span class="line">    NSInteger fatherIndex = startIndex + 1;</span><br><span class="line">    //左孩子下标</span><br><span class="line">    NSInteger leftChildIndex = fatherIndex * 2;</span><br><span class="line">    while (leftChildIndex &lt;= endIndex) &#123;</span><br><span class="line">        //比较左右节点 找出较大的角标</span><br><span class="line">        if (leftChildIndex &lt; endIndex &amp;&amp; array[leftChildIndex - 1] &lt; array[leftChildIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            leftChildIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果较大的子节点比根节点大 赋值为父节点</span><br><span class="line">        if (temp &lt; array[leftChildIndex - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(fatherIndex - 1,array[leftChildIndex - 1]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[fatherIndex - 1] = array[leftChildIndex - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fatherIndex = leftChildIndex;</span><br><span class="line">        leftChildIndex = fatherIndex * 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_sortObjectBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sortObjectBlock(fatherIndex - 1,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[fatherIndex - 1] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>&ensp;&ensp;&ensp;&ensp;它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 基数排序</span><br><span class="line">- (NSMutableArray *)sort7:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self radixSort:array];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)radixSort:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    //创建空桶</span><br><span class="line">    NSMutableArray * bucket = [self createBucket];</span><br><span class="line"></span><br><span class="line">    //待排数组的最大数值</span><br><span class="line">    NSNumber * maxNumber = [self listMaxItem:array];</span><br><span class="line"></span><br><span class="line">    //最大数值的数字位数</span><br><span class="line">    NSInteger maxLength = [self numberLength:maxNumber];</span><br><span class="line"></span><br><span class="line">    //按照从低位到高位的顺序执行排序过程</span><br><span class="line">    for (NSInteger digit = 1 ; digit &lt;= maxLength ; digit ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        //入桶</span><br><span class="line">        for (NSNumber * item in array)</span><br><span class="line">        &#123;</span><br><span class="line">            //确定item 归属哪个桶 以digit位数为基数</span><br><span class="line">            NSInteger baseNumber = [self fetchBaseNumber:item digit:digit];</span><br><span class="line">            NSMutableArray * mutArray = bucket[baseNumber];</span><br><span class="line">            //将数据放入空桶上</span><br><span class="line">            [mutArray addObject:item];            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSInteger index = 0;</span><br><span class="line"></span><br><span class="line">        //出桶</span><br><span class="line">        for (NSInteger i = 0 ; i &lt; bucket.count ; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSMutableArray * subArray = bucket[i];</span><br><span class="line">            //将桶的数据放回待排数组中</span><br><span class="line">            while (subArray.count != 0) &#123;</span><br><span class="line">                NSNumber * number = [subArray objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(index,number);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[index] = number;</span><br><span class="line">                [subArray removeObjectAtIndex:0];</span><br><span class="line">                index ++ ;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建空桶</span><br><span class="line">- (NSMutableArray *)createBucket</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * bucket = [NSMutableArray array];</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; 10 ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * array = [NSMutableArray array];</span><br><span class="line">        [bucket addObject:array];</span><br><span class="line">    &#125;</span><br><span class="line">    return bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取列表最大值</span><br><span class="line">- (NSNumber *)listMaxItem:(NSArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * maxNumber = array[0];</span><br><span class="line">    for (NSNumber * number in array)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxNumber &lt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNumber = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数字的位数</span><br><span class="line">- (NSInteger)numberLength:(NSNumber *)number</span><br><span class="line">&#123;</span><br><span class="line">    NSString * string = [NSString stringWithFormat:@&quot;%ld&quot;,(long)[number integerValue]];</span><br><span class="line">    return string.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//number 操作的数字  digit 位数  返回该位数上的数字</span><br><span class="line">- (NSInteger)fetchBaseNumber:(NSNumber *)number digit:(NSInteger)digit</span><br><span class="line">&#123;</span><br><span class="line">    //digit为基数位数</span><br><span class="line">    if (digit &gt; 0 &amp;&amp; digit &lt;= [self numberLength:number])</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * numbersArray = [NSMutableArray array];</span><br><span class="line">        NSString * string = [NSString stringWithFormat:@&quot;%ld&quot;,[number integerValue]];</span><br><span class="line">        for (NSInteger index = 0 ; index &lt; [self numberLength:number] ; index ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSString * temp = [string substringWithRange:NSMakeRange(index, 1)];</span><br><span class="line">            [numbersArray addObject:temp];</span><br><span class="line">        &#125;</span><br><span class="line">        NSString * str = numbersArray[numbersArray.count - digit];</span><br><span class="line">        return [str integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考:<a href="https://www.cnblogs.com/ludashi/p/6065086.html" target="_blank" rel="noopener">iOS可视化动态绘制八种排序过程(Swift版)</a></strong></p><p><strong>源码:<a href="https://github.com/iOS-Misaki/SortDemo">SortDemo</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;先看图，这里为了方便展示gif图片，在冒泡排序、选择排序、插入排序，视图更新停留的时间设置为0.001秒，其他排序设置视图更新时间为0.003秒。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SDWebImage 源码浅析</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/11/SDWebImage-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/11/SDWebImage-源码浅析/</id>
    <published>2018-04-11T03:49:26.000Z</published>
    <updated>2018-07-27T06:39:51.109Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在iOS的图片加载框架中，SDWebImage可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件。在项目中使用SDWebImage来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。本篇文章会着重讲解<code>SDImageCache</code>、<code>SDWebImageDownloader</code>这两个类。<br><a id="more"></a></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-7bd27225e029042f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage类图.png"></p><h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>&ensp;&ensp;&ensp;&ensp;在<code>SDWebImage</code>中，图片的下载是由<code>SDWebImageDownloader</code>完成的。<code>SDWebImageDownloader</code>是个单例，先来看下载选项，<code>SDWebImageDownloaderOptions</code>枚举。主要涉及到下载的优先级、缓存、后台执行、<code>cookies</code>这些方面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 默认请求不使用缓存</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 如果冲缓存中读取图片，使用nil来传参完成block</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    /**</span><br><span class="line">    * 在iOS 4.0以上的系统可以后台下载</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 可以自定义下载的cookies</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 允许不受信任的SSL证书</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * 图片下载放在高优先级</span><br><span class="line">    */</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>下载顺序也定义了一个枚举，默认的是队列的方式，先进先出，另一种是先进后出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>图片下载是在<code>NSOperationQueue</code>队列中完成的，默认队列的最大并发数6。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</span><br></pre></td></tr></table></figure></p><p>下载图片的操作对应一些回调，进度条的回调，下载完成的回调，<code>header</code>过滤等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"></span><br><span class="line">typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"></span><br><span class="line">typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) NSMutableDictionary *URLCallbacks;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;&ensp;&ensp;在下载器的<code>URLCallbacks</code>属性中，是个可变字典，<code>key</code>是图片的<code>url</code>,<code>value</code>是个数组，存放每张图片的多组回调信息。由于允许多个图片同时下载，所以会有多个线程同时操作<code>URLCallbacks</code>，所以把这下操作都放在<code>GCD</code>的栅栏队列中，隔离开来，避免线程的不安全性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback </span><br><span class="line">&#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) </span><br><span class="line">    &#123;</span><br><span class="line">        if (completedBlock != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first = NO;</span><br><span class="line">        if (!self.URLCallbacks[url]) </span><br><span class="line">        &#123;</span><br><span class="line">            self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">            first = YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Handle single download of simultaneous download request for the same URL</span><br><span class="line">        NSMutableArray *callbacksForURL = self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        if (first) </span><br><span class="line">        &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;图片下载器下载的时候放在<code>downloadImageWithURL:options:progress:completed:</code>方法来处理的，里面调用刚才提到的方法，把请求的信息存入管理器中，同时在创建回调的<code>block</code>中创建新的操作，配置后放入<code>downloadQueue</code>的操作队列中，最后方法返回新创建的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock </span><br><span class="line">&#123;</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __weak __typeof(self)wself = self;</span><br><span class="line"></span><br><span class="line">    [self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) </span><br><span class="line">        &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 创建请求对象，根据options参数设置属性</span><br><span class="line">        // 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        if (wself.headersFilter) </span><br><span class="line">        &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建SDWebImageDownloaderOperation，配置参数，包括是否需要认证、优先级</span><br><span class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                          options:options</span><br><span class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line"></span><br><span class="line">                                                        //从管理器的callbacksForURL中找出URL所有的进度处理回调并调用</span><br><span class="line">                                                        SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                        if (!sself) return;</span><br><span class="line">                                                        __block NSArray *callbacksForURL;</span><br><span class="line">                                                        dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                            callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                        &#125;);</span><br><span class="line">                                                        </span><br><span class="line">                                                        for (NSDictionary *callbacks in callbacksForURL) </span><br><span class="line">                                                        &#123;</span><br><span class="line">                                                            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) </span><br><span class="line">                                                        &#123;</span><br><span class="line">                                                            //从管理器的callbacksForURL中找出该URL所有的进度处理回调并且调用</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            if (!sself) return;</span><br><span class="line">                                                            __block NSArray *callbacksForURL;</span><br><span class="line">                                                            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                                //完成后，将URL对应的回调信息从URLCallbacks中删除</span><br><span class="line">                                                                if (finished) </span><br><span class="line">                                                                &#123;</span><br><span class="line">                                                                    [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                                &#125;</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                            for (NSDictionary *callbacks in callbacksForURL) </span><br><span class="line">                                                            &#123;</span><br><span class="line">                                                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                                if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                        cancelled:^&#123;</span><br><span class="line">                                                            //取消操作将该url对应的回调信息从URLCallbacks中删除</span><br><span class="line">                                                            SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                            if (!sself) return;</span><br><span class="line">                                                            dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                                [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                            &#125;);</span><br><span class="line">                                                        &#125;];</span><br><span class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">        if (wself.username &amp;&amp; wself.password) </span><br><span class="line">        &#123;</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) </span><br><span class="line">        &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (options &amp; SDWebImageDownloaderLowPriority) </span><br><span class="line">        &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将操作加入到操作队列downloadQueue中</span><br><span class="line">        //根据下载枚举的顺序来确定队列的顺序</span><br><span class="line">        [wself.downloadQueue addOperation:operation];</span><br><span class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) </span><br><span class="line">        &#123;</span><br><span class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">            [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">            wself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下载操作<br><code>SDWebImage</code>定义了一个协议<code>SDWebImageOperation</code>，协议只声明了一个<code>cancel</code>方法，用于取消操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)cancel;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p><code>SDWebImageDownloaderOperation</code>在分类中采用了<code>NSURLConnectionDataDelegate</code>协议，并且实现了该协议的一下几个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;</span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</span><br><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection __unused *)connection;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</span><br></pre></td></tr></table></figure></p><p>重点来看<code>didReceiveData</code>方法，主要任务是接收数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 附加数据</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line"></span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        // 获取已下载数据总大小</span><br><span class="line">        const NSInteger totalSize = self.imageData.length;</span><br><span class="line"></span><br><span class="line">        // 更新数据源 这里要传入所有的数据，而不仅是新数据</span><br><span class="line">        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);</span><br><span class="line"></span><br><span class="line">        // 第一次获取数据时，从这些数据获取图片的长、宽、方向</span><br><span class="line">        if (width + height == 0) </span><br><span class="line">        &#123;</span><br><span class="line">            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);</span><br><span class="line">            if (properties) </span><br><span class="line">            &#123;</span><br><span class="line">                NSInteger orientationValue = -1;</span><br><span class="line">                CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);</span><br><span class="line">                val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;width);</span><br><span class="line">                val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">                CFRelease(properties);</span><br><span class="line"></span><br><span class="line">                // 制到Core Graphics的时候，会丢失方向信息，有时候由initWithCGIImage创建的方向会不对，所以在里面先保存方向信息</span><br><span class="line">                orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //图片还没有下载完成</span><br><span class="line">        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) </span><br><span class="line">        &#123;</span><br><span class="line">            // 使用现有的数据创建图片对象，如果数据中存有多张图片，取第一张</span><br><span class="line"></span><br><span class="line">            #ifdef TARGET_OS_IPHONE</span><br><span class="line">            // iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理</span><br><span class="line">            if (partialImageRef) </span><br><span class="line">            &#123;</span><br><span class="line">                const size_t partialHeight = CGImageGetHeight(partialImageRef);</span><br><span class="line">                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">                CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">                CGColorSpaceRelease(colorSpace);</span><br><span class="line">                if (bmContext) </span><br><span class="line">                &#123;</span><br><span class="line">                    CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef = CGBitmapContextCreateImage(bmContext);</span><br><span class="line">                    CGContextRelease(bmContext);</span><br><span class="line">                &#125;   </span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef = nil;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            #endif</span><br><span class="line"></span><br><span class="line">            //图片的缩放、解码操作</span><br><span class="line">            if (partialImageRef) </span><br><span class="line">            &#123;</span><br><span class="line">                UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];</span><br><span class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                UIImage *scaledImage = [self scaledImageForKey:key image:image];</span><br><span class="line">                if (self.shouldDecompressImages) </span><br><span class="line">                &#123;</span><br><span class="line">                    image = [UIImage decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    image = scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                CGImageRelease(partialImageRef);</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    if (self.completedBlock) </span><br><span class="line">                    &#123;</span><br><span class="line">                        self.completedBlock(image, nil, nil, NO);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CFRelease(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.progressBlock) </span><br><span class="line">    &#123;</span><br><span class="line">        self.progressBlock(self.imageData.length, self.expectedSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SDWebImageDownloaderOperation</code>继承自<code>NSOperation</code>，没有实现<code>main</code>方法。而是采用<code>start</code>方法，方便自己管理下载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)start </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span><br><span class="line">    @synchronized (self) </span><br><span class="line">    &#123;</span><br><span class="line">        if (self.isCancelled) </span><br><span class="line">        &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line"></span><br><span class="line">        //如果设置后台执行，就后台执行</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) </span><br><span class="line">        &#123;</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                if (sself) </span><br><span class="line">                &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        self.executing = YES;</span><br><span class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">        self.thread = [NSThread currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.connection start];</span><br><span class="line"></span><br><span class="line">    if (self.connection) </span><br><span class="line">    &#123;</span><br><span class="line">        if (self.progressBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //主线程抛出下载开始通知</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        //启动run loop</span><br><span class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) </span><br><span class="line">        &#123;</span><br><span class="line">            // Make sure to run the runloop in our background thread so it can process downloaded data</span><br><span class="line">            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br><span class="line">            //       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            CFRunLoopRun();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果未完成，则取消连接</span><br><span class="line">        if (!self.isFinished) </span><br><span class="line">        &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        if (self.completedBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) </span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) </span><br><span class="line">    &#123;</span><br><span class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;下载完成或者下载失败后，需要停止当前线程的<code>run loop</code>，清除连接，并且抛出下载停止的通知。如果下载成功，就会处理完整的图片数据，对图片进行缩放和解压缩操作，提供给完成回调使用。</p><h2 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h2><p>&ensp;&ensp;&ensp;&ensp;缓存的功能由<code>SDImageCache</code>完成，负责处理内存缓存和一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，不会卡死UI。<br>&ensp;&ensp;&ensp;&ensp;在iOS 中内存缓存的是使用<code>NSCache对</code>象来实现的。<code>NSCache</code>和字典类似，存储键值对。磁盘缓存的处理是使用<code>NSFileManager</code>来实现的，图片存储的位置位于<code>Cache</code>文件夹，<code>SDImageCache</code>定义了一个串行队列，来异步存储图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">@interface SDImageCache ()</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSCache *memCache;</span><br><span class="line">@property (strong, nonatomic) NSString *diskCachePath;</span><br><span class="line">@property (strong, nonatomic) NSMutableArray *customPaths;</span><br><span class="line">@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t ioQueue;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (id)initWithNamespace:(NSString *)ns diskCacheDirectory:(NSString *)directory </span><br><span class="line">&#123;</span><br><span class="line">    if ((self = [super init])) </span><br><span class="line">    &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line"></span><br><span class="line">        // initialise PNG signature data</span><br><span class="line">        kPNGSignatureData = [NSData dataWithBytes:kPNGSignatureBytes length:8];</span><br><span class="line"></span><br><span class="line">        // Create IO serial queue</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        // Init default values</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line"></span><br><span class="line">        // Init the memory cache</span><br><span class="line">        _memCache = [[AutoPurgeCache alloc] init];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // Init the disk cache</span><br><span class="line">        if (directory != nil) </span><br><span class="line">        &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Set decompression to YES</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line"></span><br><span class="line">        // memory cache enabled</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line"></span><br><span class="line">        // Disable iCloud</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            _fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        #if TARGET_OS_IPHONE</span><br><span class="line">        // Subscribe to app events</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(clearMemory) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(cleanDisk) name:UIApplicationWillTerminateNotification object:nil];</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundCleanDisk) name:UIApplicationDidEnterBackgroundNotification object:nil];</span><br><span class="line">        </span><br><span class="line">        #endif</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>SDImageCache</code>中提供了很多方法来缓存、获取、移除图片。对于图片，方便操作我们需要一个<code>key</code>来索引它。在内存中，把它设置为<code>NSCache</code>中的<code>key</code>值，在磁盘中，把<code>key</code>作为图片的文件名。这个<code>key</code>就是图片的<code>url</code>。<br>图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，就降磁盘缓存操作作为一个<code>task</code>放到串行队列中处理，在iOS中，会先检测图片是<code>PNG</code>还是<code>JPEG</code>，<br>然后转换为相应的图片数据，最后将数据写入磁盘中，具体实现如下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk </span><br><span class="line">&#123;</span><br><span class="line">    if (!image || !key) </span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 内存缓存，存入NSCache中，同时存入图片的消耗值</span><br><span class="line">    </span><br><span class="line">    if (self.shouldCacheImagesInMemory) </span><br><span class="line">    &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toDisk) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        //如果确定需要磁盘缓存，将缓存操作作为一个任务放入ioQueue中</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            NSData *data = imageData;</span><br><span class="line"></span><br><span class="line">            if (image &amp;&amp; (recalculate || !data)) </span><br><span class="line">            &#123;</span><br><span class="line">                #if TARGET_OS_IPHONE</span><br><span class="line">                // 这里需要确定是PNG还是JPEG，PNG图片容易检测，因为有一个唯一签名。PNG图片的前8个字节总是包含以下值： 137 80 78 71 13 10 26 10</span><br><span class="line">                // 在data为nil的情况下假定图片为PNG，以避免丢失透明度。而当图片有数据时，会检测前缀，确定图片的类型</span><br><span class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);</span><br><span class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone || alphaInfo == kCGImageAlphaNoneSkipFirst ||alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">                BOOL imageIsPng = hasAlpha;</span><br><span class="line"></span><br><span class="line">                // But if we have an image data, we will look at the preffix</span><br><span class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) </span><br><span class="line">                &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (imageIsPng) </span><br><span class="line">                &#123;</span><br><span class="line">                    data = UIImagePNGRepresentation(image);</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">                &#125;</span><br><span class="line">                #else</span><br><span class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</span><br><span class="line">                #endif</span><br><span class="line">            &#125;</span><br><span class="line">            //创建缓存文件并且存储图片</span><br><span class="line">            if (data) </span><br><span class="line">            &#123;</span><br><span class="line">                if (![_fileManager fileExistsAtPath:_diskCachePath]) </span><br><span class="line">                &#123;</span><br><span class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // get cache Path for image key</span><br><span class="line">                NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">                // transform to NSUrl</span><br><span class="line">                NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">                [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</span><br><span class="line"></span><br><span class="line">                // disable iCloud backup</span><br><span class="line">                if (self.shouldDisableiCloud) </span><br><span class="line">                &#123;</span><br><span class="line">                    [fileURL setResourceValue:[NSNumber numberWithBool:YES] forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询图片是通过指定的<code>key</code>来查询。下面分别为内存和磁盘查询<code>key</code>的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;</span><br><span class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p><p>如果只是想查看本地是否存在<code>key</code>指定的图片，不管是在磁盘上还是内存上，可以使用以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock </span><br><span class="line">&#123;</span><br><span class="line">    if (!doneBlock) </span><br><span class="line">    &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!key) </span><br><span class="line">    &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 首先查看内存缓存，如果找到，直接回调doneBlock返回</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) </span><br><span class="line">    &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内存中没有，去磁盘查找，如果找到，将其放到内存缓存中，回调doneBlock返回</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) </span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) </span><br><span class="line">            &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;清理缓存有两个方法。可以分为完全清空和部分清理。完全清空是直接把缓存的文件夹移除，部分清理可以设置参数来移除文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)clearDisk;</span><br><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;部分清理可以设置参数来移除文件，主要有两个指标：文件的缓存有效期和最大缓存空间大小，缓存的有效期通过<code>maxCacheAge</code>设置，默认<br>一周时间。如果文件的的缓存时间超过这个时间值，则将其移除。最大缓存空间通过<code>maxCacheSize</code>属性设置，如果所有缓存文件的总大小超过<br>这个大小，会按照文件最后修改的时间的逆序，每次一半的递归来移除过早的文件，一直到缓存的实际大小小于设置的最大使用空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock </span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line">        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        // 枚举器先获取缓存文件的有用属性</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL];</span><br><span class="line"></span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</span><br><span class="line">        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        // 枚举缓存文件中所有的文件夹，移除比过期日期更早的文件，还有存储文件属性方便后面执行基于缓存大小的清理操作</span><br><span class="line">        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) </span><br><span class="line">        &#123;</span><br><span class="line">            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];</span><br><span class="line"></span><br><span class="line">            // 跳过文件夹</span><br><span class="line">            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) </span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 移除早于过期日期的文件</span><br><span class="line">            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) </span><br><span class="line">            &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 计算存储文件的总大小</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) </span><br><span class="line">        &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果磁盘缓存的大小大于配置值，则执行基于文件大小的清理，首先删除最早的文件</span><br><span class="line">        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) </span><br><span class="line">        &#123;</span><br><span class="line">            // 递归设置最大缓存的一半作为清理目标</span><br><span class="line">            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">            // 按照最后修改时间来排序剩下的缓存文件</span><br><span class="line">            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) </span><br><span class="line">            &#123;</span><br><span class="line">                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            // 删除文件知道满足期望值</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) </span><br><span class="line">            &#123;</span><br><span class="line">                if ([_fileManager removeItemAtURL:fileURL error:nil]) </span><br><span class="line">                &#123;</span><br><span class="line">                    NSDictionary *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) </span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (completionBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;在实际使用中，不会直接使用<code>SDWebImageDownloader</code>和<code>SDImageCache</code>来执行图片的下载和缓存，<code>SDWebImage</code>提供了<code>SDWebImageManager</code>来管理图片的<br>下载和缓存，这个对象的<code>delegate</code>声明了两个可选的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic, readwrite) SDImageCache *imageCache;</span><br><span class="line">@property (strong, nonatomic, readwrite) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line">@protocol SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">//控制当图片在缓存中没有找到时，应该下载哪个图片</span><br><span class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">//图片下载完成时，且被缓存到内存或者磁盘前立即转换</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure></p><p>来看看这两个方法怎么调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageOptions)options progress (SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionWithFinishedBlock)completedBlock </span><br><span class="line">&#123;</span><br><span class="line">    // 判断url的合法性</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) </span><br><span class="line">    &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    </span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) </span><br><span class="line">    &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建SDWebImageCombinedOperation对象</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    //判断是否下载失败过</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //空URL或者在不可重试情况下且是个下载失败过的URL ，直接返回操作</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) </span><br><span class="line">    &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //下载</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) </span><br><span class="line">    &#123;</span><br><span class="line">        if (operation.isCancelled) </span><br><span class="line">        &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]))</span><br><span class="line">        &#123;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) </span><br><span class="line">            &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) </span><br><span class="line">            &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) </span><br><span class="line">            &#123;</span><br><span class="line">                if (weakOperation.isCancelled) </span><br><span class="line">                &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) </span><br><span class="line">                &#123;</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        if (!weakOperation.isCancelled) </span><br><span class="line">                        &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    if (error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) </span><br><span class="line">                    &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else </span><br><span class="line">                &#123;</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) </span><br><span class="line">                    &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) </span><br><span class="line">                    &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            if (transformedImage &amp;&amp; finished) </span><br><span class="line">                            &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (!weakOperation.isCancelled) </span><br><span class="line">                                &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else </span><br><span class="line">                    &#123;</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) </span><br><span class="line">                        &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (!weakOperation.isCancelled) </span><br><span class="line">                            &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) </span><br><span class="line">                &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:operation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">    </span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line"></span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    [self.runningOperations removeObject:weakOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) </span><br><span class="line">        &#123;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) </span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) </span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="用到的知识点"><a href="#用到的知识点" class="headerlink" title="用到的知识点"></a>用到的知识点</h2><p><code>SDWebImage</code>的主要功能是图片的下载和缓存，用到了知识点非常多</p><ul><li><code>GCD</code>的<code>dispatch_barrier_sync</code>函数，这个我在<a href="https://www.jianshu.com/p/32f7d4cb051c" target="_blank" rel="noopener">GCD的使用（三）</a>中说明过。</li><li><code>NSOperationQueue</code>队列操作，<code>NSOperationQueue</code>是基于<code>GCD</code>来实现的，对<code>SDWebImage</code>中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。</li><li><code>NSURLConnection</code>网络请求。</li><li><code>NSCache</code>:类似于集合的容器，存储键值对。</li><li>清理缓存策略，设置过期日期和最大缓存空间大小。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在iOS的图片加载框架中，SDWebImage可谓是占据大半壁江山。它支持从网络中下载且缓存图片，并设置图片到对应的UIImageView控件或者UIButton控件。在项目中使用SDWebImage来管理图片加载相关操作可以极大地提高开发效率，让我们更加专注于业务逻辑实现。本篇文章会着重讲解&lt;code&gt;SDImageCache&lt;/code&gt;、&lt;code&gt;SDWebImageDownloader&lt;/code&gt;这两个类。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtime的常见用法</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/01/08/Runtime%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/01/08/Runtime的常见用法/</id>
    <published>2018-01-08T08:46:19.000Z</published>
    <updated>2018-10-26T09:29:46.022Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;这半年，原生iOS基本上没有开发任务，都是一些无关紧要的迭代。大部分开发时间放在了前端<code>Angular</code>项目上，现在的前端水平也仅仅是，依葫芦画瓢，刚好完成开发任务而已。iOS的基础东西虽然说没有丢，但是一直没有往更深的方向去专研，<code>Swift</code>也是刚好会用，没有深究。温水煮青蛙，和刚进公司的那一会比，心态差距很大。今天把一些基础性的东西<code>Runtime</code>，重拾一下吧。</p><a id="more"></a><h2 id="Runtime-给category添加属性"><a href="#Runtime-给category添加属性" class="headerlink" title="Runtime 给category添加属性"></a>Runtime 给category添加属性</h2><p>&ensp;&ensp;<code>category</code>和继承，有相似的功能。继承既能添加方法，也能添加成员变量。继承是子类继承自父类，子类中增加的方法不会成为父类的一部分。<code>category</code>可以在不知道类源码的情况下，为类添加新方法，不能添加成员变量，但是可以用过<code>Runtime</code>来实现。以前项目中很多通用的属性都用继承实现，但是不太好维护（安慰自己罢了☺，两年了，一直都是自己一个人维护项目），改成<code>category</code>来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString * fileName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIViewController+Extension.h&quot;</span><br><span class="line"></span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Extension)</span><br><span class="line"></span><br><span class="line">//getter</span><br><span class="line">- (void)setFileName:(NSString *)fileName</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(fileName), fileName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//setter</span><br><span class="line">- (NSString *)fileName</span><br><span class="line">&#123;</span><br><span class="line">    NSString * _fileName = objc_getAssociatedObject(self, @selector(fileName));</span><br><span class="line">    if (!_fileName)</span><br><span class="line">    &#123;</span><br><span class="line">        _fileName = @&quot;xx.mp3&quot;;</span><br><span class="line">        objc_setAssociatedObject(self, @selector(fileName), _fileName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    return _fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Runtime-方法交换"><a href="#Runtime-方法交换" class="headerlink" title="Runtime 方法交换"></a>Runtime 方法交换</h2><p>&ensp;&ensp;这个其实很多地方都用到了，比如用<code>NullSafe</code>来避免遇到<code>null</code>崩溃等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    //类加载时调用，确保只执行一次</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        //原始方法 这里只是举例，viewWillAppear</span><br><span class="line">        Method originalM = class_getClassMethod([self class], @selector(viewWillAppear:));</span><br><span class="line"></span><br><span class="line">        //自定义方法</span><br><span class="line">        Method customM = class_getClassMethod(self, @selector(yy_viewVillAppear:));</span><br><span class="line"></span><br><span class="line">        //交换</span><br><span class="line">        method_exchangeImplementations(originalM, customM);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)yy_viewVillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    //这里已经替换了方法viewWillAppear，所以不是递归调用</span><br><span class="line">    [self yy_viewVillAppear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Runtime-给Model赋值"><a href="#Runtime-给Model赋值" class="headerlink" title="Runtime 给Model赋值"></a>Runtime 给Model赋值</h2><h3 id="字典的Key和Model的属性名称相同"><a href="#字典的Key和Model的属性名称相同" class="headerlink" title="字典的Key和Model的属性名称相同"></a>字典的Key和Model的属性名称相同</h3><h4 id="新建基类BaseModel"><a href="#新建基类BaseModel" class="headerlink" title="新建基类BaseModel"></a>新建基类BaseModel</h4><p>&ensp;&ensp;继承NSObject，里面写一些公共方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BaseModel.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation BaseModel</span><br><span class="line"></span><br><span class="line">#pragma mark - 通过字符串创建字符串的setter方法，并返回</span><br><span class="line">- (SEL)creatSetterWithPropertyName:(NSString *)properyName</span><br><span class="line">&#123;</span><br><span class="line">    //首字母大写</span><br><span class="line">    properyName = properyName.capitalizedString;</span><br><span class="line"></span><br><span class="line">    properyName = [NSString stringWithFormat:@&quot;set%@:&quot;,properyName];</span><br><span class="line"></span><br><span class="line">    return NSSelectorFromString(properyName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 把字典中的value赋值给实体类的属性</span><br><span class="line">- (void)assignToPropertyWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    if (dictionary == nil)</span><br><span class="line">    &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray * keyArray = [dictionary allKeys];</span><br><span class="line"></span><br><span class="line">    //循环遍历字典的key,动态生成实体类的setter方法，然后把字典的value通过setter方法赋值给实体类的属性</span><br><span class="line">    for (int i = 0 ; i &lt; keyArray.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        //获取实体类的setter方法</span><br><span class="line">        SEL setSel = [self creatSetterWithPropertyName:keyArray[i]];</span><br><span class="line"></span><br><span class="line">        if ([self respondsToSelector:setSel])</span><br><span class="line">        &#123;</span><br><span class="line">            //获取字典中key对应的value</span><br><span class="line">            NSString * value = [NSString stringWithFormat:@&quot;%@&quot;,dictionary[keyArray[i]]];</span><br><span class="line"></span><br><span class="line">            //把value通过setter方法赋值给实体类的属性</span><br><span class="line">            [self performSelectorOnMainThread:setSel withObject:value waitUntilDone:[NSThread isMainThread]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;然后给实体类提供初始化方法和构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 实例方法</span><br><span class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        [self assignToPropertyWithDictionary:dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 类方法返回一个实例</span><br><span class="line">+ (instancetype)initWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    return [[self alloc] initWithDictionary:dictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="实例girlModel-继承自BaseModel"><a href="#实例girlModel-继承自BaseModel" class="headerlink" title="实例girlModel,继承自BaseModel"></a>实例girlModel,继承自BaseModel</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;BaseModel.h&quot;</span><br><span class="line"></span><br><span class="line">@interface girlModel : BaseModel</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString * girl0;</span><br><span class="line">@property (nonatomic,copy) NSString * girl1;</span><br><span class="line">@property (nonatomic,copy) NSString * girl2;</span><br><span class="line">@property (nonatomic,copy) NSString * girl3;</span><br><span class="line">@property (nonatomic,copy) NSString * girl4;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="创建字典给model赋值"><a href="#创建字典给model赋值" class="headerlink" title="创建字典给model赋值"></a>创建字典给model赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary * dic = [[NSMutableDictionary alloc]initWithCapacity:11];</span><br><span class="line">for (int i = 0 ; i &lt; 5 ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    NSString * key = [NSString stringWithFormat:@&quot;girl%d&quot;,i];</span><br><span class="line">    NSString * value = [NSString stringWithFormat:@&quot;我是第%d个女孩&quot;,i];</span><br><span class="line">    [dic setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">girlModel * model1 = [girlModel initWithDictionary:dic];</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl0);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl1);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl2);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl3);</span><br><span class="line">NSLog(@&quot;%@&quot;,model1.girl4);</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;或者用setValuesForKeysWithDictionary来验证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">girlModel * model2 = [girlModel new];</span><br><span class="line">[model2 setValuesForKeysWithDictionary:dic];</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl0);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl1);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl2);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl3);</span><br><span class="line">NSLog(@&quot;%@&quot;,model2.girl4);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;上面的方法适用与字典中的key 和model属性名一一对应的情况。下面会给出如何去遍历Model中属性的值，并且给出字典的Key和Model的属性名<strong>不一样</strong>的情况我们该如何赋值。</p><h3 id="字典的Key和Model的属性名称不同"><a href="#字典的Key和Model的属性名称不同" class="headerlink" title="字典的Key和Model的属性名称不同"></a>字典的Key和Model的属性名称不同</h3><h4 id="获取Model的实体属性"><a href="#获取Model的实体属性" class="headerlink" title="获取Model的实体属性"></a>获取Model的实体属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 通过runtime来获取model中所有属性的名称</span><br><span class="line">- (NSArray *)allPropertNames</span><br><span class="line">&#123;</span><br><span class="line">    //存储所有的属性名称</span><br><span class="line">    NSMutableArray * allNames = [[NSMutableArray alloc]init];</span><br><span class="line"></span><br><span class="line">    //存储属性的个数</span><br><span class="line">    unsigned int propertyCount = 0;</span><br><span class="line"></span><br><span class="line">    //通过运行时获取当前类的属性</span><br><span class="line">    objc_property_t * propertys = class_copyPropertyList([self class], &amp;propertyCount);</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; propertyCount ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        objc_property_t property = propertys[i];</span><br><span class="line">        const char * propertName = property_getName(property);</span><br><span class="line">        [allNames addObject:[NSString stringWithUTF8String:propertName]];</span><br><span class="line">    &#125;</span><br><span class="line">    //释放</span><br><span class="line">    free(propertys);</span><br><span class="line"></span><br><span class="line">    return allNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 通过字符串来创建改字符串的setter方法，并返回</span><br><span class="line">- (SEL)creatGetterWithPropertyName:(NSString *)propertyName</span><br><span class="line">&#123;</span><br><span class="line">    //OC中getter方法就是属性本身</span><br><span class="line">    return NSSelectorFromString(propertyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Model的属性动态的执行getter方法"><a href="#Model的属性动态的执行getter方法" class="headerlink" title="Model的属性动态的执行getter方法"></a>Model的属性动态的执行getter方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)displayCurrentModelPropert</span><br><span class="line">&#123;</span><br><span class="line">    //获取实体类的属性名</span><br><span class="line">    NSArray * array = [self allPropertNames];</span><br><span class="line"></span><br><span class="line">    NSMutableString * resultString = [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        SEL getSel = [self creatGetterWithPropertyName:array[i]];</span><br><span class="line"></span><br><span class="line">        if ([self respondsToSelector:getSel])</span><br><span class="line">        &#123;</span><br><span class="line">            //获得类和方法的签名</span><br><span class="line">            NSMethodSignature * signature = [self methodSignatureForSelector:getSel];</span><br><span class="line"></span><br><span class="line">            //从签名获取调用对象</span><br><span class="line">            NSInvocation * invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line"></span><br><span class="line">            //设置target 和 selector</span><br><span class="line">            [invocation setTarget:self];</span><br><span class="line"></span><br><span class="line">            [invocation setSelector:getSel];</span><br><span class="line"></span><br><span class="line">            NSObject * __unsafe_unretained returnValue = nil;</span><br><span class="line"></span><br><span class="line">            [invocation invoke];</span><br><span class="line"></span><br><span class="line">            [invocation getReturnValue:&amp;returnValue];</span><br><span class="line"></span><br><span class="line">            [resultString appendFormat:@&quot;%@\n&quot;,returnValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;,resultString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;下面来验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[model1 displayCurrentModelPropert];</span><br></pre></td></tr></table></figure></p><p>输出结果<br><img src="http://upload-images.jianshu.io/upload_images/1487718-bb56ac83763e1a5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-17 下午8.56.45.png"></p><p>&ensp;&ensp;<strong>当字典的key和model中属性不一样，我们就需要用一个映射来维护。基类中添加一个返回映射字典的一个方法，然后在子类中进行重写，这个映射方法在基类中返回nil, 如果子类需要重写的话就对这个方法进行重写并返回映射字典</strong>。</p><h4 id="构建映射关系"><a href="#构建映射关系" class="headerlink" title="构建映射关系"></a>构建映射关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 构建映射关系</span><br><span class="line">- (NSDictionary *)propertMap</span><br><span class="line">&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;修改一下初始化方法，在有映射字典的情况和没有映射字典的情况下调用的方法是不一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 实例方法</span><br><span class="line">- (instancetype)initWithDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([self propertMap] == nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self assignToPropertyWithDictionary:dictionary];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self assignToPropertyWithNoMapDictionary:dictionary];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)assignToPropertyWithNoMapDictionary:(NSDictionary *)dictionary</span><br><span class="line">&#123;</span><br><span class="line">    //获取字典和model属性的映射关系</span><br><span class="line">    NSDictionary * propertyMapDictionary = [self propertMap];</span><br><span class="line"></span><br><span class="line">    NSArray * dicKeyArray = [dictionary allKeys];</span><br><span class="line"></span><br><span class="line">    NSMutableDictionary * tempDic = [[NSMutableDictionary alloc]initWithCapacity:dicKeyArray.count];</span><br><span class="line"></span><br><span class="line">    for (int i = 0 ; i &lt; dicKeyArray.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSString * key = dicKeyArray[i];</span><br><span class="line">        [tempDic setObject:dictionary[key] forKey:propertyMapDictionary[key]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self assignToPropertyWithDictionary:tempDic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;下面新建一个boyMdoel继承BaseModel，并且重写映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,copy) NSString * boy0;</span><br><span class="line">@property (nonatomic,copy) NSString * boy1;</span><br><span class="line">@property (nonatomic,copy) NSString * boy2;</span><br><span class="line">@property (nonatomic,copy) NSString * boy3;</span><br><span class="line">@property (nonatomic,copy) NSString * boy4;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)propertMap</span><br><span class="line">&#123;</span><br><span class="line">    return @&#123;@&quot;key0&quot;:@&quot;boy0&quot;,</span><br><span class="line">             @&quot;key1&quot;:@&quot;boy1&quot;,</span><br><span class="line">             @&quot;key2&quot;:@&quot;boy2&quot;,</span><br><span class="line">             @&quot;key3&quot;:@&quot;boy3&quot;,</span><br><span class="line">             @&quot;key4&quot;:@&quot;boy4&quot;,&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;然后生成数据验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary * dic1 = [[NSMutableDictionary alloc]initWithCapacity:5];</span><br><span class="line">for (int i = 0 ; i &lt; 5 ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    NSString * key = [NSString stringWithFormat:@&quot;key%d&quot;,i];</span><br><span class="line">    NSString * value = [NSString stringWithFormat:@&quot;我是第%d个男孩&quot;,i];</span><br><span class="line">    [dic1 setObject:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line">boyModel * model3 = [boyModel initWithDictionary:dic1];</span><br><span class="line">[model3 displayCurrentModelPropert];</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1487718-4c39b491400e4cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-01-17 下午9.21.47.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;这半年，原生iOS基本上没有开发任务，都是一些无关紧要的迭代。大部分开发时间放在了前端&lt;code&gt;Angular&lt;/code&gt;项目上，现在的前端水平也仅仅是，依葫芦画瓢，刚好完成开发任务而已。iOS的基础东西虽然说没有丢，但是一直没有往更深的方向去专研，&lt;code&gt;Swift&lt;/code&gt;也是刚好会用，没有深究。温水煮青蛙，和刚进公司的那一会比，心态差距很大。今天把一些基础性的东西&lt;code&gt;Runtime&lt;/code&gt;，重拾一下吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
