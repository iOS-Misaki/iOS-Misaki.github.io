<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Misaki的小站</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/iOS-Misaki.github.io/atom.xml" rel="self"/>
  
  <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/"/>
  <updated>2018-07-26T14:58:08.355Z</updated>
  <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/</id>
  
  <author>
    <name>Misaki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAAnimation 系列动画</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/26/CAAnimation%20%E7%B3%BB%E5%88%97%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/26/CAAnimation 系列动画/</id>
    <published>2018-07-26T02:20:39.000Z</published>
    <updated>2018-07-26T14:58:08.355Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;有人问我为什么要写博客，必须要承认，现在网上一大推的优秀教程和现成的Demo，自己写的没有别人好，有些地方根本不够深入，但是看别人写文章、写代码和自己写完全是两件事，代码看看就能懂，但是自己过一遍，印象更深，消化的也就更彻底。对于iOS动画 ，一直都没有系统化的学习，只有用的时候才会查查api，之前写过一篇<a href="https://www.jianshu.com/p/92ac22afeeef" target="_blank" rel="noopener">红包雨</a>的文章，用的是关键帧动画，没有在继续下去。另一个就是在6月份面试的时候，有两个面试官都问到了基础动画，当时也回答的不好，现在详细地梳理一遍。现阶段，先把<code>Core Animation</code>弄清楚，以后再下沉到<code>OpenGL</code>和<code>CoreGraphics</code>。</p><a id="more"></a><h2 id="CAAnimation继承关系"><a href="#CAAnimation继承关系" class="headerlink" title="CAAnimation继承关系"></a>CAAnimation继承关系</h2><p>&ensp;&ensp;&ensp;&ensp;引用官方文档：</p><blockquote><p>Core Animation provides high frame rates and smooth animations without burdening the CPU and slowing down your app. Most of the work required to draw each frame of an animation is done for you. You configure animation parameters such as the start and end points, and Core Animation does the rest, handing off most of the work to dedicated graphics hardware, to accelerate rendering. For more details, see <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="noopener">Core Animation Programming Guide</a>.</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;<code>Core Animation</code>提供了高帧率和流畅的动画，而不会加重CPU负担，也不会减慢应用程序的速度。你可以配置动画参数，如起始点和结束点，<code>Core animation</code>完成其余部分，将大部分工作交给专用的图形硬件，以加速渲染。</p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-98d399ad7b624a91.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CAAnimation类图.jpg"></p><p>&ensp;&ensp;&ensp;&ensp;对于<code>CAAnimation</code>,是核心动画基础类，不直接使用，一般用它的子类。<code>CAAnimation</code>有三个子类<code>CAPropertyAnimation、CATransition、CAAnimationGroup</code>。第二个<code>CATransition</code>是转场动画，第三个<code>CAAnimationGroup</code>是动画组。第一个<code>CAPropertyAnimation</code>又分为两个子类<code>CABasicAnimation、CAKeyframeAnimation</code>。<code>CAKeyframeAnimation</code>是关键帧动画。<code>CABasicAnimation</code>下面还有个子类<code>CASpringAnimation</code>是弹簧动画。</p><p>&ensp;&ensp;&ensp;&ensp;<code>CAPropertyAnimation</code>通过<code>animationWithKeyPath</code>来创建动画，可以看看有哪些属性可以创建动画。详见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/AnimatableProperties/AnimatableProperties.html#//apple_ref/doc/uid/TP40004514-CH11-SW2" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">anchorPoint</span><br><span class="line">backgroundColor</span><br><span class="line">backgroundFilters</span><br><span class="line">borderColor</span><br><span class="line">borderWidth</span><br><span class="line">bounds</span><br><span class="line">compositingFilter</span><br><span class="line">contents</span><br><span class="line">contentsRect</span><br><span class="line">cornerRadius</span><br><span class="line">doubleSided</span><br><span class="line">filters</span><br><span class="line">frame</span><br><span class="line">hidden</span><br><span class="line">mask</span><br><span class="line">masksToBounds</span><br><span class="line">opacity</span><br><span class="line">position</span><br><span class="line">shadowColor</span><br><span class="line">shadowOffset</span><br><span class="line">shadowOpacity</span><br><span class="line">shadowPath</span><br><span class="line">shadowRadius</span><br><span class="line">sublayers</span><br><span class="line">sublayerTransform</span><br><span class="line">transform</span><br><span class="line">zPosition</span><br></pre></td></tr></table></figure><hr><h2 id="CAKeyframeAnimation-关键帧动画"><a href="#CAKeyframeAnimation-关键帧动画" class="headerlink" title="CAKeyframeAnimation 关键帧动画"></a>CAKeyframeAnimation 关键帧动画</h2><p>&ensp;&ensp;&ensp;&ensp;可以使用继承的<code>animationWithKeyPath:</code>方法创建一个<code>CAKeyframeAnimation</code>对象，并指定要在层上动画的属性的关键路径。然后可以指定用于控制时间和动画行为的关键帧值。对于大多数动画类型，可以使用值和<code>keyTimes</code>属性指定关键帧值。在动画期间，<code>Core animation</code>通过在您提供的值之间插入来生成中间值。当动画一个坐标点(例如layer的位置)的值时，你可以指定该点的路径，而不是单独的值。动画的节奏由你提供的时间信息控制。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>values</td><td style="text-align:center">用来存放关键帧的数组</td></tr><tr><td>path</td><td style="text-align:center">基于点的属性的路径。</td></tr><tr><td>keyTimes</td><td style="text-align:center">对应关键帧段的时间点的NSNumber数组</td></tr><tr><td>timingFunctions</td><td style="text-align:center">关键帧动画节奏的数组，比如快进慢出、慢进快出等</td></tr><tr><td>calculationMode</td><td style="text-align:center">确定沿路径动画的对象是否旋转以匹配路径切线</td></tr><tr><td>tensionValues</td><td style="text-align:center">定义曲线的紧密性的NSNumber数组</td></tr><tr><td>continuityValues</td><td style="text-align:center">定义时间曲线锐角的NSNumber数组</td></tr><tr><td>biasValues</td><td style="text-align:center">定义曲线相对于控制点的位置的NSNumber数组</td></tr><tr><td>Rotation Mode Values</td><td style="text-align:center">rotationMode属性使用这些常量</td></tr><tr><td>Value calculation modes</td><td style="text-align:center">calculationMode属性使用这些常量</td></tr></tbody></table><h3 id="效果代码"><a href="#效果代码" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 指定keyPath为position，通过Values来创建关键帧动画</span><br><span class="line">- (void)CAKeyframeAnimationWithValues</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat margin = 50.f;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animation];</span><br><span class="line">    animation.keyPath = @&quot;position&quot;;</span><br><span class="line">    NSValue * value0 = [NSValue valueWithCGPoint:CGPointMake(margin, margin)];</span><br><span class="line">    NSValue * value1 = [NSValue valueWithCGPoint:CGPointMake(margin, SCREENHEIGHT - margin)];</span><br><span class="line">    NSValue * value2 = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH - margin, SCREENHEIGHT - margin)];</span><br><span class="line">    NSValue * value3 = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH - margin, margin)];</span><br><span class="line">    NSValue * value4 = [NSValue valueWithCGPoint:CGPointMake(margin, margin)];</span><br><span class="line">    animation.values = @[value0,value1,value2,value3,value4];</span><br><span class="line"></span><br><span class="line">    //当我们动画完成时,如果希望动画就自动移除的话,我们可以设置此属性为YES,默认值为YES</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.duration = 4;</span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    //快入快出</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.pointView.layer addAnimation:animation forKey:@&quot;position.values&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 指定keyPath为position，通过path路径来创建关键帧动画</span><br><span class="line">- (void)CAKeyframeAnimationWithPath</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat margin = 50.f;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * animation = [CAKeyframeAnimation animation];</span><br><span class="line">    animation.keyPath = @&quot;position&quot;;</span><br><span class="line"></span><br><span class="line">    CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">    CGPathAddRect(path, NULL, CGRectMake(margin, margin, SCREENWIDTH - margin * 2, SCREENHEIGHT - margin * 2));</span><br><span class="line">    animation.path = path;</span><br><span class="line">    CGPathRelease(path);</span><br><span class="line"></span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.duration = 4;</span><br><span class="line">    animation.repeatCount = MAXFLOAT;</span><br><span class="line">    NSMutableArray * timingFunctionArray = [NSMutableArray new];</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; 5 ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        //每一段都是快出效果</span><br><span class="line">        CAMediaTimingFunction * timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];</span><br><span class="line">        [timingFunctionArray addObject:timingFunction];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    animation.timingFunctions = timingFunctionArray;</span><br><span class="line">    [self.pointView.layer addAnimation:animation forKey:@&quot;position.path&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-9916176ef3035803.gif?imageMogr2/auto-orient/strip" alt="CAKeyframeAnimation.gif"></p><p>&ensp;&ensp;&ensp;&ensp;需要注意的是removedOnCompletion设置为NO的时候，不需要layer的时候要根据key手动移除动画。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[self.pointView.layer removeAnimationForKey:@&quot;position.values&quot;];</span><br><span class="line">[self.pointView.layer removeAnimationForKey:@&quot;position.path&quot;];</span><br></pre></td></tr></table></figure></p><hr><h2 id="CATransition-转场动画"><a href="#CATransition-转场动画" class="headerlink" title="CATransition 转场动画"></a>CATransition 转场动画</h2><p>&ensp;&ensp;&ensp;&ensp;<code>CATransition</code>的父类是<code>CAAnimation</code>，和<code>CAPropertyAnimation</code>、<code>CAAnimationGroup</code>同级。<code>CATransition</code>是用来视图的转场动画。</p><blockquote><p>You can transition between a layer’s states by creating and adding a <a href="apple-reference-documentation://hckyNQAwLg" target="_blank" rel="noopener">CATransition</a> object to it. The default transition is a cross fade, but you can specify different effects from a set of predefined transitions.</p></blockquote><h3 id="重要属性-1"><a href="#重要属性-1" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>startProgress</td><td style="text-align:center">整个变形接收的起点</td></tr><tr><td>endProgress</td><td style="text-align:center">整个变形接收的终点</td></tr><tr><td>type</td><td style="text-align:center">指定转换类型</td></tr><tr><td>subtype</td><td style="text-align:center">转换方向的子类型</td></tr><tr><td>filter</td><td style="text-align:center">提供转换的图像过滤器对象</td></tr><tr><td>Common Transition Types</td><td style="text-align:center">指定可以与type属性一起使用的转换类型的常量</td></tr><tr><td>Common Transition Subtypes</td><td style="text-align:center">指定可以与subtype属性一起使用的转换类型的常量</td></tr></tbody></table><h3 id="效果代码-1"><a href="#效果代码-1" class="headerlink" title="效果代码"></a>效果代码</h3><p>&ensp;&ensp;&ensp;&ensp;其中<code>type</code>和<code>subtype</code>有官方指定的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Common transition types. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN NSString * const kCATransitionFade</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionMoveIn</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionPush</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionReveal</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line"></span><br><span class="line">/* Common transition subtypes. */</span><br><span class="line"></span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromRight</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromLeft</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromTop</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br><span class="line">CA_EXTERN NSString * const kCATransitionFromBottom</span><br><span class="line">CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;还有几种效果是私有API，在官方文档中找不到，<strong>慎用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cube,                     //立体</span><br><span class="line">SuckEffect,               //吮吸</span><br><span class="line">OglFlip,                  //翻转</span><br><span class="line">RippleEffect,             //波纹</span><br><span class="line">PageCurl,                 //翻页</span><br><span class="line">PageUnCurl,               //反翻页</span><br><span class="line">CameraIrisHollowOpen,     //开镜头</span><br><span class="line">CameraIrisHollowClose,    //关镜头</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;这里写了一个例子，有12种<code>type</code>转场效果和4种<code>subtype</code>转场方向，用枚举来封装一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger,CATransactionType) &#123;</span><br><span class="line">    CATransactionType_Fade = 0,                 //默认</span><br><span class="line">    CATransactionType_MoveIn,                   //覆盖</span><br><span class="line">    CATransactionType_Push,                     //推入</span><br><span class="line">    CATransactionType_Reveal,                   //揭开</span><br><span class="line"></span><br><span class="line">    CATransactionType_Cube,                     //立体</span><br><span class="line">    CATransactionType_SuckEffect,               //吮吸</span><br><span class="line">    CATransactionType_OglFlip,                  //翻转</span><br><span class="line">    CATransactionType_RippleEffect,             //波纹</span><br><span class="line">    CATransactionType_PageCurl,                 //翻页</span><br><span class="line">    CATransactionType_PageUnCurl,               //反翻页</span><br><span class="line">    CATransactionType_CameraIrisHollowOpen,     //开镜头</span><br><span class="line">    CATransactionType_CameraIrisHollowClose,    //关镜头</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (void)CATransitionWithType:(NSString *)type WithSubtype:(NSString *)subtype</span><br><span class="line">&#123;</span><br><span class="line">    CATransition * animation = [CATransition animation];</span><br><span class="line">    animation.duration = 2.f;</span><br><span class="line">    animation.type = type;</span><br><span class="line">    animation.subtype = subtype;</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.view.layer addAnimation:animation forKey:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)btnClick:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    UIButton * lastBtn;</span><br><span class="line">    NSInteger index = sender.tag - 100;</span><br><span class="line">    if (index &gt; 11)</span><br><span class="line">    &#123;</span><br><span class="line">        lastBtn = (UIButton *)[self.view viewWithTag:_subtype + 100];</span><br><span class="line">        [lastBtn setBackgroundImage:[self createImageWithColor:self.subtypeNormalColor] forState:UIControlStateNormal];</span><br><span class="line">        [sender setBackgroundImage:[self createImageWithColor:self.subtypeSelectedColor] forState:UIControlStateNormal];</span><br><span class="line">        _subtype = index;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        lastBtn = (UIButton *)[self.view viewWithTag:_transactionType + 100];</span><br><span class="line">        [lastBtn setBackgroundImage:[self createImageWithColor:self.typeNormalColor] forState:UIControlStateNormal];</span><br><span class="line">        [sender setBackgroundImage:[self createImageWithColor:self.typeSelectedColor] forState:UIControlStateNormal];</span><br><span class="line">        _transactionType = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString * subtypeString ;</span><br><span class="line"></span><br><span class="line">    switch (_subtype % 4) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            subtypeString = kCATransitionFromTop;</span><br><span class="line">            break;</span><br><span class="line">        case 1:</span><br><span class="line">            subtypeString = kCATransitionFromBottom;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            subtypeString = kCATransitionFromLeft;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            subtypeString = kCATransitionFromRight;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch (_transactionType) &#123;</span><br><span class="line">        case CATransactionType_Fade:</span><br><span class="line">            [self CATransitionWithType:kCATransitionFade WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_MoveIn:</span><br><span class="line">            [self CATransitionWithType:kCATransitionMoveIn WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_Push:</span><br><span class="line">            [self CATransitionWithType:kCATransitionPush WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_Reveal:</span><br><span class="line">            [self CATransitionWithType:kCATransitionReveal WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case CATransactionType_Cube:</span><br><span class="line">            [self CATransitionWithType:@&quot;cube&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_SuckEffect:</span><br><span class="line">            [self CATransitionWithType:@&quot;suckEffect&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_OglFlip:</span><br><span class="line">            [self CATransitionWithType:@&quot;oglFlip&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_RippleEffect:</span><br><span class="line">            [self CATransitionWithType:@&quot;rippleEffect&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_PageCurl:</span><br><span class="line">            [self CATransitionWithType:@&quot;pageCurl&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_PageUnCurl:</span><br><span class="line">            [self CATransitionWithType:@&quot;pageUnCurl&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_CameraIrisHollowOpen:</span><br><span class="line">            [self CATransitionWithType:@&quot;cameraIrisHollowOpen&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line">        case CATransactionType_CameraIrisHollowClose:</span><br><span class="line">            [self CATransitionWithType:@&quot;cameraIrisHollowClose&quot; WithSubtype:subtypeString];</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static NSInteger i = 0;</span><br><span class="line">    self.bgView.image = i % 2 ? [UIImage imageNamed:@&quot;拉姆.jpeg&quot;] :[UIImage imageNamed:@&quot;蕾姆.jpeg&quot;];</span><br><span class="line">    i ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-1a8800f104907166.gif?imageMogr2/auto-orient/strip" alt="CATransition1.gif"><br><img src="https://upload-images.jianshu.io/upload_images/1487718-1da95c682f270d71.gif?imageMogr2/auto-orient/strip" alt="CATransition2.gif"></p><hr><h2 id="CAAnimationGroup-动画组"><a href="#CAAnimationGroup-动画组" class="headerlink" title="CAAnimationGroup 动画组"></a>CAAnimationGroup 动画组</h2><p>&ensp;&ensp;&ensp;&ensp;分组动画在<code>CAAnimationGroup</code>实例指定的时间中运行。分组动画的持续时间不会被缩放到他们的<code>CAAnimationGroup</code>的持续时间。相反，动画被剪切到动画组的持续时间。例如，在一个动画组中分组的10秒动画，持续时间为5秒，只显示动画的前5秒。</p><h3 id="效果代码-2"><a href="#效果代码-2" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 一个红包雨的例子</span><br><span class="line">- (void)showRain</span><br><span class="line">&#123;</span><br><span class="line">    UIImageView * imageV = [UIImageView new];</span><br><span class="line">    imageV.image = [UIImage imageNamed:@&quot;page&quot;];</span><br><span class="line">    imageV.frame = CGRectMake(0, 0, 50 , 50 );</span><br><span class="line"></span><br><span class="line">    CALayer * layer = [CALayer layer];</span><br><span class="line">    layer.bounds = imageV.frame;</span><br><span class="line">    layer.contents = (id)imageV.image.CGImage;</span><br><span class="line">    layer.anchorPoint = CGPointMake(0, 0);</span><br><span class="line">    layer.position = CGPointMake(0, 0);</span><br><span class="line">    [self.view.layer addSublayer:layer];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [self addAnimationWithLayer:layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAnimationWithLayer:(CALayer *)layer</span><br><span class="line">&#123;</span><br><span class="line">    int height = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line">    int width = [UIScreen mainScreen].bounds.size.height;</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * moveAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    NSValue * A = [NSValue valueWithCGPoint:CGPointMake(arc4random() % width, 0)];</span><br><span class="line">    NSValue * B = [NSValue valueWithCGPoint:CGPointMake(arc4random() % width, height + 100)];</span><br><span class="line">    moveAnimation.values = @[A,B];</span><br><span class="line">    moveAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</span><br><span class="line"></span><br><span class="line">    CAKeyframeAnimation * tranAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">    CATransform3D r0 = CATransform3DMakeRotation(M_PI/180 * (arc4random() % 360 ) , 0, 0, -1);</span><br><span class="line">    CATransform3D r1 = CATransform3DMakeRotation(M_PI/180 * (arc4random() % 360 ) , 0, 0, -1);</span><br><span class="line">    tranAnimation.values = @[[NSValue valueWithCATransform3D:r0],[NSValue valueWithCATransform3D:r1]];</span><br><span class="line">    tranAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line"></span><br><span class="line">    CAAnimationGroup * group = [[CAAnimationGroup alloc] init];</span><br><span class="line">    group.duration = arc4random() % 200 / 100.0 + 3.5;</span><br><span class="line">    group.fillMode = kCAFillModeForwards;</span><br><span class="line">    group.removedOnCompletion = NO;</span><br><span class="line">    group.animations = @[moveAnimation,tranAnimation];</span><br><span class="line">    [layer addAnimation:group forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-fbc767740432f20c.gif?imageMogr2/auto-orient/strip" alt="CAAnimationGroup.gif"></p><hr><h2 id="CASpringAnimation-弹簧动画"><a href="#CASpringAnimation-弹簧动画" class="headerlink" title="CASpringAnimation 弹簧动画"></a>CASpringAnimation 弹簧动画</h2><p>&ensp;&ensp;&ensp;&ensp;<code>CASpringAnimation</code>的父类是<code>CABasicAnimation</code>, <code>CABasicAnimation</code>可以看成是只有头尾有值的关键帧动画。</p><blockquote><p>You would typically use a spring animation to animate a layer’s position so that it appears to be pulled towards a target by a spring. The further the layer is from the target, the greater the acceleration towards it is.<br>CASpringAnimation allows control over physically based attributes such as the spring’s damping and stiffness.</p></blockquote><p>&ensp;&ensp;&ensp;&ensp;<code>CASpringAnimation</code>是基于物理的属性控制，比如弹簧的阻尼和刚度。</p><h3 id="重要属性-2"><a href="#重要属性-2" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th style="text-align:center">描述 </th></tr></thead><tbody><tr><td>damping</td><td style="text-align:center">定义弹簧运动如何受到阻尼的影响</td></tr><tr><td>initialVelocity</td><td style="text-align:center">初速度</td></tr><tr><td>mass</td><td style="text-align:center">连接到弹簧末端的物体的质量</td></tr><tr><td>settlingDuration</td><td style="text-align:center">预估静止时间</td></tr><tr><td>stiffness</td><td style="text-align:center">弹簧刚度系数</td></tr></tbody></table><h3 id="效果代码-3"><a href="#效果代码-3" class="headerlink" title="效果代码"></a>效果代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnClick:(UIButton *)sender</span><br><span class="line">&#123;</span><br><span class="line">    //frame属性不可动画化 只能通过 bounds 和 position完成</span><br><span class="line">    CASpringAnimation * animation = [CASpringAnimation animationWithKeyPath:@&quot;bounds&quot;];</span><br><span class="line"></span><br><span class="line">    //质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大</span><br><span class="line">    animation.mass = self.massSlider.value;</span><br><span class="line"></span><br><span class="line">    //刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快</span><br><span class="line">    animation.stiffness = self.stiffnessSlider.value;</span><br><span class="line"></span><br><span class="line">    //阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快</span><br><span class="line">    animation.damping = self.dampingSlider.value;</span><br><span class="line"></span><br><span class="line">    //初始速率，动画视图的初始速度大小;速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反</span><br><span class="line">    animation.initialVelocity = self.velocitySlider.value;</span><br><span class="line"></span><br><span class="line">    animation.duration = 3.f;</span><br><span class="line">    animation.fromValue =  [NSValue valueWithCGRect:CGRectMake(0, 0, 80, 100)];</span><br><span class="line">    animation.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 80, 240)];</span><br><span class="line">    animation.removedOnCompletion = NO;</span><br><span class="line">    animation.fillMode = kCAFillModeForwards;</span><br><span class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">    [self.baseView.layer addAnimation:animation forKey:nil];</span><br><span class="line"></span><br><span class="line">    CASpringAnimation * animation1 = [CASpringAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">    animation1.duration = 3.f;</span><br><span class="line">    animation1.fromValue = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH / 2 , 250)];</span><br><span class="line">    animation1.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREENWIDTH / 2 , 250 - 70)];</span><br><span class="line">    animation1.removedOnCompletion = NO;</span><br><span class="line">    animation1.fillMode = kCAFillModeForwards;</span><br><span class="line">    [self.baseView.layer addAnimation:animation1 forKey:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ae46d1313229aaa6.gif?imageMogr2/auto-orient/strip" alt="CASpringAnimation.gif"></p><hr><h3 id="UIView的弹簧动画"><a href="#UIView的弹簧动画" class="headerlink" title="UIView的弹簧动画"></a>UIView的弹簧动画</h3><p>另外在看看<code>cell</code>上用<code>UIView Block</code>弹簧动画的特效</p><h4 id="效果代码-4"><a href="#效果代码-4" class="headerlink" title="效果代码"></a>效果代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration</span><br><span class="line">                      delay:(NSTimeInterval)delay</span><br><span class="line">     usingSpringWithDamping:(CGFloat)dampingRatio</span><br><span class="line">      initialSpringVelocity:(CGFloat)velocity</span><br><span class="line">                    options:(UIViewAnimationOptions)options</span><br><span class="line">                 animations:(void (^)(void))animations</span><br><span class="line">                 completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)cellAnimation</span><br><span class="line">&#123;</span><br><span class="line">    [self.springTableView reloadData];</span><br><span class="line"></span><br><span class="line">    NSArray * cellArrays = self.springTableView.visibleCells;</span><br><span class="line">    CGFloat height = self.springTableView.bounds.size.height;</span><br><span class="line"></span><br><span class="line">    for (UITableView * cell in cellArrays)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.transform = CGAffineTransformMakeTranslation(-SCREENWIDTH, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0 ; i &lt; cellArrays.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        UITableViewCell * cell = (UITableViewCell *)cellArrays[i];</span><br><span class="line">        [UIView animateWithDuration:1.5</span><br><span class="line">                              delay:0.05 * i</span><br><span class="line">             usingSpringWithDamping:0.8</span><br><span class="line">              initialSpringVelocity:0</span><br><span class="line">                            options:0 animations:^&#123;</span><br><span class="line">                    cell.transform = CGAffineTransformMakeTranslation(0, 0);</span><br><span class="line">            &#125; completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果图-4"><a href="#效果图-4" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/1487718-0a62c12dc5195c94.gif?imageMogr2/auto-orient/strip" alt="CellSpringAnimation.gif"></p><p><a href="https://github.com/iOS-Misaki/CAAnimation"><strong>源码: CAAnimation</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;有人问我为什么要写博客，必须要承认，现在网上一大推的优秀教程和现成的Demo，自己写的没有别人好，有些地方根本不够深入，但是看别人写文章、写代码和自己写完全是两件事，代码看看就能懂，但是自己过一遍，印象更深，消化的也就更彻底。对于iOS动画 ，一直都没有系统化的学习，只有用的时候才会查查api，之前写过一篇&lt;a href=&quot;https://www.jianshu.com/p/92ac22afeeef&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;红包雨&lt;/a&gt;的文章，用的是关键帧动画，没有在继续下去。另一个就是在6月份面试的时候，有两个面试官都问到了基础动画，当时也回答的不好，现在详细地梳理一遍。现阶段，先把&lt;code&gt;Core Animation&lt;/code&gt;弄清楚，以后再下沉到&lt;code&gt;OpenGL&lt;/code&gt;和&lt;code&gt;CoreGraphics&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化尝试</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%B0%9D%E8%AF%95/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/iOS-组件化尝试/</id>
    <published>2018-07-01T03:23:54.000Z</published>
    <updated>2018-07-27T03:38:19.227Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;<code>ReactiveCocoa</code>只更新了一篇，剩下结合登录例子来实践<code>MVVM</code>暂时没有时间，这周精力都放在了公司项目的组件化上面，以后有时间会慢慢补上。感觉欠的历史债好多。</p><a id="more"></a><h2 id="传统模块的耦合"><a href="#传统模块的耦合" class="headerlink" title="传统模块的耦合"></a>传统模块的耦合</h2><p>&ensp;&ensp;&ensp;&ensp;对于大型项目来说，业务模块之间的耦合度非常大，很难维护。模块之间会互相调用。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-14005383adc14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="传统模块"></p><p>&ensp;&ensp;&ensp;&ensp;为了解决这个问题，可以增加一个中间层。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-ed43c5ee1fb260b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加中间层"><br>&ensp;&ensp;&ensp;&ensp;但是模块和中间层还是互相依赖，之前耦合的问题还是存在，要改进的地方是消除中间层对业务模块的依赖。<br><img src="https://upload-images.jianshu.io/upload_images/1487718-a1542a4366eedd5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最终方案"></p><h2 id="模块的划分"><a href="#模块的划分" class="headerlink" title="模块的划分"></a>模块的划分</h2><p>&ensp;&ensp;&ensp;&ensp;组件化是把每个模块作为一个组件，在主工程里面集成所有的组件。关于用<code>CocoaPod</code>集成私有库，在上篇文章<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/" target="_blank" rel="noopener">CocoaPod创建私有库</a>有详细的介绍。<br>&ensp;&ensp;&ensp;&ensp;整个项目中模块的划分是分为基础模块、中间层和业务模块。</p><ul><li>基础模块里面是和业务没有任何关联的模块，里面包括网络请求、图片加载、数据存储、页面布局还有公共的工具类等。</li><li>业务模块是按照功能来划分的。根据业务需要，来确定颗粒度的大小，比如登录注册模块、用户信息模块、购物车模块、详情模块、订单模块等。业务模块是要依赖基础模块的。</li><li>中间层不依赖业务模块，只负责调度业务模块。</li></ul><h2 id="模块之间的通讯"><a href="#模块之间的通讯" class="headerlink" title="模块之间的通讯"></a>模块之间的通讯</h2><p>&ensp;&ensp;&ensp;&ensp;消除中间层对业务的依赖，有三种方案。</p><ul><li>蘑菇街 <a href="https://link.jianshu.com/?t=https://github.com/mogujie/MGJRouter.git" target="_blank" rel="noopener">MGJRouter</a> <code>URL -&gt; block</code></li><li>后来蘑菇街对这种方案提出改进<code>protocol -&gt; class</code></li><li>casatwy大神的 基于<a href="https://github.com/casatwy/CTMediator.git">CTMediator</a>的<code>Target -&gt; Action</code></li></ul><p>&ensp;&ensp;&ensp;&ensp;下面重点介绍第三种方案。把所有组件的调用都通过<code>category</code>的方式暴露出来，调用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;现在举个例子，首页要push登录页面。在中间层新建一个<code>CTMediator</code>的分类<code>CTMediator+UMAction</code>,暴露一个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)CTMediator_viewControllerForDetailWithValue:(NSString *)value;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>Targe</code>t是<code>UM</code>,<code>Action</code>的对象是<code>LoginViewController</code>。然后再<code>UM</code>模块里面建立<code>Target_UM</code>文件，来处理<code>LoginViewController</code>的实例化。在首页调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIViewController * vc = [[CTMediator sharedInstance] CTMediator_viewControllerForDetailWithValue:@&quot;我是标题&quot;];</span><br><span class="line">[self.navigationController presentViewController:vc animated:YES completion:nil];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;可以看到首页并没有引入<code>LoginViewController</code>的头文件。<code>CTMediator</code> 实际上是基于<code>Runtime</code>进行类名反射，将<code>CTMediator+UMAction</code>调用生成一个<code>Target_UM</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName];</span><br><span class="line">NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName];</span><br><span class="line">Class targetClass;</span><br><span class="line"></span><br><span class="line">NSObject *target = self.cachedTarget[targetClassString];</span><br><span class="line">if (target == nil) &#123;</span><br><span class="line">targetClass = NSClassFromString(targetClassString);</span><br><span class="line">target = [[targetClass alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEL action = NSSelectorFromString(actionString);</span><br><span class="line">return [self safePerformAction:action target:target params:params];</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<strong>所以每添加一个模块，都要在中间层声明一个分类来调用，同时也要在相应的模块内去实现这个<code>Target</code>。</strong></p><h2 id="关于组件化的思考"><a href="#关于组件化的思考" class="headerlink" title="关于组件化的思考"></a>关于组件化的思考</h2><p>&ensp;&ensp;&ensp;&ensp;实施组件化的大致的步骤，首先是把项目解耦拆分成一个个单独的组件，然后实现组件间的通讯。</p><ul><li><p>组件化的好处<br><strong>简化了代码的整体结构，降低了维护成本，不同模块通过git管理，实现物理隔离，提高代码的稳定性，为模块的复用提供了基础，未来可以灵活的扩展业务。</strong></p></li><li><p>组件化的缺点。<br><strong>学习成本高，对开发人员掌握各种工具要求比较高，入门比较困难，个人学习制作私有库，也是踩了好多坑。前期基业务没有实现，要提前考虑模块之间的解耦，过多的关注组件间的通讯，必然导致开发效率的下降。</strong></p></li></ul><p>&ensp;&ensp;&ensp;&ensp;说一下项目，脱离实际项目谈架构都是扯淡。目前接手的项目是个电商类的项目，iOS 和安卓都还没有起步，web前端已经实现1.0版本，基本的电商的功能都实现了。iOS项目目前就两个人。项目想做成一个模板，然后给不同的客户提供可定制化的功能。项目管理人员想推行组件化，这周我在实践这一方案的可行性。<br>&ensp;&ensp;&ensp;&ensp;并不是所有项目是适用于组件化。就对于现在的项目来说，只有两个开发人员。我来确定代码规范，不存在多人协同冲突的情况。产品虽然说后端接口和web前端都实现了，但是iOS和安卓项目都还没起步，实现最基础的业务，快速迭代上线更加重要，现有MVC或者MVVM就足够现实了。当实现了基础业务，需要更多对细节关注，才差不多要考虑组件化。<br>&ensp;&ensp;&ensp;&ensp;组件化适合业务成熟且繁杂、开发人员多的大团队，对于我们两人且还没有开启项目的团队至少现在这个时间节点来说是不合适的。适合项目的架构就是好架构，组件化是好技术，但是在不合适的时候盲目追求组件化，是本末倒置的。</p><p><strong>参考 :</strong><br><a href="https://casatwy.com/modulization_in_action.html" target="_blank" rel="noopener">在现有工程中实施基于CTMediator的组件化方案</a><br><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&lt;code&gt;ReactiveCocoa&lt;/code&gt;只更新了一篇，剩下结合登录例子来实践&lt;code&gt;MVVM&lt;/code&gt;暂时没有时间，这周精力都放在了公司项目的组件化上面，以后有时间会慢慢补上。感觉欠的历史债好多。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPod 创建私有库</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/CocoaPod-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/07/01/CocoaPod-创建私有库/</id>
    <published>2018-07-01T01:35:21.000Z</published>
    <updated>2018-07-27T03:35:42.215Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;在码云(<a href="https://gitee.com/yuyiios/events" target="_blank" rel="noopener">我的个人主页</a>)上创建两个远程仓库，其中<code>YYSpecs</code> 用来存放本地的<code>spec</code>,<code>YYToolProject</code>是用来存放私有库代码的。</p><h2 id="创建本地索引"><a href="#创建本地索引" class="headerlink" title="创建本地索引"></a>创建本地索引</h2><p>&ensp;&ensp;&ensp;&ensp;首先 进入<code>~/.cocoapods/repos</code>目录 查看有一个<code>master</code>的目录，<code>master</code>就是<code>cocoapod</code>官网的索引源，现在要做的就是创建自己私有的<code>Spec Repo</code>.</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span><br><span class="line">pod repo add YYSpecs  https://gitee.com/yuyiios/YYSpecs.git</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1487718-8a8184268cf14700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="~:.cocoapods:repos目录.png"></p><p>&ensp;&ensp;&ensp;&ensp;然后可以看见<code>master</code>有个同级目录<code>YYSpecs</code>。私有<code>Spec Repo</code>就创建完成了。</p><h2 id="创建本地lib"><a href="#创建本地lib" class="headerlink" title="创建本地lib"></a>创建本地lib</h2><p>&ensp;&ensp;&ensp;&ensp;进入桌面目录，创建一个名为<code>YYToolSet</code>的<code>pod</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create YYToolSet</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;会有以下提示，按照问题回答就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide: </span><br><span class="line">- https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line">( hold cmd and double click links to open in a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform do you want to use?? [ iOS / macOS ]</span><br><span class="line">&gt; </span><br><span class="line">ios</span><br><span class="line">What language do you want to use?? [ Swift / ObjC ]</span><br><span class="line">&gt; ObjC</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line">&gt; No</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line">&gt; None</span><br><span class="line"></span><br><span class="line">Would you like to do view based testing? [ Yes / No ]</span><br><span class="line">&gt; No</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line">&gt; YY</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;在Finder中，将<code>/YYToolSet/Classes</code>目录下的<code>ReplaceMe.m</code>删除 替换成自己的文件，如图。<img src="https://upload-images.jianshu.io/upload_images/1487718-465ead8a2f11b57d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="替换掉ReplaceMe文件.png"><br>&ensp;&ensp;&ensp;&ensp;打开工程，查看<code>YYToolSet.podspec</code>文件</p><ul><li>s.version 是pod的版本信息 这个后面打tag的时候用的到</li><li>s.summary 是简短的描述</li><li>s.source 是项目远程仓库的地址，这里不要用SSH，用HTTPS。</li><li>s.homepage 是项目主页地址 就是HTTPS地址后面去掉.git 就可以</li><li>s.source_files 是项目的文件 就是刚才替换ReplaceMe.m的那些文件 </li><li>s.resource_bundles 是资源文件</li><li>s.frameworks 是用到了系统的哪些库 例如UIKit、Foundation</li><li>s.dependency 是用到哪些第三方库 比如AFNetworking 有多个就写多个s.dependency</li><li>s.public_header_files 项目的公共头文件，举个例子，当引入Masonry、YTKNetwork的时候 可以创建一个header文件，然后将#import “Masonry.h”    #import “YTKNetwork.h”写入进去</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ed45e32c442d9704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置文件.png"></p><h2 id="验证本地lib"><a href="#验证本地lib" class="headerlink" title="验证本地lib"></a>验证本地lib</h2><p>&ensp;&ensp;&ensp;&ensp;修改完成后，切换到外面的<code>YYToolSet</code>目录，验证<code>podspec</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line">pod lib lint --verbose</span><br><span class="line">pod lib lint --allow-warnings</span><br><span class="line">pod lib lint --sources=https://gitee.com/yuyiios/YYSpecs.git</span><br><span class="line">pod lib lint --use-libraries</span><br></pre></td></tr></table></figure></p><ul><li>–verbose 假如有error,查看报错信息</li><li>–allow-warnings 假如有warning，可以通过来忽略错误信息通过验证 </li><li>–sources 假如这个私有库还依赖其他的私有库，一定要指定私有库的索引源（就是我上文说的YYSpecs的git地址）–sources=<a href="https://github.com/artsy/Specs,master">https://github.com/artsy/Specs,master</a></li><li>–use-libraries 如果用了第三方的framework或者静态库，要加上。</li></ul><h2 id="验证本地和远端的pod"><a href="#验证本地和远端的pod" class="headerlink" title="验证本地和远端的pod"></a>验证本地和远端的pod</h2><p>&ensp;&ensp;&ensp;&ensp;本地校验成功后，推送至远端，就是<code>YYToolProject</code>的git地址。进入外面的<code>YYToolSet</code>目录。执行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin [GitHub HTTPS clone URL]</span><br><span class="line">git remote add origin https://gitee.com/yuyiios/YYToolProject.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;有冲突先解决冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &apos;fix&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后给<code>pod</code>打上标签，并且推送至远端，注意这里的<code>tag</code>要和<code>podspec</code>文件里面的<code>s.version</code>对应起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -m &apos;0.1.0标签&apos; -a 0.1.0</span><br><span class="line">git push --tags</span><br><span class="line">git tag //查看标签</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;打完标签后，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;<code>pod lib lint</code>和<code>pod spec lint</code>的区别是前者只会检验本地的<code>pod</code>,后者是本地和远端都会检验，所以之前用到的<code>--allow-warning  --sources --use-libraries</code> 等命令的这里都要带上。</p><h2 id="推送至索引源仓库"><a href="#推送至索引源仓库" class="headerlink" title="推送至索引源仓库"></a>推送至索引源仓库</h2><p>&ensp;&ensp;&ensp;&ensp;远端和本地都校验通过后就要将<code>YYToolSet.podspec</code>推送至<code>YYSpecs</code>仓库中 成功后去<code>~/.cocoapods/repos/YYSpecs</code> 有个<code>YYToolSet</code>目录 有个0.1.0的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo push [Repo名] [podspec 文件名字]</span><br><span class="line">pod repo push YYSpecs YYToolSet.podspec</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;最后验证一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pod search YYToolSet </span><br><span class="line">-&gt; YYToolSet (0.1.0)</span><br><span class="line">工具集 YYToolSet.</span><br><span class="line">pod &apos;YYToolSet&apos;, &apos;~&gt; 0.1.0&apos;</span><br><span class="line">- Homepage: https://gitee.com/yuyiios/YYToolProject</span><br><span class="line">- Source:   https://gitee.com/yuyiios/YYToolProject.git</span><br><span class="line">- Versions: 0.1.0 [YYSpecs repo]</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;新建一个空项目，导入私有库验证一下，这里一定要带上<code>source</code> 就是<code>YYToolSet</code>所在索引源的远端地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pod init </span><br><span class="line">vim Podfile</span><br><span class="line"></span><br><span class="line">source &apos;https://gitee.com/yuyiios/YYToolProject.git&apos;</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">source &apos;https://gitee.com/yuyiios/YYSpecs.git&apos;</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;None&apos; do</span><br><span class="line">pod &apos;YYToolSet&apos;, &apos;~&gt; 0.1.0&apos;</span><br><span class="line"># use_frameworks!</span><br><span class="line"></span><br><span class="line"># Pods for None</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-685e87a6ae906c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="验证通过.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在码云(&lt;a href=&quot;https://gitee.com/yuyiios/events&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的个人主页&lt;/a&gt;)上创建两个远程仓库，其中&lt;code&gt;YYSpecs&lt;/code&gt; 用来存放本地的&lt;code&gt;spec&lt;/code&gt;,&lt;code&gt;YYToolProject&lt;/code&gt;是用来存放私有库代码的。&lt;/p&gt;
&lt;h2 id=&quot;创建本地索引&quot;&gt;&lt;a href=&quot;#创建本地索引&quot; class=&quot;headerlink&quot; title=&quot;创建本地索引&quot;&gt;&lt;/a&gt;创建本地索引&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;首先 进入&lt;code&gt;~/.cocoapods/repos&lt;/code&gt;目录 查看有一个&lt;code&gt;master&lt;/code&gt;的目录，&lt;code&gt;master&lt;/code&gt;就是&lt;code&gt;cocoapod&lt;/code&gt;官网的索引源，现在要做的就是创建自己私有的&lt;code&gt;Spec Repo&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 8种经典算法可视化</title>
    <link href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/18/iOS-8%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/04/18/iOS-8种经典算法可视化/</id>
    <published>2018-04-18T15:32:26.000Z</published>
    <updated>2018-07-26T16:10:02.189Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;先看图，这里为了方便展示gif图片，在冒泡排序、选择排序、插入排序，视图更新停留的时间设置为0.001秒，其他排序设置视图更新时间为0.003秒。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/1487718-c67a8b114e5a12b8.gif?imageMogr2/auto-orient/strip" alt="0冒泡排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-ab8a517890793cd8.gif?imageMogr2/auto-orient/strip" alt="1选择排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-94a562e4f40c9067.gif?imageMogr2/auto-orient/strip" alt="2插入排序（0.001s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-20d8e1c4744b3002.gif?imageMogr2/auto-orient/strip" alt="3快速排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-2db8865d136d7b27.gif?imageMogr2/auto-orient/strip" alt="4希尔排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-92b55075ee71d41f.gif?imageMogr2/auto-orient/strip" alt="5归并排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-f489ad65de02a3a1.gif?imageMogr2/auto-orient/strip" alt="6堆排序（0.003s）.gif"></p><p><img src="https://upload-images.jianshu.io/upload_images/1487718-333d51fc00d19b26.gif?imageMogr2/auto-orient/strip" alt="7基数排序（0.003s）.gif"></p><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><img src="https://upload-images.jianshu.io/upload_images/1487718-3fe0a1205ccd214d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复杂度.jpg"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="高度可视化"><a href="#高度可视化" class="headerlink" title="高度可视化"></a>高度可视化</h3><p>&ensp;&ensp;&ensp;&ensp;首先，用视图<code>SortView</code>的高度来代表随机数，为了便于查看，本身的颜色随着高度变化而变化，对外暴露一个更改高度的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SortView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SortView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self)</span><br><span class="line">    &#123;</span><br><span class="line">        self.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat y = self.superview.frame.size.height - self.frame.size.height;</span><br><span class="line"></span><br><span class="line">    CGRect frame = self.frame;</span><br><span class="line">    frame.origin.y = y;</span><br><span class="line">    self.frame = frame;</span><br><span class="line"></span><br><span class="line">    CGFloat weight = frame.size.height / self.superview.frame.size.height;</span><br><span class="line">    UIColor * color = [UIColor colorWithHue:weight saturation:1 brightness:1 alpha:1];</span><br><span class="line">    self.backgroundColor = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateHeight:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    CGRect temp = self.frame;</span><br><span class="line">    temp.size.height = height;</span><br><span class="line">    self.frame = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&ensp;&ensp;&ensp;&ensp;然后再生成随机数数组和<code>sortView</code>数组一一对应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 生成随机数数组</span><br><span class="line">- (void)setup_random</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; self.count ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        int height = (int)(SCREENHEIGHT - 200);</span><br><span class="line">        NSInteger random = arc4random() % height;</span><br><span class="line">        NSNumber * num = [NSNumber numberWithInteger:random];</span><br><span class="line">        [self.randomArray addObject:num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)addSortViews</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; self.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        CGFloat width = SCREENWIDTH / self.count;</span><br><span class="line">        SortView * sortView = [[SortView alloc]initWithFrame:CGRectMake(i * width, 0, width, [self.randomArray[i] integerValue])];</span><br><span class="line">        [self.containerView addSubview:sortView];</span><br><span class="line">        [self.sortViewArray addObject:sortView];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="排序交换回调"><a href="#排序交换回调" class="headerlink" title="排序交换回调"></a>排序交换回调</h3><p>&ensp;&ensp;&ensp;&ensp;然后在排序类，定义一个回调<code>SortObjectBlock</code>，用于更新视图的高度。<code>index</code>参数是在数组的索引值，<code>value</code>是索引值对应元素要修改的高度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SortObjectBlock)(NSInteger index,NSNumber * value);</span><br><span class="line"></span><br><span class="line">@interface SortObject : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) SortObjectBlock sortObjectBlock;</span><br></pre></td></tr></table></figure></p><h3 id="阻塞时间完成视觉效果"><a href="#阻塞时间完成视觉效果" class="headerlink" title="阻塞时间完成视觉效果"></a>阻塞时间完成视觉效果</h3><p><code>SortObjectBlock</code>在排序的时候，接收回调,为了方面观察排序的变化，每次数组中有值发生变化的时候阻塞线程0.001s。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)sort</span><br><span class="line">&#123;</span><br><span class="line">    SortObject *  sortObject = [SortObject new];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    sortObject.sortObjectBlock = ^(NSInteger index,NSNumber * value)&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:0.001];</span><br><span class="line">        [weakSelf updateSortViewWithIndex:index widthValue:value];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - 更新视图</span><br><span class="line">- (void)updateSortViewWithIndex:(NSInteger)index widthValue:(NSNumber *)value</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        SortView * sortView = (SortView *)[weakSelf.sortViewArray objectAtIndex:index];</span><br><span class="line">        [sortView updateHeight:[value integerValue]];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8种算法"><a href="#8种算法" class="headerlink" title="8种算法"></a>8种算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 冒泡</span><br><span class="line">- (NSMutableArray *)sort0:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger j = 0 ; j &lt; i ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i] &lt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(i,array[j]);</span><br><span class="line">                    _sortObjectBlock(j,array[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 选择排序</span><br><span class="line">- (NSMutableArray *)sort1:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger j = i + 1 ; j &lt; array.count ; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[i] &gt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(i,array[j]);</span><br><span class="line">                    _sortObjectBlock(j,array[i]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:i withObjectAtIndex:j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#pragma mark - 插入排序</span><br><span class="line">- (NSMutableArray *)sort2:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; array.count ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSNumber * temp = array[i];</span><br><span class="line">        for (NSInteger j = i - 1 ; j &gt;= 0 &amp;&amp; temp &lt; array[j] ; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(j,array[j + 1]);</span><br><span class="line">                _sortObjectBlock(j + 1,array[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            [array exchangeObjectAtIndex:j withObjectAtIndex:j + 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>&ensp;&ensp;&ensp;&ensp;快速排序是对冒泡排序的一种改进，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 快速排序</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)sort3:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self quickSort:array leftIndex:0 rightIndex:array.count - 1];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)quickSort:(NSMutableArray *)array leftIndex:(NSInteger)left rightIndex:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    if (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        NSInteger temp = [self getMiddleIndex:array leftIndex:left rightIndex:right];</span><br><span class="line">        //递归前半部分</span><br><span class="line">        [self quickSort:array leftIndex:left rightIndex:temp - 1];</span><br><span class="line">        //递归后半部分</span><br><span class="line">        [self quickSort:array leftIndex:temp + 1 rightIndex:right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将数组以第一个值为准分成两部分，前半部分比该值要小，后半部分比该值要大</span><br><span class="line">- (NSInteger)getMiddleIndex:(NSMutableArray *)array leftIndex:(NSInteger)left rightIndex:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * temp = array[left];</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (left &lt; right &amp;&amp; temp &lt;= array[right]) &#123;</span><br><span class="line">            right -- ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(left,array[right]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[left] = array[right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (left &lt; right &amp;&amp; array[left] &lt;= temp) &#123;</span><br><span class="line">            left ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(right,array[left]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[right] = array[left];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_sortObjectBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sortObjectBlock(left,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[left] = temp;</span><br><span class="line"></span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>&ensp;&ensp;&ensp;&ensp;希尔排序又叫缩小增量排序，属于插入排序的一种。把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。这里取得的增量为一半。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 希尔排序</span><br><span class="line">- (NSMutableArray *)sort4:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger increment = array.count / 2 ; increment &gt; 0 ; increment /= 2 )</span><br><span class="line">    &#123;</span><br><span class="line">        for (NSInteger i = increment ; i &lt; array.count ; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSInteger j = i ;</span><br><span class="line">            for (; j - increment &gt;= 0 &amp;&amp; array[j] &lt; array[j-increment]; j -= increment)</span><br><span class="line">            &#123;</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(j,array[j - increment]);</span><br><span class="line">                    _sortObjectBlock(j - increment,array[j]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [array exchangeObjectAtIndex:j withObjectAtIndex:(j - increment)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&ensp;&ensp;&ensp;&ensp;归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 归并排序</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)sort5:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self megerSortWithArray:array];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)megerSortWithArray:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * tempArray = [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    //将数组中的每一个元素放入一个数组中</span><br><span class="line">    for (NSNumber * num in array)</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * subArray = [NSMutableArray array];</span><br><span class="line">        [subArray addObject:num];</span><br><span class="line">        [tempArray addObject:subArray];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //对这个数组中的数组进行合并，直到合并完毕为止</span><br><span class="line">    while (tempArray.count != 1) &#123;</span><br><span class="line">        NSInteger i = 0 ;</span><br><span class="line">        while (i &lt; tempArray.count - 1) &#123;</span><br><span class="line">            //将tempArray[i] 和 tempArray[i+1]合并</span><br><span class="line">            tempArray[i] = [self mergeArrayFirstList:tempArray[i] secondList:tempArray[i + 1]];</span><br><span class="line">            [tempArray removeObjectAtIndex:(i + 1)];</span><br><span class="line">            </span><br><span class="line">            for (NSInteger subIndex = 0 ; subIndex &lt; [tempArray[i] count]; subIndex ++)</span><br><span class="line">            &#123;</span><br><span class="line">                NSInteger index = [self countEndIndex:i SubItemIndex:subIndex TempArray:tempArray];</span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(index,tempArray[i][subIndex]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    array = tempArray[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将两个有序数组进行合并,返回一个排序好的数组</span><br><span class="line">- (NSArray *)mergeArrayFirstList:(NSArray *)array1 secondList:(NSArray *)array2</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * resultArray = [NSMutableArray array];</span><br><span class="line">    NSInteger firstIndex = 0;</span><br><span class="line">    NSInteger secondIndex = 0;</span><br><span class="line">    while (firstIndex &lt; array1.count &amp;&amp; secondIndex &lt; array2.count) &#123;</span><br><span class="line">        if ([array1[firstIndex] integerValue] &lt; [array2[secondIndex] integerValue])</span><br><span class="line">        &#123;</span><br><span class="line">            [resultArray addObject:array1[firstIndex]];</span><br><span class="line">            firstIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [resultArray addObject:array2[secondIndex]];</span><br><span class="line">            secondIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (firstIndex &lt; array1.count) &#123;</span><br><span class="line">        [resultArray addObject:array1[firstIndex]];</span><br><span class="line">        firstIndex ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (secondIndex &lt; array2.count) &#123;</span><br><span class="line">        [resultArray addObject:array2[secondIndex]];</span><br><span class="line">        secondIndex ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return resultArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)countEndIndex:(NSInteger)endIndex SubItemIndex:(NSInteger)subItemIndex TempArray:(NSMutableArray *)tempArray</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger sum = 0 ;</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; endIndex ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += [tempArray[i] count];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum + subItemIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>&ensp;&ensp;&ensp;&ensp;它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 堆排序</span><br><span class="line">- (NSMutableArray *)sort6:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    return [self heapSort:array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)heapSort:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * list = [NSMutableArray arrayWithArray:array];</span><br><span class="line">    NSInteger endIndex = array.count - 1;</span><br><span class="line">    //创建大顶堆 把array 转换为大顶堆层次的遍历结果</span><br><span class="line">    [self heapCreate:list];</span><br><span class="line"></span><br><span class="line">    while (endIndex &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">        //交换大顶堆的收尾两个值</span><br><span class="line">        if (_sortObjectBlock)</span><br><span class="line">        &#123;</span><br><span class="line">            _sortObjectBlock(0,list[endIndex]);</span><br><span class="line">            _sortObjectBlock(endIndex,list[0]);</span><br><span class="line"></span><br><span class="line">            [list exchangeObjectAtIndex:0 withObjectAtIndex:endIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //缩小大顶堆的范围</span><br><span class="line">        endIndex -- ;</span><br><span class="line">        [self heapAdjast:list withStartIndex:0 withEndIndex:endIndex + 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//构建大顶堆的层次遍历序列</span><br><span class="line">- (void)heapCreate:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSInteger i = array.count;</span><br><span class="line">    for (; i &gt; 0; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        [self heapAdjast:array withStartIndex:i - 1 withEndIndex:array.count];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对大顶堆的局部调整，使其改节点的所有父类符合大顶堆的特点</span><br><span class="line">- (void)heapAdjast:(NSMutableArray *)array withStartIndex:(NSInteger)startIndex withEndIndex:(NSInteger)endIndex</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * temp = array[startIndex];</span><br><span class="line">    //父节点下标</span><br><span class="line">    NSInteger fatherIndex = startIndex + 1;</span><br><span class="line">    //左孩子下标</span><br><span class="line">    NSInteger leftChildIndex = fatherIndex * 2;</span><br><span class="line">    while (leftChildIndex &lt;= endIndex) &#123;</span><br><span class="line">        //比较左右节点 找出较大的角标</span><br><span class="line">        if (leftChildIndex &lt; endIndex &amp;&amp; array[leftChildIndex - 1] &lt; array[leftChildIndex])</span><br><span class="line">        &#123;</span><br><span class="line">            leftChildIndex ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果较大的子节点比根节点大 赋值为父节点</span><br><span class="line">        if (temp &lt; array[leftChildIndex - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            if (_sortObjectBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                _sortObjectBlock(fatherIndex - 1,array[leftChildIndex - 1]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            array[fatherIndex - 1] = array[leftChildIndex - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            break ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fatherIndex = leftChildIndex;</span><br><span class="line">        leftChildIndex = fatherIndex * 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (_sortObjectBlock)</span><br><span class="line">    &#123;</span><br><span class="line">        _sortObjectBlock(fatherIndex - 1,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[fatherIndex - 1] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>&ensp;&ensp;&ensp;&ensp;它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 基数排序</span><br><span class="line">- (NSMutableArray *)sort7:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    [self radixSort:array];</span><br><span class="line">    return array.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)radixSort:(NSMutableArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    //创建空桶</span><br><span class="line">    NSMutableArray * bucket = [self createBucket];</span><br><span class="line"></span><br><span class="line">    //待排数组的最大数值</span><br><span class="line">    NSNumber * maxNumber = [self listMaxItem:array];</span><br><span class="line"></span><br><span class="line">    //最大数值的数字位数</span><br><span class="line">    NSInteger maxLength = [self numberLength:maxNumber];</span><br><span class="line"></span><br><span class="line">    //按照从低位到高位的顺序执行排序过程</span><br><span class="line">    for (NSInteger digit = 1 ; digit &lt;= maxLength ; digit ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        //入桶</span><br><span class="line">        for (NSNumber * item in array)</span><br><span class="line">        &#123;</span><br><span class="line">            //确定item 归属哪个桶 以digit位数为基数</span><br><span class="line">            NSInteger baseNumber = [self fetchBaseNumber:item digit:digit];</span><br><span class="line">            NSMutableArray * mutArray = bucket[baseNumber];</span><br><span class="line">            //将数据放入空桶上</span><br><span class="line">            [mutArray addObject:item];            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSInteger index = 0;</span><br><span class="line"></span><br><span class="line">        //出桶</span><br><span class="line">        for (NSInteger i = 0 ; i &lt; bucket.count ; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSMutableArray * subArray = bucket[i];</span><br><span class="line">            //将桶的数据放回待排数组中</span><br><span class="line">            while (subArray.count != 0) &#123;</span><br><span class="line">                NSNumber * number = [subArray objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">                if (_sortObjectBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    _sortObjectBlock(index,number);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                array[index] = number;</span><br><span class="line">                [subArray removeObjectAtIndex:0];</span><br><span class="line">                index ++ ;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建空桶</span><br><span class="line">- (NSMutableArray *)createBucket</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray * bucket = [NSMutableArray array];</span><br><span class="line">    for (NSInteger i = 0 ; i &lt; 10 ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * array = [NSMutableArray array];</span><br><span class="line">        [bucket addObject:array];</span><br><span class="line">    &#125;</span><br><span class="line">    return bucket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取列表最大值</span><br><span class="line">- (NSNumber *)listMaxItem:(NSArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber * maxNumber = array[0];</span><br><span class="line">    for (NSNumber * number in array)</span><br><span class="line">    &#123;</span><br><span class="line">        if (maxNumber &lt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNumber = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数字的位数</span><br><span class="line">- (NSInteger)numberLength:(NSNumber *)number</span><br><span class="line">&#123;</span><br><span class="line">    NSString * string = [NSString stringWithFormat:@&quot;%ld&quot;,(long)[number integerValue]];</span><br><span class="line">    return string.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//number 操作的数字  digit 位数  返回该位数上的数字</span><br><span class="line">- (NSInteger)fetchBaseNumber:(NSNumber *)number digit:(NSInteger)digit</span><br><span class="line">&#123;</span><br><span class="line">    //digit为基数位数</span><br><span class="line">    if (digit &gt; 0 &amp;&amp; digit &lt;= [self numberLength:number])</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray * numbersArray = [NSMutableArray array];</span><br><span class="line">        NSString * string = [NSString stringWithFormat:@&quot;%ld&quot;,[number integerValue]];</span><br><span class="line">        for (NSInteger index = 0 ; index &lt; [self numberLength:number] ; index ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            NSString * temp = [string substringWithRange:NSMakeRange(index, 1)];</span><br><span class="line">            [numbersArray addObject:temp];</span><br><span class="line">        &#125;</span><br><span class="line">        NSString * str = numbersArray[numbersArray.count - digit];</span><br><span class="line">        return [str integerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考:<a href="https://www.cnblogs.com/ludashi/p/6065086.html" target="_blank" rel="noopener">iOS可视化动态绘制八种排序过程(Swift版)</a></strong></p><p><strong>源码:<a href="https://github.com/iOS-Misaki/SortDemo">SortDemo</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;先看图，这里为了方便展示gif图片，在冒泡排序、选择排序、插入排序，视图更新停留的时间设置为0.001秒，其他排序设置视图更新时间为0.003秒。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
