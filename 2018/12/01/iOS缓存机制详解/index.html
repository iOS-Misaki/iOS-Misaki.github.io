<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/iOS-Misaki.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/iOS-Misaki.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/iOS-Misaki.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/iOS-Misaki.github.io/images/smile_180*180.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/iOS-Misaki.github.io/images/smile_32*32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/iOS-Misaki.github.io/images/smile_16*16.png?v=5.1.4">


  <link rel="mask-icon" href="/iOS-Misaki.github.io/images/smile.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/iOS-Misaki.github.io/atom.xml" title="Misaki的小站" type="application/atom+xml" />






<meta name="description" content="Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren’t aware that NSURLCache could be setup in two lines and do it 10">
<meta name="keywords" content="iOS 余意">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS缓存机制详解">
<meta property="og:url" content="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/12/01/iOS缓存机制详解/index.html">
<meta property="og:site_name" content="Misaki的小站">
<meta property="og:description" content="Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren’t aware that NSURLCache could be setup in two lines and do it 10">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1487718-b3a080f6739c49cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-12-01T10:22:52.244Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS缓存机制详解">
<meta name="twitter:description" content="Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren’t aware that NSURLCache could be setup in two lines and do it 10">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1487718-b3a080f6739c49cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/iOS-Misaki.github.io/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/2018/12/01/iOS缓存机制详解/"/>





  <title>iOS缓存机制详解 | Misaki的小站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    <a href="https://github.com/iOS-Misaki" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/iOS-Misaki.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Misaki的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/iOS-Misaki.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/iOS-Misaki.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/iOS-Misaki/iOS-Misaki.github.io/iOS-Misaki.github.io/2018/12/01/iOS缓存机制详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Misaki">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/iOS-Misaki.github.io/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misaki的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS缓存机制详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-01T18:04:20+08:00">
                2018-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>Untold numbers of developers have hacked together an awkward, fragile system for network caching functionality, all because they weren’t aware that NSURLCache could be setup in two lines and do it 100× better. Even more developers have never known the benefits of network caching, and never attempted a solution, causing their apps to make untold numbers of unnecessary requests to the server.<br>无数开发者尝试自己做一个丑陋而脆弱的系统来实现网络缓存的功能，殊不知NSURLCache只要两行代码就能搞定，并且好上100倍。甚至更多的开发者根本不知道网络缓存的好处，从来没有尝试过解决方案，导致他们的App向服务器发出无数不必要的请求。</p>
</blockquote>
<a id="more"></a>
<h2 id="iOS系统的缓存策略"><a href="#iOS系统的缓存策略" class="headerlink" title="iOS系统的缓存策略"></a>iOS系统的缓存策略</h2><p>&ensp;&ensp;&ensp;&ensp;上面是引用<code>Mattt</code>大神在<a href="https://nshipster.com/" target="_blank" rel="noopener">NSHipster</a>介绍NSURLCache时的原话。</p>
<h3 id="服务端的缓存策略"><a href="#服务端的缓存策略" class="headerlink" title="服务端的缓存策略"></a>服务端的缓存策略</h3><p>&ensp;&ensp;&ensp;&ensp;先看看服务端的缓存策略。当第一次请求后，客户端会缓存数据，当有第二次请求的时候，客户端会额外在请求头加上<code>If-Modified-Since</code>或者<code>If-None-Match</code>，<code>If-Modified-Since</code>会携带缓存的最后修改时间，服务端会把这个时间和实际文件的最后修改时间进行比较。</p>
<ul>
<li>相同就返回状态码304，且不返回数据，客户端拿出缓存数据，渲染页面</li>
<li>不同就返回状态码200，并且返回数据，客户端渲染页面，并且更新缓存</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;当然类似的还有<code>Cache-Control</code>、<code>Expires</code>和<code>Etag</code>，都是为了校验本地缓存文件和服务端是否一致，这里就带过了。</p>
<h3 id="NSURLCache"><a href="#NSURLCache" class="headerlink" title="NSURLCache"></a>NSURLCache</h3><p>&ensp;&ensp;&ensp;&ensp;<code>NSURLCache</code>是iOS系统提供的内存以及磁盘的综合缓存机制。<code>NSURLCache</code>对象被存储沙盒中<code>Library/cache</code>目录下。在我们只需要在<code>didFinishLaunchingWithOptions</code>函数里面加上下面的代码，就可以满足一般的缓存要求。(是的，搞定NSURLCache就是这么简单)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLCache * sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:20 * 1024 *1024 diskCapacity:100 * 1024 * 1024 diskPath:nil];</span><br><span class="line">[NSURLCache setSharedURLCache:sharedCache];</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;下面是几个常用的API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//设置内存缓存的最大容量</span><br><span class="line">[cache setMemoryCapacity:1024 * 1024 * 20];</span><br><span class="line"></span><br><span class="line">//设置磁盘缓存的最大容量</span><br><span class="line">[cache setDiskCapacity:1024 * 1024 * 100];</span><br><span class="line"></span><br><span class="line">//获取某个请求的缓存</span><br><span class="line">[cache cachedResponseForRequest:request];</span><br><span class="line"></span><br><span class="line">//清除某个请求的缓存</span><br><span class="line">[cache removeCachedResponseForRequest:request];</span><br><span class="line"></span><br><span class="line">//请求策略，设置了系统会自动用NSURLCache进行数据缓存</span><br><span class="line">request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;</span><br></pre></td></tr></table></figure></p>
<h3 id="iOS常用的缓存策略"><a href="#iOS常用的缓存策略" class="headerlink" title="iOS常用的缓存策略"></a>iOS常用的缓存策略</h3><p>&ensp;&ensp;&ensp;&ensp;<code>NSURLRequestCachePolicy</code>是个枚举，指的是不同的缓存策略，一共有7种，但是能用的只有4种。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)</span><br><span class="line">&#123;</span><br><span class="line">    //如果有协议，对于特定的URL请求，使用协议实现定义的缓存逻辑。(默认的缓存策略)</span><br><span class="line">    NSURLRequestUseProtocolCachePolicy = 0,</span><br><span class="line"></span><br><span class="line">    //请求仅从原始资源加载URL，不使用任何缓存</span><br><span class="line">    NSURLRequestReloadIgnoringLocalCacheData = 1,</span><br><span class="line"></span><br><span class="line">    //不仅忽略本地缓存，还要忽略协议缓存和其他缓存 (未实现)</span><br><span class="line">    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4,</span><br><span class="line"></span><br><span class="line">    //被NSURLRequestReloadIgnoringLocalCacheData替代</span><br><span class="line">    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,</span><br><span class="line"></span><br><span class="line">    //无视缓存的有效期,有缓存就取缓存，没有缓存就会从原始地址加载</span><br><span class="line">    NSURLRequestReturnCacheDataElseLoad = 2,</span><br><span class="line"></span><br><span class="line">    //无视缓存的有效期，有缓存就取缓存，没有缓存就视为失败 (可以用于离线模式)</span><br><span class="line">    NSURLRequestReturnCacheDataDontLoad = 3,</span><br><span class="line"></span><br><span class="line">    //会从初始地址校验缓存的合法性，合法就用缓存数据，不合法从原始地址加载数据 (未实现)</span><br><span class="line">    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="AFNetworking的缓存策略"><a href="#AFNetworking的缓存策略" class="headerlink" title="AFNetworking的缓存策略"></a>AFNetworking的缓存策略</h2><p>&ensp;&ensp;&ensp;&ensp;之前写了<a href="https://ios-misaki.github.io/iOS-Misaki.github.io/2018/04/11/SDWebImage-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">SDWebImage的源码解析</a> 里面介绍过<code>SDWebImage</code>的缓存策略，有两条线根据时间和空间来管理缓存和<code>AFNetworking</code>很相似。<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>中<code>AFImageDownloader</code>使用<code>AFAutoPurgingImageCache</code>和<code>NSURLCache</code>管理图片缓存。</p>
<h3 id="AFNetworking中的NSURLCache"><a href="#AFNetworking中的NSURLCache" class="headerlink" title="AFNetworking中的NSURLCache"></a>AFNetworking中的NSURLCache</h3><p>&ensp;&ensp;&ensp;&ensp;<code>AFImageDownloader</code>中设置<code>NSURLCache</code>，低版本<code>iOS</code>版本中设置内存容量和磁盘容量会闪退（这个我没有考证，<code>iOS 7</code>的手机还真没有）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([[[UIDevice currentDevice] systemVersion] compare:@&quot;8.2&quot; options:NSNumericSearch] == NSOrderedAscending) </span><br><span class="line">&#123;</span><br><span class="line">    return [NSURLCache sharedURLCache];</span><br><span class="line">&#125;</span><br><span class="line">return [[NSURLCache alloc] initWithMemoryCapacity:20 * 1024 * 1024 diskCapacity:150 * 1024 * 1024 diskPath:@&quot;com.alamofire.imagedownloader&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="AFNetworking中的AFAutoPurgingImageCache"><a href="#AFNetworking中的AFAutoPurgingImageCache" class="headerlink" title="AFNetworking中的AFAutoPurgingImageCache"></a>AFNetworking中的AFAutoPurgingImageCache</h3><p>&ensp;&ensp;&ensp;&ensp;<code>AFAutoPurgingImageCache</code>是专门用来图片缓存的。可以看到内部有三个属性，一个是用来装载<code>AFImageCache</code>对象的字典容器，一个是可以用内存空间大小、一个同步队列。<code>AFAutoPurgingImageCache</code>在初始化的时候，会注册<code>UIApplicationDidReceiveMemoryWarningNotification</code>通知，收到内存警告的时候会清除所有缓存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AFAutoPurgingImageCache ()</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary &lt;NSString* , AFCachedImage*&gt; *cachedImages;</span><br><span class="line">@property (nonatomic, assign) UInt64 currentMemoryUsage;</span><br><span class="line">@property (nonatomic, strong) dispatch_queue_t synchronizationQueue;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;<code>AFCachedImage</code>是单个图片缓存对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UIImage *image;</span><br><span class="line"></span><br><span class="line">//标志符(这个值就是图片的请路径 request.URL.absoluteString)</span><br><span class="line">@property (nonatomic, strong) NSString *identifier;</span><br><span class="line"></span><br><span class="line">//图片大小</span><br><span class="line">@property (nonatomic, assign) UInt64 totalBytes;</span><br><span class="line"></span><br><span class="line">//缓存日期</span><br><span class="line">@property (nonatomic, strong) NSDate *lastAccessDate;</span><br><span class="line"></span><br><span class="line">//当前可用内存空间大小</span><br><span class="line">@property (nonatomic, assign) UInt64 currentMemoryUsage;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;来看看<code>AFCachedImage</code>初始化的时候。<code>iOS</code>使用图标标准是<code>ARGB_8888</code>，即一像素占位4个字节。内存大小 = 宽×高×每像素字节数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)initWithImage:(UIImage *)image identifier:(NSString *)identifier </span><br><span class="line">&#123;</span><br><span class="line">    if (self = [self init]) </span><br><span class="line">    &#123;</span><br><span class="line">        self.image = image;</span><br><span class="line">        self.identifier = identifier;</span><br><span class="line"></span><br><span class="line">        CGSize imageSize = CGSizeMake(image.size.width * image.scale, image.size.height * image.scale);</span><br><span class="line">        CGFloat bytesPerPixel = 4.0;</span><br><span class="line">        CGFloat bytesPerSize = imageSize.width * imageSize.height;</span><br><span class="line">        self.totalBytes = (UInt64)bytesPerPixel * (UInt64)bytesPerSize;</span><br><span class="line">        self.lastAccessDate = [NSDate date];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;来看看添加缓存的代码，用了<code>dispatch_barrier_async</code>栅栏函数将添加操作和删除缓存操作分割开来。每添加一个缓存对象，都重新计算当前缓存大小和可用空间大小。当内存超过设定值时，会按照日期的倒序来遍历缓存图片，删除最早日期的缓存，一直到满足缓存空间为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier </span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</span><br><span class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</span><br><span class="line"></span><br><span class="line">        AFCachedImage *previousCachedImage = self.cachedImages[identifier];</span><br><span class="line">        if (previousCachedImage != nil) </span><br><span class="line">        &#123;</span><br><span class="line">            self.currentMemoryUsage -= previousCachedImage.totalBytes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.cachedImages[identifier] = cacheImage;</span><br><span class="line">        self.currentMemoryUsage += cacheImage.totalBytes;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</span><br><span class="line">        if (self.currentMemoryUsage &gt; self.memoryCapacity) </span><br><span class="line">        &#123;</span><br><span class="line">            UInt64 bytesToPurge = self.currentMemoryUsage - self.preferredMemoryUsageAfterPurge;</span><br><span class="line">            NSMutableArray &lt;AFCachedImage*&gt; *sortedImages = [NSMutableArray arrayWithArray:self.cachedImages.allValues];</span><br><span class="line">            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;lastAccessDate&quot; ascending:YES];</span><br><span class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</span><br><span class="line"></span><br><span class="line">            UInt64 bytesPurged = 0;</span><br><span class="line"></span><br><span class="line">            for (AFCachedImage *cachedImage in sortedImages) </span><br><span class="line">            &#123;</span><br><span class="line">                [self.cachedImages removeObjectForKey:cachedImage.identifier];</span><br><span class="line">                bytesPurged += cachedImage.totalBytes;</span><br><span class="line">                if (bytesPurged &gt;= bytesToPurge) </span><br><span class="line">                &#123;</span><br><span class="line">                    break ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            self.currentMemoryUsage -= bytesPurged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="YTKNetwork的缓存策略"><a href="#YTKNetwork的缓存策略" class="headerlink" title="YTKNetwork的缓存策略"></a>YTKNetwork的缓存策略</h2><p>&ensp;&ensp;&ensp;&ensp;<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork</a>是猿题库技术团队开源的一个网络请求框架，内部封装了<code>AFNetworking</code>。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。笔者在一个电商的<code>PaaS</code>项目中就是使用<code>YTKNetwork</code>，它的特点还有支持请求结果缓存，支持批量请求，支持多请求依赖等。</p>
<h3 id="准备请求之前"><a href="#准备请求之前" class="headerlink" title="准备请求之前"></a>准备请求之前</h3><p>&ensp;&ensp;&ensp;&ensp;先来看看请求基类<code>YTKRequest</code>在请求之前做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)start </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //忽略缓存的标志 手动设置 是否利用缓存</span><br><span class="line">    if (self.ignoreCache) </span><br><span class="line">    &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 还有未完成的请求 是否还有未完成的请求</span><br><span class="line">    if (self.resumableDownloadPath) </span><br><span class="line">    &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载缓存是否成功</span><br><span class="line">    if (![self loadCacheWithError:nil]) </span><br><span class="line">    &#123;</span><br><span class="line">        [self startWithoutCache];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dataFromCache = YES;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">        //将请求数据写入文件</span><br><span class="line">        [self requestCompletePreprocessor];</span><br><span class="line">        [self requestCompleteFilter];</span><br><span class="line"></span><br><span class="line">        //这个时候直接去相应 请求成功的delegate和block ，没有发送请求</span><br><span class="line">        YTKRequest *strongSelf = self;</span><br><span class="line">        [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        if (strongSelf.successCompletionBlock) </span><br><span class="line">        &#123;</span><br><span class="line">            strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将block置空</span><br><span class="line">        [strongSelf clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="缓存数据写入文件"><a href="#缓存数据写入文件" class="headerlink" title="缓存数据写入文件"></a>缓存数据写入文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestCompletePreprocessor </span><br><span class="line">&#123;</span><br><span class="line">    [super requestCompletePreprocessor];</span><br><span class="line"></span><br><span class="line">    if (self.writeCacheAsynchronously) </span><br><span class="line">    &#123;</span><br><span class="line">        dispatch_async(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        [self saveResponseDataToCacheFile:[super responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;<code>ytkrequest_cache_writing_queue</code>是一个优先级比较低的串行队列，当标志<code>dataFromCache</code>为<code>YES</code>的时候，确定能拿到数据，在这个串行队列中异步的写入文件。来看看写入缓存的具体操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveResponseDataToCacheFile:(NSData *)data </span><br><span class="line">&#123;</span><br><span class="line">    if ([self cacheTimeInSeconds] &gt; 0 &amp;&amp; ![self isDataFromCache]) </span><br><span class="line">    &#123;</span><br><span class="line">        if (data != nil) </span><br><span class="line">        &#123;</span><br><span class="line">            @try &#123;</span><br><span class="line">                // New data will always overwrite old data.</span><br><span class="line">                [data writeToFile:[self cacheFilePath] atomically:YES];</span><br><span class="line"></span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [self cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:self];</span><br><span class="line">                metadata.creationDate = [NSDate date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [NSKeyedArchiver archiveRootObject:metadata toFile:[self cacheMetadataFilePath]];</span><br><span class="line">            &#125; @catch (NSException *exception) &#123;</span><br><span class="line">                YTKLog(@&quot;Save cache failed, reason = %@&quot;, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;除了请求数据文件，<code>YTK</code>还会生成一个记录缓存数据信息的元数据<code>YTKCacheMetadata</code>对象。<code>YTKCacheMetadata</code>记录了缓存的版本号、敏感信息、缓存日期和App的版本号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) long long version;</span><br><span class="line">@property (nonatomic, strong) NSString *sensitiveDataString;</span><br><span class="line">@property (nonatomic, assign) NSStringEncoding stringEncoding;</span><br><span class="line">@property (nonatomic, strong) NSDate *creationDate;</span><br><span class="line">@property (nonatomic, strong) NSString *appVersionString;</span><br></pre></td></tr></table></figure></p>
<p>&ensp;&ensp;&ensp;&ensp;然后把请求方法、请求域名、请求URL和请求参数组成的字符串进行一次<code>MD5</code>加密，作为缓存文件的名称。<code>YTKCacheMetadata</code>和缓存文件同名，多了一个<code>.metadata</code>的后缀作为区分。文件写入的路径是沙盒中<code>Library/LazyRequestCache</code>目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)cacheFileName </span><br><span class="line">&#123;</span><br><span class="line">    NSString *requestUrl = [self requestUrl];</span><br><span class="line">    NSString *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    id argument = [self cacheFileNameFilterForRequestArgument:[self requestArgument]];</span><br><span class="line">    NSString *requestInfo = [NSString stringWithFormat:@&quot;Method:%ld Host:%@ Url:%@ Argument:%@&quot;,</span><br><span class="line">    (long)[self requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    NSString *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    return cacheFileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1487718-b3a080f6739c49cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork缓存文件路径.png"></p>
<h3 id="校验缓存"><a href="#校验缓存" class="headerlink" title="校验缓存"></a>校验缓存</h3><p>&ensp;&ensp;&ensp;&ensp;回到start方法中，<code>loadCacheWithError</code>是校验缓存能不能成功加载出来，<code>loadCacheWithError</code>中会调用<code>validateCacheWithError</code>来检验缓存的合法性，校验的依据正是<code>YTKCacheMetadata</code>和<code>cacheTimeInSeconds</code>。要想使用缓存数据，请求实例要重写<code>cacheTimeInSeconds</code>设置一个大于0的值，而且缓存还支持版本、App的版本。在实际项目上应用，<code>get</code>请求实例设置一个<code>cacheTimeInSeconds</code>就够用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateCacheWithError:(NSError * _Nullable __autoreleasing *)error     </span><br><span class="line">&#123;</span><br><span class="line">    // Date</span><br><span class="line">    NSDate *creationDate = self.cacheMetadata.creationDate;</span><br><span class="line">    NSTimeInterval duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    if (duration &lt; 0 || duration &gt; [self cacheTimeInSeconds]) </span><br><span class="line">    &#123;</span><br><span class="line">        if (error) </span><br><span class="line">        &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache expired&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // Version</span><br><span class="line">    long long cacheVersionFileContent = self.cacheMetadata.version;</span><br><span class="line">    if (cacheVersionFileContent != [self cacheVersion]) </span><br><span class="line">    &#123;</span><br><span class="line">        if (error) </span><br><span class="line">        &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache version mismatch&quot;&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    // Sensitive data</span><br><span class="line">    NSString *sensitiveDataString = self.cacheMetadata.sensitiveDataString;</span><br><span class="line">    NSString *currentSensitiveDataString = ((NSObject *)[self cacheSensitiveData]).description;</span><br><span class="line">    if (sensitiveDataString || currentSensitiveDataString) </span><br><span class="line">    &#123;</span><br><span class="line">        // If one of the strings is nil, short-circuit evaluation will trigger</span><br><span class="line">        if (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) </span><br><span class="line">        &#123;</span><br><span class="line">            if (error) </span><br><span class="line">            &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;Cache sensitive data mismatch&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // App version</span><br><span class="line">    NSString *appVersionString = self.cacheMetadata.appVersionString;</span><br><span class="line">    NSString *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    if (appVersionString || currentAppVersionString) </span><br><span class="line">    &#123;</span><br><span class="line">        if (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) </span><br><span class="line">        &#123;</span><br><span class="line">            if (error) </span><br><span class="line">            &#123;</span><br><span class="line">                *error = [NSError errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; NSLocalizedDescriptionKey:@&quot;App version mismatch&quot;&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><p>&ensp;&ensp;&ensp;&ensp;因为缓存的目录是<code>Library/LazyRequestCache</code>，清除缓存就直接清空目录下所有文件就可以了。调用<code>[[YTKNetworkConfig sharedConfig] clearCacheDirPathFilter]</code>就行。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>缓存的本质是用空间换取时间。大学里面学过的《计算机组成原理》中就有介绍<code>cache</code>，除了磁盘和内存,还有L1和L2，对于iOS开发者来说，一般关注<code>disk</code>和<code>memory</code>就够了。阅读<code>SDWebImage、AFNetworking、YTKNetwork</code>的源码后，可以看出他们都非常重视数据的多线程的读写安全，在做深度优化时候，因地制宜，及时清理缓存文件。</strong></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://yuyi-1257105666.cos.ap-beijing.myqcloud.com/wechatpay.png" alt="Misaki 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="https://yuyi-1257105666.cos.ap-beijing.myqcloud.com/alipay.png" alt="Misaki 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/iOS-Misaki.github.io/2018/11/28/组件化遇到的问题/" rel="next" title="组件化遇到的问题">
                <i class="fa fa-chevron-left"></i> 组件化遇到的问题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zODM3OS8xNDkwNw"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/iOS-Misaki.github.io/images/avatar.png"
                alt="Misaki" />
            
              <p class="site-author-name" itemprop="name">Misaki</p>
              <p class="site-description motion-element" itemprop="description">一个热爱二次元、沉迷炒币的iOS开发者</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/iOS-Misaki.github.io/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/iOS-Misaki.github.io/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/iOS-Misaki" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/abb55beb0e35" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/3241094067" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://space.bilibili.com/14658855/#/" target="_blank" title="bilibili">
                      
                        <i class="fa fa-fw fa-tv"></i>bilibili</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://user.qzone.qq.com/1204396551/main" target="_blank" title="QQ空间">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ空间</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yuyiios" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/ui_misaki" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS系统的缓存策略"><span class="nav-number">1.</span> <span class="nav-text">iOS系统的缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务端的缓存策略"><span class="nav-number">1.1.</span> <span class="nav-text">服务端的缓存策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSURLCache"><span class="nav-number">1.2.</span> <span class="nav-text">NSURLCache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS常用的缓存策略"><span class="nav-number">1.3.</span> <span class="nav-text">iOS常用的缓存策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AFNetworking的缓存策略"><span class="nav-number">2.</span> <span class="nav-text">AFNetworking的缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetworking中的NSURLCache"><span class="nav-number">2.1.</span> <span class="nav-text">AFNetworking中的NSURLCache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetworking中的AFAutoPurgingImageCache"><span class="nav-number">2.2.</span> <span class="nav-text">AFNetworking中的AFAutoPurgingImageCache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#YTKNetwork的缓存策略"><span class="nav-number">3.</span> <span class="nav-text">YTKNetwork的缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#准备请求之前"><span class="nav-number">3.1.</span> <span class="nav-text">准备请求之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存数据写入文件"><span class="nav-number">3.2.</span> <span class="nav-text">缓存数据写入文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#校验缓存"><span class="nav-number">3.3.</span> <span class="nav-text">校验缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清除缓存"><span class="nav-number">3.4.</span> <span class="nav-text">清除缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">4.</span> <span class="nav-text">结语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Misaki</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_page_pv">
  本文阅读数:<span id="busuanzi_value_page_pv"></span>
</span>
</div>






        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/iOS-Misaki.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/iOS-Misaki.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/iOS-Misaki.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/iOS-Misaki.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/iOS-Misaki.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/iOS-Misaki.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/iOS-Misaki.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/iOS-Misaki.github.io/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/iOS-Misaki.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/iOS-Misaki.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/iOS-Misaki.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
